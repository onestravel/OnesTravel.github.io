[{"title":"【并发编程】线程基础","url":"https://blog.onestravel.cn/20210920/f8c53c115779/","content":"【并发编程】线程基础一. 实现线程的方式1. 为何说只有一种实现线程的方式1.1 常见的实现线程的方式1.1.1 继承Thread类继承 Thread 类，并重写其中的 run() 方法。\npublic class DemoThread extends Thread {\n\n    @Override\n    public void run() {\n        System.out.println('用Thread类实现线程');\n    }\n}\n1.1.2 实现 Runnable 接口实现 Runnable 接口，实现其 run() 方法，然后将实现了 Runnable 接口的实例传递到 Thread 类中就可以实现多线程。 \npublic class RunnableThread implements Runnable {\n\n    @Override\n    public void run() {\n        System.out.println('用实现Runnable接口实现线程');\n    }\n}\n1.1.3 线程池创建线程通过线程池来创建线程。线程中实现了很多线程，我们可以通过其构造器指定该线程池允许创建的线程的最大数量；比如：我们将线程池的数量设置为10，那么就将会有10个子线程来为我们工作。接下来，我们通过线程池中的代码来看看线程池是怎么创建线程的。\nstatic class DefaultThreadFactory implements ThreadFactory {\n\n    DefaultThreadFactory() {\n        SecurityManager s = System.getSecurityManager();\n        group = (s != null) ? s.getThreadGroup() :\n            Thread.currentThread().getThreadGroup();\n        namePrefix = \"pool-\" +\n            poolNumber.getAndIncrement() +\n            \"-thread-\";\n    }\n\n\n    public Thread newThread(Runnable r) {\n        Thread t = new Thread(group, r,\n                    namePrefix + threadNumber.getAndIncrement(),\n0);\n\n        if (t.isDaemon())\n            t.setDaemon(false);\n        if (t.getPriority() != Thread.NORM_PRIORITY)\n            t.setPriority(Thread.NORM_PRIORITY);\n        return t;\n    }\n}\n对于线程池而言，本质上是通过线程工厂来创建线程的，默认采用 DefaultThreadFactory，它会给线程池创建的线程设置一些默认值，比如：线程的名字、是否是守护线程、线程的优先级等；最终还是通过 new Thread() 来创建线程，只是构造方法中传入的参数多一些。\n1.1.4 有返回值的 Callable 创建线程Runnable 创建的线程时没有返回值的，而 Callable 和与之相关的 Future 和 FutureTask 可以把线程执行的结果作为返回值返回。如代码所示：实现 Callable 接口，并且泛型设置为 Integer ,然后返回一个随机整数。\nclass CallableTask implements Callable&lt;Integer> {\n\n    @Override\n    public Integer call() throws Exception {\n        return new Random().nextInt();\n    }\n}\n\n//创建线程池\nExecutorService service = Executors.newFixedThreadPool(10);\n//提交任务，并用 Future提交返回结果\nFuture&lt;Integer> future = service.submit(new CallableTask());\n无论是 Callable 还是 FutureTask ，它们首先和 Runnable 一样都是一个任务，是需要被执行的，而不是说它们本身就是一个线程。它们可以放到线程池中执行：如代码所示，submit() 方法把任务放到线程池中，并由线程池创建线程。\n1.2 总结，为什么实现线程只有一种方式根据前面的实现线程的方式，我们可以看到比如线程池、定时器等仅仅只是在 new Thread() 之外做了一层封装；最终都还是通过实现 Runnable 接口或者继承 Thread 类来实现的。\n我们知道，启动线程的方式是调用 start() 方法，然后在 start() 方法中最终会调 run() 方法。\n我们来看 Thread 类的时候可以发现，在 Thread 类的 run() 方法中做了如下操作： 判断 target 不为 null 的情况下，调用 target 的 run() 方法；而 target 实际上就是 Runnable 接口的一个实例，即使用 Runnable 接口实现线程时传给Thread类的对象。\n继承 Thread 类，然后重写 run() 方法，重写后的run()方法中就是需要执行的任务，最终还是调用 start() 方法来启动线程。\n所以创建线程就只有一种方式，就是构造一个 Thread 类，这是创建线程的唯一方式。\n上面看到的实现线程的两种方式本质上都是一样的，就是构造一个 Thread 类，不同点在于实现线程运行内容的不同 ：要买来自重写的 run() 方法，要么来自 target 的 run() 方法。\n所以我们可以这样描述：\n本质上，实现线程只有一种方式，而要想实现线程执行的内容，却有两种方式，也就是可以通过 实现 Runnable 接口的方式，或是继承 Thread 类重写 run() 方法的方式，把我们想要执行的代码传入，让线程去执行，在此基础上，如果我们还想有更多实现线程的方式，比如线程池和 Timer 定时器，只需要在此基础上进行封装即可。\n2. 为什么说实现 Runnable 接口比继承 Thread 类实现线程要好我们来总结一下实现 Runnable 接口比继承 Thread 类实现线程好在哪里？\n\n从代码架构考虑： Runnable 接口只有一个 run() 方法，它定义了需要执行的内容，在这种情况些 实现了 Runnable 类和 Thread 类的解耦；Thread 类负责启动线程和设置属性等，权责分明。\n从性能考虑：使用继承 Thread 类来实现线程，没执行依次任务，就需要创建一个独立的线程；执行完成之后到生命周期的尽头，如果需要再次执行，就必须重新创建一个线程；在线程执行的任务量比较大的时候，带来的开销也很大。如果使用实现 Runnable 接口的方式来实现线程，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建/销毁线程，大大降低了性能开销。\n从拓展性考虑：Java 语言不执行多继承，如果类一旦继承了 Thread 类，那么后续就不能继承其他的类。如果该类需要继承其他的一些类来实现功能上的拓展，就显得很局限了，限制了代码的拓展性。而Java运行多实现，则实现Runnable 接口方式来实现线程，则不会限制代码的拓展性。\n\n综上所述：\n应该优先选择通过实现 Runnable 接口的方式来创建线程。\n二. 如何正确停止线程通长情况下，我们不会停止一个线程，而是允许线程运行到结束，然后让它自然停止。但是依然也有许多特殊情况需要手动停止线程，比如：用户突然关闭程序，程序出错重启等。\n1. 正确停止线程对于Java 程序而言，最正确的停止线程的方式是 interrupt,但 interrupt 仅仅起到通知被停止线程的作用。对于被停止线程而言，它完全具有自主权，可以选择立即停止 、过一会停止，或者不停止。那么为什么Java不提供强制停止线程的能力呢？\n其实，Java 希望程序间能够相互通知，相互协作的管理线程，因为如果在不知道对方线程正在做的工作，贸然停止线程就可能造成一些安全问题，为了避免问题，就需要给对方线程一定的事件来处理收尾工作。 \n1.1 用 interrupt 停止线程while (!Thread.currentThread().islnterrupted() &amp;&amp; more work flag) {\n    //do more work\n}\n一旦调用某个线程的 interrupt() 方法之后，这个线程的中断标记为就会被置为 true ；每个线程都有这样的标记位，当线程执行时，应该定期检查该标志位，如果标记为被置为 true ，就说明有程序想终止该线程。\n在上面的代码中看到，在 while 循环体判断语句中，首先通过 Thread.currentThread().islnterrupted() 判断线程是否被中断，随后检查是否还有工作要做的标志位，两个条件都满足的情况下，才会继续执行下面的工作。\neg:\npublic class StopThread implements Runnable {\n\n    @Override\n    public void run() {\n        int count = 0;\n        while (!Thread.currentThread().isInterrupted() &amp;&amp; count &lt; 1000) {\n            System.out.println(\"count = \" + count++);\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(new StopThread());\n        thread.start();\n        Thread.sleep(5);\n        thread.interrupt();\n    }\n}\n在 StopThread 类的 run() 方法中，首先判断线程是否被中断，然后判断 count 是否小于 1000。这线程的工作内容就是打印0~999的数字，每打印一个数字，count 加 1 ；可以看到每次开始之前都会检查线程是否被中断。\n在 main 函数中启动该线程，然后过 5 毫秒之后立刻终止线程，该线程会检测中断信号，于是在线程未执行完就会停止，这种就属于通过 interrupt 正确停止线程的情况。\n1.2 sleep 期间能否感受到中断现在我们考虑一种特殊情况：在线程执行过程中有休眠需求，也就是每打印一次，进入一次 sleep ，将 sleep 时间设置为 10 秒；则改造后的代码如下\nRunnable runnable = () -> {\n    int num = 0;\n    try {\n        while (!Thread.currentThread().isInterrupted() &amp;&amp; \n        num &lt;= 1000) {\n            System.out.println(num);\n            num++;\n            Thread.sleep(10000);\n        }\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n};\npublic class StopDuringSleep {\n\n    public static void main(String[] args) throws InterruptedException {\n        Runnable runnable = () -> {\n            int num = 0;\n            try {\n                while (!Thread.currentThread().isInterrupted() &amp;&amp; num &lt;= 1000) {\n                    System.out.println(num);\n                    num++;\n                    Thread.sleep(1000000);\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        };\n        Thread thread = new Thread(runnable);\n        thread.start();\n        Thread.sleep(5);\n        thread.interrupt();\n    }\n}\n在主线程休眠 5 毫秒后，通知子线程中断，此时子线程仍然在执行 sleep 语句，处于休眠中。那么就需要考虑，在休眠中的线程能否感受到中断通知呢？如果需要等到线程休眠结束后，那岂不响应中断太不及时了。\n在 Java 设计之初，如果 sleep,wait 等可以让线程进入阻塞的方法使得线程休眠了，而处于休眠中的线程被中断，那么线程是可以感受到中断信号的，并且会抛出一个 InterruptedException 异常，同时清除中断信号，将中断标记为置为false；这样，就不用担心长时间休眠中的线程感受不到中断了，因为即便现在还在休眠中，仍然能够响应中断通知，并抛出异常。\n1.3 相应中断的两种最佳处理方式在实际开发中肯定是团队协作的，不同的人负责编写不同的方法，然后相互调用来实现整个业务的逻辑。那么如果我们负责编写的方法需要被别人调用，同时我们的方法内调用了 sleep 或者 wait 等能响应中断的方法时，仅仅 catch 住异常是不够的。\nprivate void subTas() {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        // 在这里不处理该异常是非常不好的\n    }\n}\n我们可以在方法中使用 try/catch 或在方法签名中声明 throws  InterruptedException。\n1.3.1 方法签名抛异常，run() 强制 try/catch上面代码所示 catch 语句块里是空的，并没有进行任何处理。假设线程执行到这个方法，并且正在 sleep ，此时有线程发送 interrupt 通知试图中断线程，就会抛出异常，并清除中断信号。抛出的异常被 catch 语句块捕捉。\n但是，捕捉到异常的 catch 没有进行任何处理逻辑，相当于把中断信号给隐藏了，这样做是很不合理的。我们可以选择在方法签名中抛出异常\nvoid subTask2() throws InterruptedException {\n    Thread.sleep(1000);\n}\n正如代码所示：要求每一个方法的调用方有义务去处理异常。调用方要不使用 try/catch 并在 catch 中正确处理异常，要不将异常声明到方法签名中。如果每层逻辑都遵守规范，便可以将中断信号传递到顶层，最终让 run() 方法可以捕获异常。对于 run() 方法而言，它本身没有抛出异常的能力，只能通过 try/catch 来处理异常；可以根据不同的业务逻辑来进行相应的处理。\n1.3.2 再次中断private void reInterrupt() {\n    try {\n        Thread.sleep(2000);\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        e.printStackTrace();\n    }\n}\n除了刚刚推荐的将异常声明到方法签名中的方式以外，还可以在 catch 语句中再次中断线程。如代码所示，需要在 catch 语句块中调用 Thread.currentThread().interrupt()函数。因为如果线程在休眠期间被中断，那么会自动清除中断信号。如果这时候手动添加中断信号，中断信号依然可以被捕捉到。这样后续执行的方法依然可以检测到这里发生过中断，可以做出相应的处理，整个线程可以正常退出\n2. 为什么 volatile 标记位的停止方法是错误的？2.1 错误的停止方法首先，我们来看几种线程停止的错误的方法：比如：stop() , suspend() 和 resume(),这些方法已经被 Java 标记为 @Deprecated。我们不应该再使用它们。因为 stop() 会直接把线程停止，这样就没有给足够的事件来处理想要在停止之前保存数据的逻辑，任务嘎然而止，会导致出现数据完整性等问题。\n对于 suspend() 和 resume() 而言，它们的问题在于如果线程调用 suspend() ,它并不会释放锁，就开始进入休眠，但此时有可能扔持有锁，这样就容易导致死锁，因为这把锁在线程被 resume() 之前，是不会释放的。\n正因为有这样的风险，所以 suspend() 和 resume() 组合使用的方式也被废弃了。\n接下来我们来看一下，为什么用 volatile 标记位的停止方法也是错误的？\n2.2 volatile 修饰标记位使用的场景public class VolatileCanStop implements Runnable {\n\n    private volatile boolean canceled = false;\n\n    @Override\n    public void run() {\n        int num = 0;\n        try {\n            while (!canceled &amp;&amp; num &lt;= 1000000) {\n                if (num % 10 == 0) {\n                    System.out.println(num + \"是10的倍数。\");\n                }\n                num++;\n                Thread.sleep(1);\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        VolatileCanStop r = new VolatileCanStop();\n        Thread thread = new Thread(r);\n        thread.start();\n        Thread.sleep(3000);\n        r.canceled = true;\n    }\n}\n如代码所示：声明了一个叫做 VolatileStopThread 的类，它实现了 Runnable 接口，然后在 run() 中进行 while 循环，在循环体中进行了两层判断，首先判断 canceled 变量的值（canceled 变量是一个被 volatile 修饰的初始值为 false 的布尔值），当该值变为 true 时，while 跳出循环，while 第二个判断是 num 值小于 1000000 ，在 while 循环体中，只要是10的倍数，就打印出来，然后 num++ 。\n接下来，在 main() 方法中，首先启动线程，然后经过3秒中的时间， 把用 volatile 修饰的布尔值标记位设置为 true，这样，正在运行的线程就会在下一次 while 循环判断中判断出 canceled 的值已经变为 true 了，这样就不再满足 while 的判断条件，跳出整个 while 循环，线程就停止了，这种情况是演示 volatile 修饰的标记位可以正常工作的情况。\n2.3 volatile 修饰标记位不适用的场景class Producer implements Runnable {\n    public volatile boolean canceled = false;\n    BlockingQueue storage;\n    public Producer(BlockingQueue storage) {\n        this.storage = storage;\n    }\n\n    @Override\n    public void run() {\n        int num = 0;\n        try {\n            while (num &lt;= 100000 &amp;&amp; !canceled) {\n                if (num % 50 == 0) {\n                    storage.put(num);\n                    System.out.println(num + \"是50的倍数,被放到仓库中了。\");\n                }\n                num++;\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            System.out.println(\"生产者结束运行\");\n        }\n    }\n}\n首先，声明了一个生产者 Producer ，通过 volatile 标记的初始值为 false 的布尔值 canceled 来停止线程。在 run() 方法中， while 的判断语句是 num 是否小于 100000 以及 canceled 是否被标记。while 循环体中判断 num 如果是 50 的倍数就放到 storage 仓库中 ，storage 是生产者与消费者质检通信的存储器，当 num 大于 100000 或被通知停止时，会跳出 while 循环并执行 finally 语句块，告诉大家 『生产者结束运行』\nclass Consumer {\n    BlockingQueue storage;\n    public Consumer(BlockingQueue storage) {\n        this.storage = storage;\n    }\n    public boolean needMoreNums() {\n        if (Math.random() > 0.97) {\n            return false;\n        }\n        return true;\n    }\n}\n对于消费者 Consumer ，它与生产者共用同一个仓库 storage ，并且在方法内通过 needMoreNums() 方法判断是否需要继续使用更多的数字，刚才生产者生产了一些 50 的倍数供消费者使用，消费者是否继续使用数字的判断条件时产生一个随机数并与 0.97 进行比较，大于 0.97 就不在继续使用数字。\npublic static void main(String[] args) throws InterruptedException {\n        ArrayBlockingQueue storage = new ArrayBlockingQueue(8);\n\n        Producer producer = new Producer(storage);\n        Thread producerThread = new Thread(producer);\n        producerThread.start();\n        Thread.sleep(500);\n\n        Consumer consumer = new Consumer(storage);\n        while (consumer.needMoreNums()) {\n            System.out.println(consumer.storage.take() + \"被消费了\");\n            Thread.sleep(100);\n        }\n        System.out.println(\"消费者不需要更多数据了。\");\n\n        //一旦消费不需要更多数据了，我们应该让生产者也停下来，但是实际情况却停不下来\n        producer.canceled = true;\n        System.out.println(producer.canceled);\n    }\n}\n在 main() 函数中，首先创建了生产者/消费者共用的仓库 BlockingQueue storage，仓库容量是 8，并且建立生产者并将生产者放入线程后启动线程，启动后进行 500 毫秒的休眠，这是生产者会阻塞， 500 毫秒后消费者被创建出来，并判断是否需要更多的数字，然后每次消费后休眠 100 毫秒，这样的业务逻辑是有可能出现在实际生产中的。\n当消费者不再需要数据，就会将 canceled 的标记位设置为 true ，理论上此时生产者就会跳出 while 循环，并打印出 『 生产者运行结束』。\n然而结果并不是我们想象的那样，尽管已经把 canceled 设置为 true ， 但生产者仍然没有停止，这是因为在这种情况下，生产者在执行 storage.put(num) 时发生阻塞，在它被唤醒之前是没办法进入下一次循环判断 canceled 的值的，所以这种情况下用 volatile 是没有办法让生产者停下来的，相反如果用 interrupt 语句来中断，即便生产者处理阻塞状态，仍然能够感受到中断信号，并做响应处理。\n三. 线程的6中状态的切换1. 线程的6中状态在 Java 中线程的生命周期中一共有6种状态\n\nNew（新建）\nRunnable（可运行）\nBlocked（被阻塞）\nWaiting（等待）\nTimed Waiting（计时等待）\nTerminated （被终止）\n\n如果想要确定线程当前的状态，可以通过 getState() 方法，并且线程在任何时刻只可能处于 1 种状态。\n下面我们来逐个介绍线程的 6 种状态：\n1.1 New 新创建\n\nNew 表示线程被创建但尚未启动的状态：当我们用 new Thread() 新建一个线程时，如果线程没有开始运行 start() 方法，所以也没有开始执行 run() 方法里面的代码，那么此时它的状态就是 New。而一旦线程调用了 start()，它的状态就会从 New 变成 Runnable状态。\n1.2 Runnable 可运行\n\nJava 中的 Runable 状态对应操作系统线程状态中的两种状态，分别是 Running 和 Ready，也就是说，Java 中处于 Runnable 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。\n所以，如果一个正在运行的线程是 Runnable 状态，当它运行到任务的一半时，执行该线程的 CPU 被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是 Runnable，因为它有可能随时被调度回来继续执行任务。\n1.3 Blocked 阻塞状态\n\n从 Runnable 状态进入 Blocked 状态只有一种可能，就是进入 synchronized 保护的代码时没有抢到 monitor 锁，无论是进入 synchronized 代码块，还是 synchronized 方法；当处于 Blocked 的线程抢到 monitor 锁，就会从 Blocked 状态回到Runnable 状态。\n1.4 Waiting 等待\n\n线程进入 Waiting 状态有三种可能性。\n\n没有设置 Timeout 参数的 Object.wait() 方法。\n没有设置 Timeout 参数的 Thread.join() 方法。\nLockSupport.park() 方法。\n\n刚才强调过，Blocked 仅仅针对 synchronized monitor 锁，可是在 Java 中还有很多其他的锁，比如 ReentrantLock，如果线程在获取这种锁时没有抢到该锁就会进入 Waiting 状态，因为本质上它执行了 LockSupport.park() 方法，所以会进入 Waiting 状态。同样，Object.wait() 和 Thread.join() 也会让线程进入 Waiting 状态。 \nBlocked 与 Waiting 的区别是 Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()/notifyAll() 。\n1.5 Timed Waiting 限期等待\n\n在 Waiting 上面是 Timed Waiting 状态，这两个状态是非常相似的，区别仅在于有没有时间限制，Timed Waiting 会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒。\n以下情况会让线程进入 Timed Waiting 状态。\n\n设置了时间参数的 Thread.sleep(long millis) 方法；\n设置了时间参数的 Object.wait(long timeout) 方法；\n设置了时间参数的 Thread.join(long millis) 方法；\n设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。\n\n如果其他线程调用 notify() 或 notifyAll()来唤醒它，它会直接进入 Blocked 状态，这是为什么呢？因为唤醒 Waiting 线程的线程如果调用 notify() 或 notifyAll()，要求必须首先持有该 monitor 锁，所以处于 Waiting 状态的线程被唤醒时拿不到该锁，就会进入 Blocked 状态，直到执行了 notify()/notifyAll() 的唤醒它的线程执行完毕并释放 monitor 锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从 Blocked 状态回到 Runnable 状态。\n同样在 Timed Waiting 中执行 notify() 和 notifyAll() 也是一样的道理，它们会先进入 Blocked 状态，然后抢夺锁成功后，再回到 Runnable 状态。\n当然对于 Timed Waiting 而言，如果它的超时时间到了且能直接获取到锁/join的线程运行结束/被中断/调用了LockSupport.unpark()，会直接恢复到 Runnable 状态，而无需经历 Blocked 状态。\n1.6 Terminated 终止\n\n要想进入这个Terminated 终止状态有两种可能。\n\nrun() 方法执行完毕，线程正常退出。\n\n出现一个没有捕获的异常，终止了 run() 方法，最终导致意外终止。\n\n\n注意点最后我们再看线程转换的两个注意点。\n\n线程的状态是需要按照箭头方向来走的，比如线程从 New 状态是不可以直接进入 Blocked 状态的，它需要先经历 Runnable 状态。\n线程生命周期不可逆：一旦进入 Runnable 状态就不能回到 New 状态；一旦被终止就不可能再有任何状态的变化。所以一个线程只能有一次 New 和 Terminated 状态，只有处于中间状态才可以相互转换。\n\n四. wait/notify/notifyAll 方法的使用注意事项从以下三个问题入手学习 wait/notify/notifyAll 方法的使用注意事项：\n\n为什么 wait 方法必须在 synchronized 保护的同步代码中使用？\n为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？\nwait/notify 和 sleep 方法的异同？\n\n1. 为什么 wait 方法必须在 synchronized 保护的同步代码中使用？首先，我们来看看 wait 方法的源码注释是怎么写的。\n“wait method should always be used in a loop:\n synchronized (obj) {\n     while (condition does not hold)\n         obj.wait();\n     ... // Perform action appropriate to condition\n}\nThis method should only be called by a thread that is the owner of this object’s monitor.”\n意思是说，在使用 wait 方法时，必须把 wait 方法写在 synchronized 保护的 while 代码块中，并始终判断执行条件是否满足，如果满足就往下继续执行，如果不满足就执行 wait 方法，而在执行 wait 方法之前，必须先持有对象的 monitor 锁，也就是通常所说的 synchronized 锁。那么设计成这样有什么好处呢？\n我们逆向思考这个问题，如果不要求 wait 方法放在 synchronized 保护的同步代码中使用，而是可以随意调用，那么就有可能写出这样的代码。\nclass BlockingQueue {\n    Queue&lt;String> buffer = new LinkedList&lt;String>();\n    public void give(String data) {\n        buffer.add(data);\n        notify();  // Since someone may be waiting in take\n    }\n    public String take() throws InterruptedException {\n        while (buffer.isEmpty()) {\n            wait();\n        }\n        return buffer.remove();\n    }\n}\n在代码中可以看到有两个方法，give 方法负责往 buffer 中添加数据，添加完之后执行 notify 方法来唤醒之前等待的线程，而 take 方法负责检查整个 buffer 是否为空，如果为空就进入等待，如果不为空就取出一个数据，这是典型的生产者消费者的思想。\n但是这段代码并没有受 synchronized 保护，于是便有可能发生以下场景：\n\n首先，消费者线程调用 take 方法并判断 buffer.isEmpty 方法是否返回 true，若为 true 代表buffer是空的，则线程希望进入等待，但是在线程调用 wait 方法之前，就被调度器暂停了，所以此时还没来得及执行 wait 方法。\n此时生产者开始运行，执行了整个 give 方法，它往 buffer 中添加了数据，并执行了 notify 方法，但 notify 并没有任何效果，因为消费者线程的 wait 方法没来得及执行，所以没有线程在等待被唤醒。\n此时，刚才被调度器暂停的消费者线程回来继续执行 wait 方法并进入了等待。虽然刚才消费者判断了 buffer.isEmpty 条件，但真正执行 wait 方法时，之前的 buffer.isEmpty 的结果已经过期了，不再符合最新的场景了，因为这里的“判断-执行”不是一个原子操作，它在中间被打断了，是线程不安全的。\n\n假设这时没有更多的生产者进行生产，消费者便有可能陷入无穷无尽的等待，因为它错过了刚才 give 方法内的 notify 的唤醒。\n我们看到正是因为 wait 方法所在的 take 方法没有被 synchronized 保护，所以它的 while 判断和 wait 方法无法构成原子操作，那么此时整个程序就很容易出错。\n我们把代码改写成源码注释所要求的被 synchronized 保护的同步代码块的形式，代码如下:\npublic void give(String data) {\n   synchronized (this) {\n      buffer.add(data);\n      notify();\n  }\n}\n\npublic String take() throws InterruptedException {\n   synchronized (this) {\n    while (buffer.isEmpty()) {\n         wait();\n       }\n     return buffer.remove();\n  }\n}\n这样就可以确保 notify 方法永远不会在 buffer.isEmpty 和 wait 方法之间被调用，提升了程序的安全性。\n另外，wait 方法会释放 monitor 锁，这也要求我们必须首先进入到 synchronized 内持有这把锁。\n这里还存在一个“虚假唤醒”（spurious wakeup）的问题，线程可能在既没有被notify/notifyAll，也没有被中断或者超时的情况下被唤醒，这种唤醒是我们不希望看到的。虽然在实际生产中，虚假唤醒发生的概率很小，但是程序依然需要保证在发生虚假唤醒的时候的正确性，所以就需要采用while循环的结构。\nwhile (condition does not hold)\n    obj.wait();\n这样即便被虚假唤醒了，也会再次检查while里面的条件，如果不满足条件，就会继续wait，也就消除了虚假唤醒的风险。\n2. 为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？为什么 wait/notify/notifyAll 方法被定义在 Object 类中？而 sleep 方法定义在 Thread 类中？主要有两点原因：\n\n因为 Java 中每个对象都有一把称之为 monitor 监视器的锁，由于每个对象都可以上锁，这就要求在对象头中有一个用来保存锁信息的位置。这个锁是对象级别的，而非线程级别的，wait/notify/notifyAll 也都是锁级别的操作，它们的锁属于对象，所以把它们定义在 Object 类中是最合适，因为 Object 类是所有对象的父类。\n因为如果把 wait/notify/notifyAll 方法定义在 Thread 类中，会带来很大的局限性，比如一个线程可能持有多把锁，以便实现相互配合的复杂逻辑，假设此时 wait 方法定义在 Thread 类中，如何实现让一个线程持有多把锁呢？又如何明确线程等待的是哪把锁呢？既然我们是让当前线程去等待某个对象的锁，自然应该通过操作对象来实现，而不是操作线程。\n\n3. wait/notify 和 sleep 方法的异同对比 wait/notify 和 sleep 方法的异同，主要对比 wait 和 sleep 方法，我们先说相同点：\n\n它们都可以让线程阻塞。\n\n它们都可以响应 interrupt 中断：在等待的过程中如果收到中断信号，都可以进行响应，并抛出 InterruptedException 异常。\n\n\n但是它们也有很多的不同点：\n\nwait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求。\n在同步代码中执行 sleep 方法时，并不会释放 monitor 锁，但执行 wait 方法时会主动释放 monitor 锁。\nsleep 方法中会要求必须定义一个时间，时间到期后会主动恢复，而对于没有参数的 wait 方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并不会主动恢复。\nwait/notify 是 Object 类的方法，而 sleep 是 Thread 类的方法。\n\n五. 有哪几种实现生产者消费者模式的方法5.1 生产者消费者模式我们先来看看什么是生产者消费者模式，生产者消费者模式是程序设计中非常常见的一种设计模式，被广泛运用在解耦、消息队列等场景。在现实世界中，我们把生产商品的一方称为生产者，把消费商品的一方称为消费者，有时生产者的生产速度特别快，但消费者的消费速度跟不上，俗称“产能过剩”，又或是多个生产者对应多个消费者时，大家可能会手忙脚乱。如何才能让大家更好地配合呢？这时在生产者和消费者之间就需要一个中介来进行调度，于是便诞生了生产者消费者模式。\n\n\n使用生产者消费者模式通常需要在两者之间增加一个阻塞队列作为媒介，有了媒介之后就相当于有了一个缓冲，平衡了两者的能力，整体的设计如图所示，最上面是阻塞队列，右侧的 1 是生产者线程，生产者在生产数据后将数据存放在阻塞队列中，左侧的 2 是消费者线程，消费者获取阻塞队列中的数据。而中间的 3 和 4 分别代表生产者消费者之间互相通信的过程，因为无论阻塞队列是满还是空都可能会产生阻塞，阻塞之后就需要在合适的时机去唤醒被阻塞的线程。\n那么什么时候阻塞线程需要被唤醒呢？有两种情况:\n\n第一种情况是当消费者看到阻塞队列为空时，开始进入等待，这时生产者一旦往队列中放入数据，就会通知所有的消费者，唤醒阻塞的消费者线程。\n另一种情况是如果生产者发现队列已经满了，也会被阻塞，而一旦消费者获取数据之后就相当于队列空了一个位置，这时消费者就会通知所有正在阻塞的生产者进行生产。\n\n5.2 如何用 BlockingQueue 实现生产者消费者模式我们接下来看如何用 wait/notify/Condition/BlockingQueue 实现生产者消费者模式，先从最简单的 BlockingQueue 开始讲起：\npublic static void main(String[] args) {\n\n  BlockingQueue&lt;Object> queue = new ArrayBlockingQueue&lt;>(10);\n\n Runnable producer = () -> {\n    while (true) {\n          queue.put(new Object());\n  }\n   };\n\nnew Thread(producer).start();\nnew Thread(producer).start();\n\nRunnable consumer = () -> {\n      while (true) {\n           queue.take();\n}\n   };\nnew Thread(consumer).start();\nnew Thread(consumer).start();\n}\n如代码所示，首先，创建了一个 ArrayBlockingQueue 类型的 BlockingQueue，命名为 queue 并将它的容量设置为 10；其次，创建一个简单的生产者，while(true) 循环体中的queue.put() 负责往队列添加数据；然后，创建两个生产者线程并启动；同样消费者也非常简单，while(true) 循环体中的 queue.take() 负责消费数据，同时创建两个消费者线程并启动。为了代码简洁并突出设计思想，代码里省略了 try/catch 检测，我们不纠结一些语法细节。以上便是利用 BlockingQueue 实现生产者消费者模式的代码。虽然代码非常简单，但实际上 ArrayBlockingQueue 已经在背后完成了很多工作，比如队列满了就去阻塞生产者线程，队列有空就去唤醒生产者线程等。\n5.3 如何用 Condition 实现生产者消费者模式BlockingQueue 实现生产者消费者模式看似简单，背后却暗藏玄机，我们在掌握这种方法的基础上仍需要掌握更复杂的实现方法。我们接下来看如何在掌握了 BlockingQueue 的基础上利用 Condition 实现生产者消费者模式，它们背后的实现原理非常相似，相当于我们自己实现一个简易版的 BlockingQueue：\npublic class MyBlockingQueueForCondition {\n\n   private Queue queue;\n   private int max = 16;\n   private ReentrantLock lock = new ReentrantLock();\n   private Condition notEmpty = lock.newCondition();\n   private Condition notFull = lock.newCondition();\n\n\n   public MyBlockingQueueForCondition(int size) {\n       this.max = size;\n       queue = new LinkedList();\n   }\n\n   public void put(Object o) throws InterruptedException {\n       lock.lock();\n       try {\n           while (queue.size() == max) {\n               notFull.await();\n           }\n           queue.add(o);\n           notEmpty.signalAll();\n       } finally {\n           lock.unlock();\n       }\n   }\n\n   public Object take() throws InterruptedException {\n       lock.lock();\n       try {\n           while (queue.size() == 0) {\n               notEmpty.await();\n           }\n           Object item = queue.remove();\n           notFull.signalAll();\n           return item;\n       } finally {\n           lock.unlock();\n       }\n   }\n}\n如代码所示，首先，定义了一个队列变量 queue 并设置最大容量为 16；其次，定义了一个 ReentrantLock 类型的 Lock 锁，并在 Lock 锁的基础上创建两个 Condition，一个是 notEmpty，另一个是 notFull，分别代表队列没有空和没有满的条件；最后，声明了 put 和 take 这两个核心方法。\n因为生产者消费者模式通常是面对多线程的场景，需要一定的同步措施保障线程安全，所以在 put 方法中先将 Lock 锁上，然后，在 while 的条件里检测 queue 是不是已经满了，如果已经满了，则调用 notFull 的 await() 阻塞生产者线程并释放 Lock，如果没有满，则往队列放入数据并利用 notEmpty.signalAll() 通知正在等待的所有消费者并唤醒它们。最后在 finally 中利用 lock.unlock() 方法解锁，把 unlock 方法放在 finally 中是一个基本原则，否则可能会产生无法释放锁的情况。\n下面再来看 take 方法，take 方法实际上是与 put 方法相互对应的，同样是通过 while 检查队列是否为空，如果为空，消费者开始等待，如果不为空则从队列中获取数据并通知生产者队列有空余位置，最后在 finally 中解锁。\n这里需要注意，我们在 take() 方法中使用 while( queue.size() == 0 ) 检查队列状态，而不能用 if( queue.size() == 0 )。为什么呢？大家思考这样一种情况，因为生产者消费者往往是多线程的，我们假设有两个消费者，第一个消费者线程获取数据时，发现队列为空，便进入等待状态；因为第一个线程在等待时会释放 Lock 锁，所以第二个消费者可以进入并执行 if( queue.size() == 0 )，也发现队列为空，于是第二个线程也进入等待；而此时，如果生产者生产了一个数据，便会唤醒两个消费者线程，而两个线程中只有一个线程可以拿到锁，并执行 queue.remove 操作，另外一个线程因为没有拿到锁而卡在被唤醒的地方，而第一个线程执行完操作后会在 finally 中通过 unlock 解锁，而此时第二个线程便可以拿到被第一个线程释放的锁，继续执行操作，也会去调用 queue.remove 操作，然而这个时候队列已经为空了，所以会抛出 NoSuchElementException 异常，这不符合我们的逻辑。而如果用 while 做检查，当第一个消费者被唤醒得到锁并移除数据之后，第二个线程在执行 remove 前仍会进行 while 检查，发现此时依然满足 queue.size() == 0 的条件，就会继续执行 await 方法，避免了获取的数据为 null 或抛出异常的情况。\n5.4 如何用 wait/notify 实现生产者消费者模式最后我们再来看看使用 wait/notify 实现生产者消费者模式的方法，实际上实现原理和Condition 是非常类似的，它们是兄弟关系：\nclass MyBlockingQueue {\n\n   private int maxSize;\n   private LinkedList&lt;Object> storage;\n\n   public MyBlockingQueue(int size) {\n       this.maxSize = size;\n       storage = new LinkedList&lt;>();\n   }\n\n   public synchronized void put() throws InterruptedException {\n       while (storage.size() == maxSize) {\n           wait();\n       }\n       storage.add(new Object());\n       notifyAll();\n   }\n\n   public synchronized void take() throws InterruptedException {\n       while (storage.size() == 0) {\n           wait();\n       }\n       System.out.println(storage.remove());\n       notifyAll();\n   }\n}\n如代码所示，最主要的部分仍是 take 与 put 方法，我们先来看 put 方法，put 方法被 synchronized 保护，while 检查队列是否为满，如果不满就往里放入数据并通过 notifyAll() 唤醒其他线程。同样，take 方法也被 synchronized 修饰，while 检查队列是否为空，如果不为空就获取数据并唤醒其他线程。使用这个 MyBlockingQueue 实现的生产者消费者代码如下：\n/**\n* 描述：     wait形式实现生产者消费者模式\n*/\npublic class WaitStyle {\n\n   public static void main(String[] args) {\n       MyBlockingQueue myBlockingQueue = new MyBlockingQueue(10);\n       Producer producer = new Producer(myBlockingQueue);\n       Consumer consumer = new Consumer(myBlockingQueue);\n       new Thread(producer).start();\n       new Thread(consumer).start();\n   }\n}\n\nclass Producer implements Runnable {\n\n   private MyBlockingQueue storage;\n\n   public Producer(MyBlockingQueue storage) {\n       this.storage = storage;\n   }\n\n   @Override\n   public void run() {\n       for (int i = 0; i &lt; 100; i++) {\n           try {\n               storage.put();\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n}\n\nclass Consumer implements Runnable {\n\n   private MyBlockingQueue storage;\n\n   public Consumer(MyBlockingQueue storage) {\n       this.storage = storage;\n   }\n\n   @Override\n   public void run() {\n       for (int i = 0; i &lt; 100; i++) {\n           try {\n               storage.take();\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   }\n}\n以上就是三种实现生产者消费者模式的示例，其中，第一种 BlockingQueue 模式实现比较简单，但其背后的实现原理在第二种、第三种实现方法中得以体现，第二种、第三种实现方法本质上是我们自己实现了 BlockingQueue 的一些核心逻辑，供生产者与消费者使用。\n","categories":["JAVA"],"tags":["JVM","JAVA"]},{"title":"【笔记四】编译插桩操纵字节码，实现不可能完成的任务","url":"https://blog.onestravel.cn/20210728/9c2efe6aefcb/","content":"【笔记四】编译插桩操纵字节码，实现不可能完成的任务根据之前学习的class 字节码文件的解析，接下来在此基础上进行一些更深入的操作，来加深对 class 字节码文件的理解。\n相信做过 Android 开发的工程师大多都遇到过这种需求：\n\n记录每一个页面的打开和关闭事件，并通过各种 DataTracking 的框架上传到服务器，用来日后做数据分析。\n\n面对这样的需求，一般人都会想到，这其实就是在每一个 Activity 的 onCreate 和 onDestroy 方法中，分别添加页面打开和页面关闭的逻辑。常见的做法有以下三种：\n\n修改项目中现有的每一个 Activity，这样显然不够高大上，并且如果项目以后需要添加新的页面，这套逻辑需要重新拷贝一遍，非常容易遗漏。\n将项目中所有的 Activity 继承自 BaseActivity，将页面打开和关闭的逻辑添加在 BaseActivity中，这种方案看起来比第 1 种方案高级得多，并且后续项目中有新的 Activity，直接继承 BaseActivity 即可。但是这种方案对第三方依赖库中的界面则无能为力，因为我们没有第三方依赖库的源码。\n在 Application 中调用registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks callback) 方法来注册一个 Activity 生命周期的监听回调，所有的 Activity 都会走该回调，我们可以在该回调中通过生命周期的方法来记录页面打开和关闭事件。\n\n除了这三种方案，还有一种更加优雅更加完整的方案应运而生：编译插桩。\n1. 编译插桩是什么顾名思义，所谓编译插桩就是在代码编译期间修改已有的代码或者生成新代码。实际上，我们项目中经常用到的 Dagger、ButterKnife 甚至是 Kotlin 语言，它们都用到了编译插桩的技术。\n理解编译插桩之前，需要先回顾一下 Android 项目中 .java 文件的编译过程：\n\n\n从上图可以看出，我们可以在 1、2 两处对代码进行改造。\n\n在 .java 文件编译成 .class 文件时，APT、AndroidAnnotation 等就是在此处触发代码生成。\n在 .class 文件进一步优化成 .dex 文件时，也就是直接操作字节码文件。这种方式功能更加强大，应用场景也更多。但是门槛比较高，需要对字节码有一定的理解。\n\n主要介绍第 2 种实现方式，用一张图来描述如下过程\n\n\n一般情况下，我们经常会使用编译插桩实现如下几种功能：\n\n日志埋点；\n性能监控；\n动态权限控制；\n业务逻辑跳转时，校验是否已经登录；\n甚至是代码调试等。\n\n2. 插桩工具介绍目前市面上主要流行两种实现编译插桩的方式：\nAspectJ\nAspectJ 是老牌 AOP（Aspect-Oriented Programming）框架，如果你做过 J2EE 开发可能对这个框架更加熟悉，经常会拿这个框架跟 Spring AOP 进行比较。其主要优势是成熟稳定，使用者也不需要对字节码文件有深入的理解。\nASM\n目前另一种编译插桩的方式 ASM 越来越受到广大工程师的喜爱。通过 ASM 可以修改现有的字节码文件，也可以动态生成字节码文件，并且它是一款完全以字节码层面来操纵字节码并分析字节码的框架（此处可以联想一下写汇编代码时的酸爽）。\n举个例子，在 Java 中如果实现两个数相加操作，可以如下实现：\npublic int add(){\n  int a = 10;\n  int b = 20;\n  return a + b;\n}\n但是如果使用 ASM 直接编写字节码指令，则有可能是如下几个字节码指令：\u0010\n\n虽然上面的代码看起来很恐怖，但是没必要太过担心，因为有各种工具帮我们生成这些字节码指令。\n接下来就使用 ASM 来实现简单的编译插桩效果，通过插桩实现在每一个 Activity 打开时输出相应的 log 日志。\n3. 插桩实现3.1 实现思路过程主要包含两步：\n\n遍历项目中所有的 .class 文件 如何找到项目中编译生成的所有 .class 文件，是我们需要解决的第一个问题。众所周知，Android Studio 使用 Gradle 编译项目中的 .java 文件，并且从 Gradle1.5.0 之后，我们可以自己定义 Transform，来获取所有 .class 文件引用。但是 Transform 的使用需要依赖 Gradle Plugin。因此我们第一步需要创建一个单独的 Gradle Plugin，并在 Gradle Plugin 中使用自定义 Transform 找出所有的 .class 文件。\n\n遍历到目标 .class 文件 （Activity）之后，通过 ASM 动态注入需要被插入的字节码如果第一步进行顺利，我们可以找出所有的 .class 文件。接下来就需要过滤出目标 Activity 文件，并在目标 Activity 文件的 onCreate 方法中，通过 ASM 插入相应的 log 日志字节码。\n\n\n3.2 具体实现\n创建 ASMLifeCycleDemo 项目创建主项目 ASMLifeCycleDemo，当前项目中只有一个 MainActivity\n\n\n创建自定义 Gradle 插件 首先在 ASMLifeCycleDemo 项目中创建一个新的 module，并选择 Android Library 类型，命名为 asm_lifecycle_plugin。 将 asm_lifecycle_plugin module 中除了 build.gradle 和 main 文件夹之外的所有内容都删除。然后在 main 目录下分别创建 groovy 和 java 目录\u0010\n因为 Gradle 插件是使用 groovy 语言编写的，所以需要新建一个 groovy 目录，用来存放插件相关的.groovy类。 但 ASM 是 java 层面的框架，所以在 java 目录里存放 ASM 相关的类。\n\n\n  然后，在 groovy 中创建目录 cn.onestravel.plugin，并在此目录中创建类 LifeCyclePlugin.groovy 文件。在 LifeCyclePlugin 中重写 apply 方法，实现插件逻辑，因为是 demo 演示，所以我只是简单的打印 log 日志。\npackage cn.onestravel.plugin\n\nimport org.gradle.api.Plugin\nimport org.gradle.api.Project\n\npublic class LifeCyclePlugin implements Plugin&lt;Project> {\n\n    @Override\n    void apply(Project project) {\n        System.out.println(\"==LifeCyclePlugin ====\")\n\n    }\n}\n可以看出 LifeCyclePlugin 实现了 gradle api 中的 Plugin 接口。当我们在 app module 的 build.gradle 文件中使用此插件时，其 LifeCyclePlugin 的 apply 方法将会被自动调用。\n接下来，将 asm_lifecycle_plugin module 的 build.gradle 中的内容全部删掉，改为如下内容：\napply plugin: 'groovy'\napply plugin: 'maven'\n\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation gradleApi()\n    implementation localGroovy()\n\n    implementation 'com.android.tools.build:gradle:3.4.2'\n\n}\n\ngroup='cn.onestravel.plugin'\nversion='1.0.0'\n\nuploadArchives{\n    repositories {\n        mavenDeployer{\n           repository(url:uri('../ams_lifecycle_repo'))\n        }\n    }\n}\ngroup 和 version 都需要在 app module 引用此插件时使用。\n所有的插件都需要被部署到 maven 库中，我们可以选择部署到远程或者本地。这里只是演示，所以只是将插件部署到本地目录中。具体地址通过 repository 属性配置，如图所示我将其配置在项目根目录下的 asm_lifecycle_repo 目录下。\n最后一步，创建 properties 文件。\n在 plugin/src/main 目录下新建目录 resources/META-INF/gradle-plugins，然后在此目录下新建一个文件：ones.asm.lifecycle.properties，其中文件名 ones.asm.lifecycle 就是我们自定义插件的名称，稍后我们在 app module 中会使用到此名称。\n在 .properties 文件中，需要指定我们自定义的插件类名 LifeCyclePlugin，如下所示：\nimplementation-class=cn.onestravel.plugin.LifeCyclePlugin\n至此，自定义 Gradle 插件就已经写完，现在可以在 Android Studio 的右边栏找到 Gradle 中点击 uploadArchives，执行 plugin 的部署任务：\n可以看到，构建成功之后，在 Project 的根目录下将会出现一个 repo 目录，里面存放的就是我们的插件目标文件。\n\n\n测试 asm_lifecycle_plugin\n为了测试自定义的 Gradle 插件是否可用，可以在 app module 中的 build.gradle 中引用此插件。\napply plugin: 'ones.asm.lifecycle'// 1. 自定义 Gradle 插件中 properties 的文件名\nbuildscript{\n    repositories {\n        google()\n        jcenter()\n        maven {url '../ams_lifecycle_repo'}\n    }\n    dependencies {\n        classpath 'cn.onestravel.plugin:asm_lifecycle_plugin:1.0.0' //2. group 值 + module 名 + version\n    }\n}\nandroid {\n  ...\n}\ndependencies{\n  ...\n}\n\n\n然后在命令行中使用 gradlew 执行构建命令./gradlew clean assembleDebug，如果打印出我们自定义插件里的 log，则说明自定义 Gradle 插件可以使用：\n➜  asmlifecycledemo ./gradlew clean  assembleDebug\nStarting a Gradle Daemon (subsequent builds will be faster)\n\n> Configure project :asmlifecycledemo\n==LifeCyclePlugin ====\n------------------register  LifeCycleTransform\n\n\nBUILD SUCCESSFUL in 31s\n26 actionable tasks: 26 executed\n\n\n自定义 Transform，实现遍历 .class 文件\n自定义 Gradle 插件已经写好，接下来就需要实现遍历所有 .class 的逻辑。这部分功能主要依赖 Transform API。\n\n\n什么是 Transform ？\n   Transform 可以被看作是 Gradle 在编译项目时的一个 task，在 .class 文件转换成 .dex 的流程中会执行这些 task，对所有的 .class 文件（可包括第三方库的 .class）进行转换，转换的逻辑定义在 Transform 的 transform 方法中。实际上平时我们在 build.gradle 中常用的功能都是通过 Transform 实现的，比如混淆（proguard）、分包（multi-dex）、jar 包合并（jarMerge）。\n自定义 Transform\n在 cn.onestravel.plugin 目录中，新建 LifeCycleTransform.groovy，并继承 Transform 类。LifeCycleTransform 需要实现抽象类 Transform 中的抽象方法，具体有如下几个方法需要实现：\npackage cn.onestravel.plugin\n\nimport com.android.build.api.transform.*\nimport com.android.build.gradle.internal.pipeline.TransformManager\n\npublic class LifeCycleTransform extends Transform {\n\n    @Override\n    String getName() {\n        return \"LifeCycleTransform\"\n    }\n\n    @Override\n    Set&lt;QualifiedContent.ContentType> getInputTypes() {\n        return TransformManager.CONTENT_CLASS\n    }\n\n    @Override\n    Set&lt;? super QualifiedContent.Scope> getScopes() {\n        return TransformManager.PROJECT_ONLY\n    }\n\n    @Override\n    boolean isIncremental() {\n        return false\n    }\n\n    @Override\n    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {\n        super.transform(transformInvocation)\n    }\n}\ngetName：\n设置我们自定义的 Transform 对应的 Task 名称。Gradle 在编译的时候，会将这个名称显示在控制台上。比如：Task :app:transformClassesWithXXXForDebug。\ngetInputType：\n在项目中会有各种各样格式的文件，通过 getInputType 可以设置 LifeCycleTransform 接收的文件类型，此方法返回的类型是 Set&lt;QualifiedContent.ContentType&gt; 集合。\nContentType 有以下 2 种取值。\n /**\n     * A content type that is requested through the transform API.\n     */\n    interface ContentType {\n\n        /**\n         * Content type name, readable by humans.\n         * @return the string content type name\n         */\n        String name();\n\n        /**\n         * A unique value for a content type.\n         */\n        int getValue();\n    }\n\n    /**\n     * The type of of the content.\n     */\n    enum DefaultContentType implements ContentType {\n        /**\n         * The content is compiled Java code. This can be in a Jar file or in a folder. If\n         * in a folder, it is expected to in sub-folders matching package names.\n         */\n        CLASSES(0x01),\n\n        /** The content is standard Java resources. */\n        RESOURCES(0x02);\n\n        private final int value;\n\n        DefaultContentType(int value) {\n            this.value = value;\n        }\n\n        @Override\n        public int getValue() {\n            return value;\n        }\n    }\n\nCLASSES：代表只检索 .class 文件；\nRESOURCES：代表检索 java 标准资源文件。\n\ngetScopes()\n这个方法规定自定义 Transform 检索的范围，具体有以下几种取值：\nenum Scope implements ScopeType {\n        /** Only the project (module) content */\n        PROJECT(0x01),\n        /** Only the sub-projects (other modules) */\n        SUB_PROJECTS(0x04),\n        /** Only the external libraries */\n        EXTERNAL_LIBRARIES(0x10),\n        /** Code that is being tested by the current variant, including dependencies */\n        TESTED_CODE(0x20),\n        /** Local or remote dependencies that are provided-only */\n        PROVIDED_ONLY(0x40),\n\n        /**\n         * Only the project's local dependencies (local jars)\n         *\n         * @deprecated local dependencies are now processed as {@link #EXTERNAL_LIBRARIES}\n         */\n        @Deprecated\n        PROJECT_LOCAL_DEPS(0x02),\n        /**\n         * Only the sub-projects's local dependencies (local jars).\n         *\n         * @deprecated local dependencies are now processed as {@link #EXTERNAL_LIBRARIES}\n         */\n        @Deprecated\n        SUB_PROJECTS_LOCAL_DEPS(0x08);\n\n        private final int value;\n\n        Scope(int value) {\n            this.value = value;\n        }\n\n        @Override\n        public int getValue() {\n            return value;\n        }\n    }\n*isIncremental() *\n表示当前 Transform 是否支持增量编译，我们不需要增量编译，所以直接返回 false 即可。\ntransform()\n在 自定义Transform 中最重要的方法就是 transform()。在这个方法中，可以获取到两个数据的流向。\n\ninputs：inputs 中是传过来的输入流，其中有两种格式，一种是 jar 包格式，一种是 directory（目录格式）。\noutputProvider：outputProvider 获取到输出目录，最后将修改的文件复制到输出目录，这一步必须做，否则编译会报错。\n\n我们可以实现一个简易 LifeCycleTransform，功能是打印出所有 .class 文件。代码如下：\npackage cn.onestravel.plugin\n\nimport com.android.build.api.transform.*\nimport com.android.build.gradle.internal.pipeline.TransformManager\n\npublic class LifeCycleTransform extends Transform {\n\n    @Override\n    String getName() {\n      //1. 自定义的 Transform 名称为 LifeCycleTransform；\n        return \"LifeCycleTransform\"\n    }\n\n    @Override\n    Set&lt;QualifiedContent.ContentType> getInputTypes() {\n      //2. 检索项目中 .class 类型的目录或者文件；\n        return TransformManager.CONTENT_CLASS\n    }\n\n    @Override\n    Set&lt;? super QualifiedContent.Scope> getScopes() {\n      //3. 设置当前 Transform 检索范围为当前项目；\n        return TransformManager.PROJECT_ONLY\n    }\n\n    @Override\n    boolean isIncremental() {\n        return false\n    }\n\n    @Override\n    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {\n        super.transform(transformInvocation)\n        Collection&lt;TransformInput> inputs = transformInvocation.inputs\n        inputs.each { TransformInput transformInput ->\n            transformInput.directoryInputs.each { DirectoryInput directoryInput ->\n                File dir = directoryInput.file\n                if (dir) {\n                  //4. 设置过滤文件为 .class 文件（去除文件夹类型），并打印文件名称。\n                    Map&lt;String, Object> options = new HashMap&lt;>()\n                    options.put(\"type\", groovy.io.FileType.FILES)\n                    options.put(\"nameFilter\", ~/.*\\.class/)\n                    dir.traverse(options) { file ->\n                        System.out.println(file.name)\n                    }\n                }\n            }\n        }\n    }\n}\n解释说明：\n\n自定义的 Transform 名称为 LifeCycleTransform；\n检索项目中 .class 类型的目录或者文件；\n设置当前 Transform 检索范围为当前项目；\n设置过滤文件为 .class 文件（去除文件夹类型），并打印文件名称。\n\n5. 将自定义的 LifeCycleTransform 注册到 Gradle 插件中\n在 LifeCyclePlugin 中添加如下代码：\npackage cn.onestravel.plugin\n\nimport com.android.build.gradle.AppExtension;\nimport org.gradle.api.Plugin\nimport org.gradle.api.Project\n\npublic class LifeCyclePlugin implements Plugin&lt;Project> {\n\n    @Override\n    void apply(Project project) {\n        System.out.println(\"==LifeCyclePlugin ====\")\n\n\n        def android = project.extensions.getByType(AppExtension)\n        println('------------------register  LifeCycleTransform')\n        LifeCycleTransform transform = new LifeCycleTransform()\n        android.registerTransform(transform)\n\n    }\n}\n再次在命令行中执行 build 命令，可以看到 LifeCycleTransform 检索出的所有 .class 文件。\n➜  asmlifecycledemo ./gradlew clean assembleDebug\nStarting a Gradle Daemon (subsequent builds will be faster)\n\n> Configure project :asmlifecycledemo\n==LifeCyclePlugin ====\n------------------register  LifeCycleTransform\n\n> Task :asmlifecycledemo:transformClassesWithLifeCycleTransformForDebug\nBuildConfig.class\nMainActivity.class\n\nBUILD SUCCESSFUL in 31s\n26 actionable tasks: 26 executed\n\n可以看出，Gradle 编译时多了一个我们自定义的 LifeCycleTransform 类型的任务，并且将所有 .class 文件名打印出来，其中包含了我们需要的目标文件 MainActivity.class。\n3.3 使用 ASM，插入字节码到 Activity 文件ASM 是一套开源框架，其中几个常用的 API 如下：\n\nClassReader：负责解析 .class 文件中的字节码，并将所有字节码传递给 ClassWriter。\nClassVisitor：负责访问 .class 文件中各个元素，还记得上一课时我们介绍的 .class 文件结构吗？ClassVisitor 就是用来解析这些文件结构的，当解析到某些特定结构时（比如类变量、方法），它会自动调用内部相应的 FieldVisitor 或者 MethodVisitor 的方法，进一步解析或者修改 .class 文件内容。\nClassWriter：继承自 ClassVisitor，它是生成字节码的工具类，负责将修改后的字节码输出为 byte 数组。\n\n3.3.1 添加 ASM 依赖在 asm_lifecycle_plugin 的 build.gradle 中，添加对 ASM 的依赖，如下：\napply plugin: 'groovy'\napply plugin: 'maven'\n\n\ndependencies {\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\n    implementation gradleApi()\n    implementation localGroovy()\n\n    implementation 'com.android.tools.build:gradle:3.4.2'\n\n    //ASM 相关依赖\n    implementation 'org.ow2.asm:asm:7.1'\n    implementation 'org.ow2.asm:asm-commons:7.1'\n\n}\n\ngroup='cn.onestravel.plugin'\nversion='1.0.0'\n\nuploadArchives{\n    repositories {\n        mavenDeployer{\n           repository(url:uri('../ams_lifecycle_repo'))\n        }\n    }\n}\n","categories":["Android"],"tags":["Android","JVM"]},{"title":"【笔记三】字节码层面分析 class 文件结构","url":"https://blog.onestravel.cn/20210528/618470f841d8/","content":"【笔记三】字节码层面分析 class 文件结构1. class 的来龙去脉Java 能够实现“一次编译，到处运行”\u0010，这其中 class 文件要占大部分功劳\u0010\u0010\u0010\u0010；为了让 Java 具有良好的跨平台能力，Java 独具匠心的提供了一种可以在所有平台上都能使用的一种中间代码—字节码类文件（.class 类文件）。有了字节码，无论哪种平台（如：Mac，Linux，windows等），只要是安装了虚拟机，都可以直接运行字节码文件。\n并且，有了字节码，也解除了 Java 虚拟机和 Java 语言之间的耦合。其实，Java 虚拟机当时被设计出来的目的就不单单是值运行 Java 这一种语言。目前，Java 虚拟机已经可以支持很多除 Java 语言外的其他语言；如：Groovy、JRuby、Jython、Scala 等。之所以能勾支持其他语言，是因为这些语言经过编译之后也可以生成能够被 Java 虚拟机解释并执行的字节码文件。而虚拟机并不关心字节码文件是由哪种语言编译而来的。\n\n\n2. 上帝视角看 class 文件如果从纵观角度来看 class 文件，class 文件里只有两种数据结构：无符号数和表。\n\n无符号数：数据基本的数据类型，由 u1、u2、u4、u8 分别来代表一个字节、两个字节、四个字节 和 八个字节的无符号数，无符号数可以用来描述数字，索引引用，数值量或者字符串（UTF 编码）。\n表：表是由多个无符号数或者其他表作为数据项构成的复合数据类型，class 文件种所有的表都以“_iinfo”结尾。其实，整个 Class 文件本质上就是一张表。\n\n\n\n可以看出，在一张表中可以包含其他无符号数和其他表格。伪代码可以如下所示：\n//无符号数\nu1 = byte[1];\nu2 = byte[2];\nu4 = byte[4];\nu8 = byte[8];\n\n//表\nclass_table{\n  //表中可以引用各种无符号数\n  u1 tag;\n  u2 index2;\n  ...\n  //表中也可以引用其他表\n  method_table mt;\n  ...\n}\n3. class 文件结构刚才说 class 文件中只存在无符号数和表这两种数据结构。而这些无符号数和表就组成了 class 中的各个结构。这些结构按照预先约定好的顺序紧密的从前向后排列，相邻项之间没有任何间隙。如下图所示：\n\n当 JVM 加载某个class 文件时，JVM 就是根据上图中的结构去解析 class 文件，加载 class 文件到内存中，并在内存中分配相应的空间。具体一种结构需要占用多大控件可以参考下表：\n\n\n\n字段\n名称\n数据类型\n数量\n\n\n\nmagic number\n魔数\nu4\n1\n\n\nmajor version\n主版本号\nu2\n1\n\n\nminor version\n副版本号\nu2\n1\n\n\nconstant_pool_count\n常量池大小\nu2\n1\n\n\nconstant_pool\n常量池\ncp_info\nconstant_pool_count - 1\n\n\naccess_flag\n访问标志\nu2\n1\n\n\nthis_class\n当前类索引\nu2\n1\n\n\nsuper_class\n父类索引\nu2\n1\n\n\ninterfaces_count\n接口索引集合大小\nu2\n1\n\n\ninterfaces\n接口索引集合\nu2\ninterfaces_count - 1\n\n\nfields_count\n字段索引集合大小\nu2\n1\n\n\nfields\n字段索引集合\nfield_info\nfields_count - 1\n\n\nmethods_count\n方法索引集合大小\nu2\n1\n\n\nmethods\n方法索引集合\nmethod_info\nmethods_count - 1\n\n\nattributes_count\n属性索引集合大小\nu2\n1\n\n\nattributes\n属性索引集合\nattribute_info\nattributes_count - 1\n\n\n\n看到这里你可能会有点概念混淆，分不清无符号数、表格以及上面的结构是什么关系。其实可以举一个简单的例子：人类的身体是由 H、O、C、N 等元素组成的。但是这些元素又是按照一定的规律组成了人类身体的各个器官。class 文件中的无符号数和表格就相当于人类身体中的 H、O、C、N 等元素，而 class 结构图中的各项结构就相当于人类身体的各个器官。\n\n4. 实例分析接下来通过一个 Java 代码来看一下上面几个结构的详细情况。\nimport java.io.Serializable;\n\npublic class Test implements Serializable, Cloneable{\n      private int num = 1;\n\n      public int add(int i) {\n          int j = 10;\n          num = num + i;\n          return num;\n     }\n}\n将 Test.java 通过 javac 进行编译，生成Test.class 字节码文件，然后使用16进制编辑器打开 class 文件，显示内容如下：\n\n上面都是一些 16 进制数字，每两个字符代表一个字节。乍看一下各个字符之间毫无规律，但是在 JVM 的视角里这些 16 进制字符是按照严格的规律排列的。接下来就一步一步看下 JVM 是如何解析它们的。\n4.1 魔数 magic number\n如上图所示，在 class 文件开头的四个字节是 class 文件的魔数，它是一个固定的值–0XCAFEBABE。魔数是 class 文件的标志，也就是说它是判断一个文件是不是 class 格式文件的标准， 如果开头四个字节不是 0XCAFEBABE， 那么就说明它不是 class 文件， 不能被 JVM 识别或加载。\n4.2 版本号\n紧跟在魔数后面的四个字节代表当前 class 文件的版本号。前两个字节 0000 代表次版本号（minor_version），后两个字节 0034 是主版本号（major_version），对应的十进制值为 52，也就是说当前 class 文件的主版本号为 52，次版本号为 0。所以综合版本号是 52.0，也就是  jdk1.8.0\n4.3 常量池紧跟在版本号之后的是一个叫作常量池的表（cp_info）。在常量池中保存了类的各种相关信息，比如类的名称、父类的名称、类中的方法名、参数名称、参数类型等，这些信息都是以各种表的形式保存在常量池中的。\n常量池中的每一项都是一个表，其项目类型共有 14 种，如下表所示：\n\n\n\n表名\n标识位\n描述\n\n\n\nCONSTANT_utf8_info\n1\nUTF-8编码字符串表\n\n\nCONSTANT_Integer_info\n3\n整型常量表\n\n\nCONSTANT_Float_info\n4\n浮点型常量表\n\n\nCONSTANT_Long_info\n5\n长整型常量表\n\n\nCONSTANT_Double_info\n6\n双精度浮点型常量表\n\n\nCONSTANT_Class_info\n7\n接口/类 引用表\n\n\nCONSTANT_String_info\n8\n字符串常量表\n\n\nCONSTANT_Fieldref_info\n9\n字段引用表\n\n\nCONSTANT_Methodref_info\n10\n类的方法引用表\n\n\nCONSTANT_InterfaceMethod_info\n11\n接口方的法引用表\n\n\nCONSTANT_NameAndType\n12\n字段或者方法的名称和类型表\n\n\nCONSTANT_MethodHandle_info\n15\n方法句柄表\n\n\nCONSTANT_MethodType_info\n16\n方法类型表\n\n\nCONSTANT_InvokeDynamic_info\n18\n动态方法调用表\n\n\n可以看出，常量池中的每一项都会有一个 u1大小的 tag 。tag 值是表的标识，JVM 解析 class 文件时，通过这个数据来判断当前数据结构是哪一种表。以上14 中表都有自己的结构，这里以 CONSTANT_Class_info和CONSTANT_Utf8_info这两张表举例说明：\n首先，CONSTANT_Class_info表具体结构如下所示：\ntable CONSTANT_Class_info {\n    u1  tag = 7;\n    u2  name_index;\n}\n解释说明：\n\ntag：占用一个字节大小。比如值为 7，说明是 CONSTANT_Class_info 类型表。\nname_index：是一个索引值，可以将它理解为一个指针，指向常量池中索引为 name_index 的常量表。比如 name_index = 2，则它指向常量池中第 2 个常量。\n\n接下来再看 CONSTANT_Utf8_info 表具体结构如下：\ntable CONSTANT_utf8_info &#123;\n    u1  tag;\n    u2  length;\n    u1[] bytes;\n&#125;解释说明：\n\ntag：值为1，表示是 CONSTANT_Utf8_info 类型表。\nlength：length 表示 u1[] 的长度，比如 length=5，则表示接下来的数据是 5 个连续的 u1 类型数据。\nbytes：u1 类型数组，长度为上面第 2 个参数 length 的值。\n\n而我们在java代码中声明的String字符串最终在class文件中的存储格式就 CONSTANT_utf8_info。因此一个字符串最大长度也就是u2所能代表的最大值65536个，但是需要使用2个字节来保存 null 值，因此一个字符串的最大长度为 65536 - 2 = 65534。\n不难看出，在常量池内部的表中也有相互之间的引用。用一张图来理解 CONSTANT_Class_info 和 CONSTANT_utf8_info 表格之间的关系，如下图所示：\n\n理解了常量池内部的数据结构之后，接下来就看一下实例代码的解析过程。因为开发者平时定义的 Java 类各式各样，类中的方法与参数也不尽相同。所以常量池的元素数量也就无法固定，因此 class 文件在常量池的前面使用 2 个字节的容量计数器，用来代表当前类中常量池的大小。如下图所示：\n\n红色框中的 001d 转化为十进制就是 29，也就是说常量计数器的值为 29。其中下标为 0 的常量被 JVM 留作其他特殊用途，因此 Test.class 中实际的常量池大小为这个计数器的值减 1，也就是 28个。\n第一个常量，如下所示：\n\n0a 转化为 10 进制后为 10，通过查看常量池 14 种表格图中，可以查到 tag=10 的表类型为 CONSTANT_Methodref_info，因此常量池中的第一个常量类型为方法引用表。其结构如下：\nCONSTANT_Methodref_info &#123;\n    u1 tag = 10;\n    u2 class_index;        指向此方法的所属类\n    u2 name_type_index;    指向此方法的名称和类型\n\n&#125;也就是说在“0a”之后的 2 个字节指向这个方法是属于哪个类，紧接的 2 个字节指向这个方法的名称和类型。它们的值分别是：\n\n0006：十进制 6，表示指向常量池中的第 6 个常量。\n0015：十进制 21，表示指向常量池中的第 21 个常量。\n\n至此，第 1 个常量就解读完毕了。紧接着的就是第 2 个常量，如下所示：\n\ntag 09 表示是字段引用表 CONSTANT_FIeldref_info ，其结构如下：\nCONSTANT_Fieldref_info&#123;\n    u1 tag;\n    u2 class_index;        指向此字段的所属类\n    u2 name_type_index;    指向此字段的名称和类型\n\n&#125;同样也是 4 个字节，前后都是两个索引。\n\n0005：指向常量池中第 5 个常量。\n0016：指向常量池中第 22 个常量。\n\n到现在为止我们已经解析出了常量池中的两个常量。剩下的 21 个常量的解析过程也大同小异，这里就不一一解析了。\n实际上我们可以借助 javap 命令来帮助我们查看 class 常量池中的内容：\njavap -v Test.class\n上述命令执行后，显示结果如下：\n\n正如我们刚才分析的一样，常量池中第一个常量是 Methodref 类型，指向下标 6 和下标 21 的常量。其中下标 21 的常量类型为 NameAndType，它对应的数据结构如下：\nCONSTANT_NameAndType_info&#123;\n    u1 tag;\n    u2 name_index;    指向某字段或方法的名称字符串\n    u2 type_index;    指向某字段或方法的类型字符串\n\n&#125;而下标在 21 的 NameAndType 的 name_index 和 type_index 分别指向了 13 和 14，也就是“”和“()V”。因此最终解析下来常量池中第 1 个常量的解析过程以及最终值如下图所示：\n\n仔细解析层层引用，最后我们可以看出，Test.class 文件中常量池的第 1 个常量保存的是 Object 中的默认构造器方法。\n4.4 访问标志（access_flags）紧跟在常量池之后的常量是访问标志，占用两个字节，如下图所示：\n\n访问标志代表类或者接口的访问信息，比如：该 class 文件是类还是接口，是否被定义成 public，是否是 abstract，如果是类，是否被声明成 final 等等。各种访问标志如下所示：\n\n\n\n访问标志\n值\n描述\n\n\n\nACC_PUBLIC\n0x0001\npublic 类型\n\n\nACC_FINAL\n0x0010\n被声明为 final 类型的类\n\n\nACC_SUPER\n0x0020\n是否允许使用invokespecial字节码指令的新语义，JDK 1.0.2之后编译出来的类这个标志默认为真\n\n\nACC_INTERFACE\n0x0200\n标识这是一个接口类型\n\n\nACC_ABSTRACT\n0x0400\n标识这是一个抽象类或是接口类型\n\n\nACC_ANNOTATION\n0x2000\n标识这是一个注解\n\n\nACC_ENUM\n0x4000\n标识这是一个枚举\n\n\n我们定义的 Test.java 是一个普通 Java 类，不是接口、枚举或注解。并且被 public 修饰但没有被声明为 final 和 abstract，因此它所对应的 access_flags 为 0021（0X0001 和 0X0020 相结合）。\n4.5 类索引、父类索引与接口索引计数器在访问标志后的 2 个字节就是类索引，类索引后的 2 个字节就是父类索引，父类索引后的 2 个字节则是接口索引计数器。如下图所示：\n\n可以看出类索引指向常量池中的第 5 个常量，父类索引指向常量池中的第 6 个常量，并且实现的接口个数为 2 个。再回顾下常量池中的数据：\n\n从图中可以看出，第 5 个常量和第 6 个常量均为 CONSTANT_Class_info 表类型，并且代表的类分别是“Test”和“Object”。再看接口计数器，因为接口计数器的值是 2，代表这个类实现了 2 个接口。查看在接口计数器之后的 4 个字节分别为：\n\n0007：指向常量池中的第 7 个常量，从图中可以看出第 7 个常量值为”Serializable”。\n0008：指向常量池中的第 8 个常量，从图中可以看出第 8 个常量值为”Cloneable”。\n\n综上所述，可以得出如下结论：当前类为 Test 继承自 Object 类，并实现了“Serializable”和“Cloneable”这两个接口。\n4.6 字段表紧跟在接口索引集合后面的就是字段表了，字段表的主要功能是用来描述类或者接口中声明的变量。这里的字段包含了类级别变量以及实例变量，但是不包括方法内部声明的局部变量。\n同样, 一个类中的变量个数是不固定的，因此在字段表集合之前还是使用一个计数器来表示变量的个数，如下所示：\u0010\n\n0002 表示类中声明了 2 个变量（在 class 文件中叫字段），字段计数器之后会紧跟着 2 个字段表的数据结构。\n字段表的具体结构如下：\nCONSTANT_Fieldref_info&#123;\n    u2  access_flags    字段的访问标志\n    u2  name_index          字段的名称索引(也就是变量名)\n    u2  descriptor_index    字段的描述索引(也就是变量的类型)\n    u2  attributes_count    属性计数器\n    attribute_info\n&#125;继续解析 Text.class 中的字段表，其结构如下图所示：\n\n4.7 字段访问标志对于 Java 类中的变量，也可以使用 public、private、final、static 等标识符进行标识。因此解析字段时，需要先判断它的访问标志，字段的访问标志如下所示：\n\n\n\n字段访问标志\n值\n描述\n\n\n\nACC_PUBLIC\n0x0001\n字段是否为 public\n\n\nACC_PRIVATE\n0x0002\n字段是否为 private\n\n\nACC_PROTECTED\n0x0004\n字段是否为 protected\n\n\nACC_STATIC\n0x0008\n字段是否为静态static\n\n\nACC_FINAL\n0x0010\n字段是否为 final\n\n\nACC_VOLATILE\n0x0040\n字段是否为 volatile\n\n\nACC_TRANSIENT\n0x0080\n字段是否为 transient\n\n\nACC_ENUM\n0x4000\n字段是否为 enum\n\n\n字段表结构图中的访问标志的值为 0002，代表它是 private 类型。变量名索引指向常量池中的第 9 个常量，变量名类型索引指向常量池中第 10 个常量。第 9 和第 10 个常量分别为“num”和“I”，如下所示：\n\n因此可以得知类中有一个名为 num，类型为 int 类型的变量。对于第 2 个变量的解析过程也是一样，就不再过多介绍。\n注意事项：\n\n字段表集合中不会列出从父类或者父接口中继承而来的字段。\n内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。\n\n对于以上两种情况，可以自行定义一个类查看并手动分析一下。\n4.8 方法表字段表之后跟着的就是方法表常量。相信你应该也能猜到了，方法表常量应该也是以一个计数器开始的，因为一个类中的方法数量是不固定的，如图所示：\n\n上图表示 Test.class 中有两个方法，但是我们只在 Test.java 中声明了一个 add 方法，这是为什么呢？这是因为默认构造器方法也被包含在方法表常量中。\n方法表的结构如下所示：\nCONSTANT_Methodref_info&#123;\n    u2  access_flags;        方法的访问标志\n    u2  name_index;          指向方法名的索引\n    u2  descriptor_index;    指向方法类型的索引\n    u2  attributes_count;    方法属性计数器\n    attribute_info attributes;\n&#125;可以看到，方法也是有自己的访问标志，具体如下：\n\n\n\n访问标志\n值\n描述\n\n\n\nACC_PUBLIC\n0x0001\n方法是否为 public\n\n\nACC_PRIVATE\n0x0002\n方法是否为 private\n\n\nACC_PROTECTED\n0x0004\n方法是否为 protected\n\n\nACC_STATIC\n0x0008\n方法是否为 static\n\n\nACC_FINAL\n0x0010\n放发是否为 final\n\n\nACC_SYNCHRONIZED\n0x0020\n方法是否被 synchronized 修饰\n\n\nACC_VARAGAS\n0x0080\n方法是否可以接收参数\n\n\nACC_NATIVE\n0x0100\n方法是否为 native\n\n\nACC_ABSTRACT\n0X0400\n方法是否为 abstract\n\n\n可以看到，方法也是有自己的访问标志，具体如下：\n\n从图中我们可以看出 add 方法的以下字段的具体值：\n\naccess_flags = 0x0001 也就是访问权限为 public。\nname_index = 0x0011  指向常量池中的第 17 个常量，也就是“add”。\ntype_index = 0x0012   指向常量池中的第 18 个常量，也即是 (I)。这个方法接收 int 类型参数，并返回 int 类型参数。\n\n4.9 属性表在之前解析字段和方法的时候，在它们的具体结构中我们都能看到有一个叫作 attributes_info 的表，这就是属性表。\n属性表并没有一个固定的结构，各种不同的属性只要满足以下结构即可：\nCONSTANT_Attribute_info&#123;\n    u2 name_index;\n    u2 attribute_length length;\n    u1[] info;\n&#125;JVM 中预定义了很多属性表，这里重点讲一下 Code 属性表。\n\nCode属性表\n\n我们可以接着刚才解析方法表的思路继续往下分析：\n\n可以看到，在方法类型索引之后跟着的就是“add”方法的属性。0X0001 是属性计数器，代表只有一个属性。0X000f 是属性表类型索引，通过查看常量池可以看出它是一个 Code 属性表，如下所示：\n\nCode 属性表中，最主要的就是一些列的字节码。通过 javap -v Test.class 之后，可以看到方法的字节码，如下图显示的是 add 方法的字节码指令：\n\nJVM 执行 add 方法时，就通过这一系列指令来做相应的操作。\n","categories":["Android"],"tags":["Android","JVM"]},{"title":"【笔记二】GC 回收机制和分代回收策略","url":"https://blog.onestravel.cn/20210328/68b72d473df5/","content":"【笔记二】GC 回收机制和分代回收策略垃圾回收（Garbage Collection，简写为: GC）是 Java 开发者最关注的一块知识点。Java 语言开发者比 C 语言开发者幸福的地方就在于，不需要手动释放对象的内存，JVM 中的垃圾回收器（Garbage Collector）会为我们自动回收。但是也是又对应的代价的：一旦这种自动化机制出错，就必须区深入理解 GC 回收机制，甚至需要对这些 “自动化” 的技术实施必要的监控和调节。\nJava 内存运行时区域中程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作，这几个区域内不需要过多考虑回收的问题。\n而堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的就是这部分内存。\n1. 什么是垃圾所谓垃圾就是内存中已经没有用的对象。既然是“垃圾回收”，那就需要知道哪些对象是垃圾。Java 虚拟机中使用一种叫做 “可达性分析” 的算法来决定对象是否可以被回收。\n1.1 可达性分析可达性分析算法是从离散数学图论引入的，JVM 把内存中对象的引用关系看做一张图，从一组叫做 “GC Root” 的对象作为起始点，从这些结点开始向下搜索，搜索走过的路径成为引用链，最后通过判断对象的引用链是否可达来决定对象是否可以被回收。如下图所示：\n\n\n如上图所示，对象 A、B、C、D、E 都与 “GC Root” 之间存在一条直接或者间接的引用链，这代表它们与 “GC Root” 之间是可达的，因此他们是不能被 GC 回收掉的。而对象 K 和对象 M 都被对象 J 所引用到，但是并不存在一条引用链连接他们和 “GC Root” ，所以当 GC 进行垃圾回收时，只要遍历到 J、K 、M 这三个对象，就会将他们回收掉。\n\n注意：上图中圆形图标虽然标记的是对象，但实际上代表该对象在内存中的引用。包括 “GC Root” 也是一组引用而并非对象。\n\nGC Root在 Java 中，有一下几种对象可以作为 GC Root:\n\nJava 虚拟机栈（局部变量表）中引用的对象；\n方法区中静态引用指向的对象；\n仍处于存货状态中的对象；\nNative 中 JNI 引用的对象。\n\n2. 什么时候回收不同的虚拟机有着不同的 GC 实现机制，但是一般情况下每一种 GC 的实现都会再以下两种情况触发垃圾回收。\n\nAllocation Failure：再堆内存分配时，如果因为剩余可用空间不足导致对象内存分配失败，这时候系统会触发依次 GC。\nSystem.gc()：在应用层，Java 开发工程师可以主动调用此 API 来请求依次  GC 。\n\n3. 代码验证 GC Root 的几种情况现在我们了解了 Java 中的 GC Root ，以及何时触发 GC 。接下来就通过几个案例来验证 GC Root 的几种情况。在看代码之前，先了解一下执行 Java 命令时的参数。\n\n-Xms 初始分配 JVM 运行时的内存大小，如果不指定，默认为物理内存的 1/64。\n\n比如我们运行如下命令执行 HelloWord 程序，从物理内存中分配出 200M 空间分配给 JVM 内存。\njava -Xms200m HelloWorld\n3.1 验证虚拟机栈（栈帧中局部变量）中引用对象作为 GC Root运行如下代码：\npublic class GCRootLocalVariable {\n    private int _10MB = 10 * 1024 * 1024;\n    private byte[] memory = new byte[8 * _10MB];\n\n    public static void main(String[] args){\n        System.out.println(\"开始时:\");\n        printMemory();\n        method();\n        System.gc();\n        System.out.println(\"第二次GC完成\");\n        printMemory();\n    }\n\n    public static void method() {\n        GCRootLocalVariable g = new GCRootLocalVariable();\n        System.gc();\n        System.out.println(\"第一次GC完成\");\n        printMemory();\n    }\n\n    /**\n     * 打印出当前JVM剩余空间和总的空间大小\n     */\n    public static void printMemory() {\n        System.out.print(\"free is \" + Runtime.getRuntime().freeMemory()/1024/1024 + \" M, \");\n        System.out.println(\"total is \" + Runtime.getRuntime().totalMemory()/1024/1024 + \" M, \");\n    }\n}\n日志如下：\n开始时:\nfree is 242 M, total is 245 M,\n第一次GC完成\nfree is 163 M, total is 245 M,\n第二次GC完成\nfree is 243 M, total is 245 M,\n分析：\n\n当第一次 GC 时，g 作为局部变量（new 出来的80M对象）的引用，并且它作为 GC Root ，在调用 GC 后，并不会被 GC 回收\n当第二次 GC 时，method() 方法执行完成后，局部变量 g 跟随方法消失，不再有引用类型执行该 80M 对象，所以第二次 GC 时会被回收。\n\n\n注意：上面的日志包括后面的实例中，因为有中间变量，所以会有1M 左右的误差，不影响进行  GC 分析。\n\n3.2 验证方法区中的静态变量引用的对象作为 GC Root运行如下代码：\npublic class GCRootStaticVariable{\n    private static int _10MB = 10 * 1024 * 1024;\n    private byte[] memory;\n    private static GCRootStaticVariable staticVariable;\n\n    public GCRootStaticVariable(int size) {\n        memory = new byte[size];\n    }\n\n    public static void main(String[] args){\n        System.out.println(\"程序开始:\");\n        printMemory();\n        GCRootStaticVariable g = new GCRootStaticVariable(4 * _10MB);\n        g.staticVariable = new GCRootStaticVariable(8 * _10MB);\n        // 将g置为null, 调用GC时可以回收此对象内存\n        g = null;\n        System.gc();\n        System.out.println(\"GC完成\");\n        printMemory();\n    }\n\n    /**\n     * 打印出当前JVM剩余空间和总的空间大小\n     */\n    public static void printMemory() {\n        System.out.print(\"free is \" + Runtime.getRuntime().freeMemory()/1024/1024 + \" M, \");\n        System.out.println(\"total is \" + Runtime.getRuntime().totalMemory()/1024/1024 + \" M, \");\n    }\n}\n打印结果如下：\n程序开始:\nfree is 242 M, total is 245 M,\nGC完成\nfree is 163 M, total is 245 M,\n分析：\n程序刚开始运行时内存为 242M ，并分别创建了 g 对象（40M），初始化了 g 对象内部的静态变量 staticVariable 对象（80M）。当调用 GC 时，g 对象引用为置为 null , 该40M 对象被 GC 回收，而 staticVariable 对象（80M）作为 GC Root ，它引用的 80M 对应并未被回收。\n3.3 验证活跃线程作为 GC Root运行如下代码\npublic class GCRootThread{\n\n    private int _10MB = 10 * 1024 * 1024;\n    private byte[] memory = new byte[8 * _10MB];\n\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"开始前内存情况:\");\n        printMemory();\n        AsyncTask at = new AsyncTask(new GCRootThread());\n        Thread thread = new Thread(at);\n        thread.start();\n        System.gc();\n        System.out.println(\"main方法执行完毕，完成GC\");\n        printMemory();\n\n        thread.join();\n        at = null;\n        System.gc();\n        System.out.println(\"线程代码执行完毕，完成GC\");\n        printMemory();\n    }\n\n    /**\n     * 打印出当前JVM剩余空间和总的空间大小\n     */\n    public static void printMemory() {\n        System.out.print(\"free is \" + Runtime.getRuntime().freeMemory()/1024/1024 + \" M, \");\n        System.out.println(\"total is \" + Runtime.getRuntime().totalMemory()/1024/1024 + \" M, \");\n    }\n\n    private static class AsyncTask implements Runnable {\n        private GCRootThread gcRootThread;\n\n        public AsyncTask(GCRootThread gcRootThread){\n            this.gcRootThread = gcRootThread;\n        }\n\n        @Override\n        public void run() {\n            try{\n                Thread.sleep(500);\n            } catch(Exception e){}\n        }\n    }\n}\n打印日志如下：\n开始前内存情况:\nfree is 242 M, total is 245 M,\nmain方法执行完毕，完成GC\nfree is 163 M, total is 245 M,\n线程代码执行完毕，完成GC\nfree is 243 M, total is 245 M,\n分析：\n程序刚开始时是 242M 内存，当调用第一次 GC 时线程并没有执行结束，并且它作为 GC Root，所以它所引用的 80M 内存并不会被 GC 回收掉。 thread.join() 保证线程结束再调用后续代码，所以当调用第二次 GC 时，线程已经执行完毕并被置为 null，这时线程已经被销毁，所以之前它所引用的 80M 此时会被 GC 回收掉。\n3.4 测试成员变量是否可以作为 GC Root运行如下代码：\npublic class GCRootClassVariable{\n\n    private static int _10MB = 10 * 1024 * 1024;\n    private byte[] memory;\n    private GCRootClassVariable classVariable;\n\n    public GCRootClassVariable(int size){\n        memory = new byte[size];\n    }\n\n    public static void main(String[] args){\n        System.out.println(\"程序开始:\");\n        printMemory();\n        GCRootClassVariable g = new GCRootClassVariable(4 * _10MB);\n        g.classVariable = new GCRootClassVariable(8 * _10MB);\n        g = null;\n        System.gc();\n        System.out.println(\"GC完成\");\n        printMemory();\n    }\n\n    /**\n     * 打印出当前JVM剩余空间和总的空间大小\n     */\n    public static void printMemory() {\n        System.out.print(\"free is \" + Runtime.getRuntime().freeMemory()/1024/1024 + \" M, \");\n        System.out.println(\"total is \" + Runtime.getRuntime().totalMemory()/1024/1024 + \" M, \");\n    }\n}\n打印日志如下：\n程序开始:\nfree is 242 M, total is 245 M,\nGC完成\nfree is 243 M, total is 245 M,\n分析：\n从上面日志中可以看出当调用 GC 时，因为 g 已经置为 null，因此 g 中的全局变量 classVariable 此时也不再被 GC Root 所引用。所以最后 g(40M) 和 classVariable(80M) 都会被回收掉。这也表明全局变量同静态变量不同，它不会被当作 GC Root。\n\n上面演示的这几种情况往往也是内存泄漏发生的场景，设想一下我们将各个 Test 类换成 Android 中的 Activity 的话将导致 Activity 无法被系统回收，而一个 Activity 中的数据往往是较大的，因此内存泄漏导致 Activity 无法回收还是比较致命的。\n\n4. 如何进行垃圾回收由于垃圾收集算法的实现涉及大量的程序细节，各家虚拟机厂商对其实现细节各不相同，下面介绍几种算法的思想以及优缺点。\n4.1 标记清除算法（Mark and Sweep GC）从 GC Roots 集合开始，将内存整个遍历一次，保留所有可以被 GC Roots 直接或间接引用到的对象，而剩下的对象都作为垃圾对待并回收，可以分为以下两步：\n\nMark 标记阶段：找到内存中所以 GC Root 对象，将和 GC Root 直接或间接引用的对象标记为灰色（存活对象），否则标记位黑色（垃圾对象）。\nSweep 清除阶段：遍历完内存中所以对象后，直接将标记为垃圾的对象清除。\n\n\n\n优缺点分析：\n优点：实现简单，不需要将对象进行移动\n缺点：这个算法需要中断进程内其他组件的执行（stop the world），并可能产生内存碎片，提高了垃圾回收的频率。\n4.2 复制算法（Copying）将现有的内存分为两块，每次只使用其中一块；在垃圾回收时，将正在使用的内存块中存活的对象复制到未被使用的内存块中；之后将正在使用的内存块中的所有对象进行清除，交换两个内存块的角色，完成垃圾回收。 \n\n复制算法之前，内存分为 A/B 两块，并且当前只使用内存 A，内存的状况如下图所示：\n\n\n标记完之后，所有可达对象都被按次序复制到内存 B 中，并设置 B 为当前使用中的内存。内存状况如下图所示：\n\n\n\n优缺点分析：\n优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。\n4.3 标记-压缩算法（Mark-Compact）需要从根节点开始对所有可达对象做一次标记，之后，它不简单清理未标记对象，而是将所有存活对象压缩到内存的一端。最后，清理边界外所有空间。因此，标记压缩算法也分两步进行：\n\nMark 标记阶段：找到内存中所以 GC Root 对象，只要是和 GC Root 对象直接或间接相连的标记位灰色（存活对象），否则标记位黑色（回收垃圾对象）。\n\nCompact 压缩阶段：将剩余存活对象按顺序压缩到内存的某一端。\n\n\n\n\n优缺点分析：\n优点：这种方法既避免了内存碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高\n缺点：所谓压缩操作，需要对局部对象进行移动，所以，一定程度上还是降低了效率。\n4.4 JVM 分代回收策略Java 虚拟机根据内存中对象的存活周期的不同，把内存划分为几块；一般分为新生代、老年代，这就是 JVM 的分代回收策略。在 HotSpot 中，除了新生代和老年代还有永久代。\n分代回收的中心思想就是：对于新创建的对象会在新生代区域分配内存，此区域的对象生命周期一般比较短。如果经过多次回收仍然存活下来则将它们转移到老年代区域中。\n新生代（年轻代 Young Generation）\n新生成的对象优先存放在新生代区域中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾回收一般可以回收70%~95% 的空间，回收率很高。新生代区域中需要一些复制操作，所以在新生代区域中使用的垃圾回收算法是复制算法。\n新生代区域又可以继续细分为3部分：Eden、Survivor0（简称 S0）、Survivor1（简称 S1）。这三部分按照8 : 1 : 1 的比例来划分。这3块内存区域的分配如下：\n绝大多数刚刚被创建的对象会存放在 Eden 区。如图所示：\n\n\n当 Eden 区第一次满的时候，会进行垃圾回收。首先将 Eden 区的垃圾对象回收清除，并将存活的对象复制到 S0 ，此时 S1 时空的。如图所示：\n\n\n下一次 Eden 区满时，在进行一次垃圾回收。此时将 Eden 区和 S0 区中的垃圾对象进行回收清除，并将存活对象复制到 S1 区，此时 S0 是空的。如图所示：\n\n\n如此反复在 S0 和 S1 切换几次（默认15次）之后，如果还有存活对象。说明这些对象的生命周期较长，则将他们转移到老年代中。如图所示：\n\n\n老年代\n一个对象在如果在新生代区域存活了足够长时间没有被清理掉，则会被复制到老年代。老年代的内存大小一般比新生代大，能存放更多的对象。如果对象比较大（字符串或大数组），并且新生代剩余空间不足，则这个大对象会被直接分配到老年代。\n我们可以使用 -XX:PretenureSizeThreshold 来控制直接升入老年代对象的大小，大于这个值的对象会直接分配到老年代区域。老年代因为生命周期比较长，不需要过多的复制操作，，所以一般采用标记-压缩的回收算法。\n\n注意：对于老年代，可能存在这么一种情况，老年代中的对象有时候会引用到新生代中的对象。如果这时候要执行 GC ，则可能需要查询整个老年代上可能存在引用新生代中的对象的情况，这显然是低效的。所以，老年代中维护了一个 512 byte 的card table，所有老年代对象引用新生代对象的信息都记录在这里。每当新生代 GC 发生时，只需要检查这个 card table 即可，大大提高了性能。\n\n5. GC log 分析为了让上层应用开发人员更方便的调试 Java 程序，JVM 提供了相应的 GC 日志。在 GC 执行垃圾回收时间过程中，会有各种相应的 log 被打印出来。其中新生代和老年代打印出来的 log 日志是有区别的。\n\n新生代 GC ：这一区域的 GC 叫做 Minor GC。因为 Java 对象大都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。\n老年代 GC：发生在这一区域的 GC 叫做 Major GC 或者 Full GC。当出现了 Major GC，经常会伴随至少一次的 Minor GC。\n\n\n注意：在有些虚拟机实现中，Major GC 和 Full GC 还是有一定的区别的。Major GC 只是代表回收老年代区域的内存，Full GC 代表回收整个堆中的内存，也就是新生代+老年代。\n\n首先我们需要先理解几个 Java 命令参数\n\n\n\n命令参数\n功能描述\n\n\n\n-verbose:gc\n显示 GC 的操作内容\n\n\n-Xms20M\n初始化堆大小为20M\n\n\n-Xmx20M\n设置堆最大分配内存20M\n\n\n-Xmn10M\n设置新生代内存大小为10M\n\n\n-XX:+printGCDetails\n打印 GC 的详细 log 日志\n\n\n-XX:SurvivorRatio=8\n新生代中的 Eden 区域与Survivor 区域的大小比值为 8:1:1\n\n\n使用如下代码，在内存中创建 4 个 byte 类型数组来演示内存分配与 GC 的详细过程。代码如下：\n/**\n* VM agrs: -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails\n* -XX:SurvivorRatio=8\n*/\npublic class MinorGCTest {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void testAllocation() {\n        byte[] a1, a2, a3, z4;\n        a1 = new byte[2 * _1MB];\n        a2 = new byte[2 * _1MB];\n        a3 = new byte[2 * _1MB];\n        a4 = new byte[1 * _1MB];\n    }\n\n    public static void main(String[] agrs) {\n        testAllocation();\n    }\n}\n通过上面的参数可以看出堆内存总大小为 20M，其中新生代占 10M，剩下的10M 会自动分配给老年代。执行上面代码打印日志如下：\nHeap\nPSYoungGen      total 9216K, used 8003K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)\n  eden space 8192K, 97% used [0x00000007bf600000,0x00000007bfdd0ed8,0x00000007bfe00000)\n  from space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)\n  to   space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000)\nParOldGen       total 10240K, used 0K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)\n  object space 10240K, 0% used [0x00000007bec00000,0x00000007bec00000,0x00000007bf600000)\nMetaspace       used 2631K, capacity 4486K, committed 4864K, reserved 1056768K\n  class space    used 286K, capacity 386K, committed 512K, reserved 1048576K\n日志中的各字段代表意义如下：\n\n\n\n字段\n含义\n\n\n\nPSYoungGen\n新生代\n\n\neden\n新生代中的 Eden 区\n\n\nfrom\n新生代中的 S0 区\n\n\nto\n新生代中的 S1 区\n\n\nParOldGen\n老年代\n\n\n从日志中可以看出：程序执行完之后，a1，a2，a3，a4 四个对象都被分配在了新生代的 Eden 区。\n如果我们将测试代码中的 a4 初始化改为 ``a4 = new byte[2*_1M]，则打印日志如下：\n[GC (Allocation Failure) [PSYoungGen: 6815K->480K(9216K)] 6815K->6632K(19456K), 0.0067344 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]\nHeap\nPSYoungGen      total 9216K, used 2130K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)\n  eden space 8192K, 26% used [0x00000007bf600000,0x00000007bf814930,0x00000007bfe00000)\n  from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000)\n  to   space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)\nParOldGen       total 10240K, used 6420K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)\n  object space 10240K, 62% used [0x00000007bec00000,0x00000007bf2450d0,0x00000007bf600000)\nMetaspace       used 2632K, capacity 4486K, committed 4864K, reserved 1056768K\n  class space    used 286K, capacity 386K, committed 512K, reserved 1048576K\n这是因为在给 a4 分配内存之前，Eden 区已经被占用6M。已经无法再分配出 2M 来存储 a4 对象。因此会执行一次 Minor GC，并尝试将存活的 a1，a2，a3 对象复制到 S1 区。但是 S1区只有1M 空间，所以没有办法存储a1、a2、a3 任意一个对象。在这种情况下，a1、a2、a3 被转移到老年代，最后将 a4 存储在 Eden 区。所以最终的结果就是：Eden 区占用2M(a4)，老年代占用6M（a1,a2,a3）。\n6. 引用上面说过，判断对象是否存活是通过 GC Roots 的引用可达性来判断的。但 JVM 中的引用关系不止一种，而是有四种，根据引用由强到弱，他们分别是：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）。\n四种引用的简单对比：\n\n\n\n引用\nGC 回收时机\n使用示例\n\n\n\n强引用\n如果一个对象具有强引用，那垃圾回收器绝不会回收它\nObject obj = new Object();\n\n\n软引用\n内存实在不足时，会对软引用进行回收\nSoftReference softObj = new SoftReference();\n\n\n弱引用\n第一次垃圾回收时，如果垃圾回收器遍历到此弱引用，则将其回收\nWeakReference weakObj = new WeakReference();\n\n\n虚引用\n一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过虚引用来获取一个对象的实例\n不会使用\n\n\n平时项目中，尤其是Android项目，因为有大量的图像(Bitmap)对象，使用软引用的场景较多。所以重点看下软引用SoftReference的使用，不当的使用软引用有时也会导致系统异常。\n软引用常规使用\n 常规使用代码如下\npublic class SoftReferenceNormal {\n  static class SoftObject {\n    byte[] data = new byte[120 * 1024 * 1024];//120M\n  }\n\n  public static void main(String[] args) throws InterruptedException {\n    SoftReference&lt;SoftObject> cacheRef = new SoftReference&lt;>(new SoftObject());\n\n    System.out.println(\"第一次 GC 前，软引用：\"+cacheRef.get());\n    System.out.println(\"第一次 GC 后，软引用：\"+cacheRef.get());\n\n    //再分配一个120M 对象\n    SoftObject newSo = new SoftObject();\n    System.out.println(\"再次分配120M 强引用对象后，软引用：\"+cacheRef.get());\n  }\n}\n执行上述代码，打印日志如下：\n$ java -Xmx200m SoftReferenceNormal\n第一次 GC 前，软引用：SoftReferenceNormal$SoftObject@5c647e05\n第一次 GC 后，软引用：SoftReferenceNormal$SoftObject@5c647e05\n再次分配120M 强引用对象后，软引用：null\n首先通过-Xmx将堆最大内存设置为200M。从日志中可以看出，当第一次GC时，内存中还有剩余可用内存，所以软引用并不会被GC回收。但是当我们再次创建一个120M的强引用时，JVM可用内存已经不够，所以会尝试将软引用给回收掉。\n软引用隐藏问题\n需要注意的是，被软引用对象关联的对象会自动被垃圾回收器回收，但是软引用对象本身也是一个对象，这些创建的软引用并不会自动被垃圾回收器回收掉。比如如下代码：\nimport java.lang.ref.SoftReference;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic class SoftReferenceTest {\n    static class SoftObject {\n        byte[] data = new byte[1024];//1KB\n      }\n\n  public static final int CACHE_INITIAL_CAPACITY = 100 * 1024;//100M\n  //静态集合保存软引用对象，会导致这些软引用对象本身不能被垃圾回收器回收\n  public static Set&lt;SoftReference&lt;SoftObject>> cache = new HashSet&lt;>(CACHE_INITIAL_CAPACITY);\n\n  public static void main(String[] args) throws InterruptedException {\n    for (int i = 0; i &lt; CACHE_INITIAL_CAPACITY ; i++) {\n        SoftObject obj = new SoftObject();\n        cache.add(new SoftReference&lt;>(obj));\n        if(i % 10000 == 0){\n             System.out.println(\"size of cache：\"+cache.size());\n        }\n    }\n\n    System.out.println(\"The End!\");\n    }\n}\n执行上述代码，打印日志如下：\n$java -Xms4M -Xmx4m -Xmn2M SoftReferenceTest\nsize of cache：1\nsize of cache：10001\nsize of cache：20001\nsize of cache：30001\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n    at SoftReferenceTest$SoftObject.&lt;init>(SoftReferenceTest.java:7)\n    at SoftReferenceTest.main(SoftReferenceTest.java:16)\n\n限制堆内存大小为4M，最终程序崩溃，但是异常的原因并不是普通的堆内存溢出，而是”GC overhead”。之所以会抛出这个错误，是由于虚拟机一直在不断回收软引用，回收进行的速度过快，占用的cpu过大(超过98%)，并且每次回收掉的内存过小(小于2%)，导致最终抛出了这个错误。\n这里需要做优化，合适的处理方式是注册一个引用队列，每次循环之后将引用队列中出现的软引用对象从cache中移除。如下所示：\nimport java.lang.ref.SoftReference;\nimport java.lang.ref.ReferenceQueue;\nimport java.lang.ref.Reference;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic class SoftReferenceTest {\n    static class SoftObject {\n        byte[] data = new byte[1024];//1KB\n      }\n\n      public static int removedSoftRefs = 0;\n      public static final int CACHE_INITIAL_CAPACITY = 100 * 1024;//100M\n      //静态集合保存软引用对象，会导致这些软引用对象本身不能被垃圾回收器回收\n      public static Set&lt;SoftReference&lt;SoftObject>> cache = new HashSet&lt;>(CACHE_INITIAL_CAPACITY);\n      public static ReferenceQueue&lt;SoftObject> referenceQueue = new ReferenceQueue&lt;>();\n\n      public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i &lt; CACHE_INITIAL_CAPACITY ; i++) {\n            SoftObject obj = new SoftObject();\n            cache.add(new SoftReference&lt;>(obj,referenceQueue));\n            clearUselessReference();\n            if(i % 10000 == 0){\n                 System.out.println(\"size of cache：\"+cache.size());\n            }\n        }\n\n        System.out.println(\"The End!\");\n    }\n\n\n    public static void clearUselessReference() {\n        Reference&lt;? extends SoftObject> ref = referenceQueue.poll();\n        while (ref != null){\n            if(cache.remove(ref)){\n                removedSoftRefs++;\n            }\n            ref = referenceQueue.poll();\n        }\n\n    }\n}\n再次运行修改后的代码，结果如下：\n$java -Xms4M -Xmx4m -Xmn2M SoftReferenceTest\nsize of cache：1\nsize of cache：1700\nsize of cache：1310\nsize of cache：920\nsize of cache：530\nsize of cache：2218\nsize of cache：1828\nsize of cache：1310\nsize of cache：708\nsize of cache：280\nsize of cache：1940\nThe End! removes soft Reference 100657\n\n可以看出优化后，程序可以正常执行完。并且在执行过程中会动态的将集合中的软引用删除。\n总结虚拟机垃圾回收机制很多时候都是影响系统性能、并发能力的主要因素之一。尤其是对于从事 Android 开发的工程师来说，有时候垃圾回收会很大程度上影响 UI 线程，并造成界面卡顿现象。因此理解垃圾回收机制并学会分析 GC Log 也是一项必不可少的技能。\n","categories":["Android"],"tags":["Android","JVM"]},{"title":"【笔记一】Java程序运行时，内存是如何分配的","url":"https://blog.onestravel.cn/20210128/3659e5f3ab6f/","content":"【笔记一】Java程序运行时，内存是如何分配的Java 虚拟机在执行Java 程序的过程中，会把它所管理的内存划分为不同的数据区域；主要分为：程序计数器、虚拟机栈、本地方法栈、堆、方法区。\n下图描述一个 HelloWord.java 文件被加载到内存的过程：\n\nHelloWord.java 首先需要经过编译器编译，生成 HelloWord.class 字节码文件；\nJava 程序中访问 HelloWord 这个类时，需要通过 ClassLoader(类加载器) 将HelloWord.class加载到 JVM 内存中；\nJVM 中的内存可以划分为若干个不同的数据区域，主要分为：程序计数器、虚拟机栈、本地方法栈、堆、方法区。\n\n\n\n1.1 程序计数器（Program Counter Register）Java 程序时多线程的，CPU 可以在多个线程中分配执行时间片段，当其中一个线程被 CPU 挂起时，需要记录代码已经执行到的位置，方便 CPU 重新执行此线程时，可以知道从那一行指令开始继续执行，这就是程序计数器的作用。\n“程序计数器” 是虚拟机中较小的一块存储空间，主要用于记录当前线程执行的位置。\n如下图所示：每个线程都会记录一个当前方法执行到的位置，当 CPU 切回到某一个线程时，可以根据程序计数器记录的位置，继续向下执行指令。\n\n\n除了上图所示的恢复线程数据之外，其他一些我们熟悉的分支操作、循环操作、跳转、异常处理等也都需要依赖程序计数器来完成。\n关于程序计数器需要注意的地方：\n\n在 Java 虚拟机规范中，并没有对程序计数器这一区域规定任何的 OutOfMemoryError 情况。\n\n程序计数器是线程私有的，每个线程中都有一个程序计数器。它的生命周期随着线程的创建而创建，随着线程的结束而死亡。\n\n当一个线程正在执行一个 Java 方法的时候，这个程序计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是 Native 方法，这个程序计数器的值是则为空（Undefined）。\n\n\n1.2 虚拟机栈虚拟机栈也是线程私有的，与线程的生命周期同步。在 Java 虚拟机规范中，对各个区域规定了两种异常状况：\n\nStackOverflowError ：当线程请求栈深度超出虚拟机栈所允许的深度时抛出。\nOutOfMemoryError ：当 Java 虚拟机栈动态扩展到无法申请足够内存时抛出。\n\n在我们学习Java 虚拟机的过程中，经常会看到一句话\nJVM 是基于栈的解释器执行的，DVM 是基于寄存器的解释器执行的。\n上面这句话中的 『基于栈』指的就是虚拟机栈。虚拟机栈的初衷是用来描述 Java 方法执行的内存模型，每个方法被执行的时候，JVM 都会在虚拟机栈中创建一个栈帧，接下来看这个栈帧具体是什么：\n1.2.1 栈帧栈帧（Stack Frame） 是用于支持虚拟机进行方法调用和执行的数据结构，每一个线程在执行某个方法时，都会为该方法创建一个对应的栈帧。\n我们可以这样理解：一个线程包含多个栈帧，而每个栈帧内部包含『局部变量表』，『操作数栈』，『动态链接』『返回地址』等。如下图所示：\n\n1.2.1.1 局部变量表局部变量表是变量值的存储空间，我们调用方法时传递的参数，以及在方法内部创建的局部变量都保存在 局部变量表 中。在 Java 编译成 class 文件的时候，就会在方法的 Code 属性表中的 max_locals 数据项中，确定该方法需要分配的最大局部变量表的容量。如下代码所示：\npublic static int add(int k) {\n    int i = 1;\n    int j = 2;\n    return i + j + k;\n}\n使用 javap -v 反编译之后，得到如下字节码指令：\npublic static int add(int);\n    descriptor: (I)I\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: iconst_1\n         1: istore_1\n         2: iconst_2\n         3: istore_2\n         4: iload_1\n         5: iload_2\n         6: iadd\n         7: iload_0\n         8: iadd\n         9: ireturn\n\n上面的 locals=3 代表的就是局部变量表的长度为3，也就是说经过编译之后，局部变量表的长度已经固定为3，分别保存 参数k 和 局部变量 i 、j 。\n\n注意：系统不会为局部变量表赋予初始值（实例变量和类变量都会被赋予初始值），也就是说不存在类变量那样的准备阶段。\n\n1.2.1.2 操作数栈操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出栈（LIFO）。\n同局部变量表一样，操作数栈的最大深度也是在编译的时候写入方法的 Code 属性表中的 max_tacks 数据项中。栈中的数据元素可以是任意的Java 数据类型，包括long和double。\n当一个方法刚刚开始执行时，这个方法的操作数栈时空的；在方法执行过程中，会有各种字节码的指令被压入和弹出操作数栈。比如：iadd 指令就是将操作数栈中栈顶的两个整型元素弹出，执行加法运算，并将运算结果重新压回操作数栈中。\n1.2.1.3 动态链接动态链接 的主要目的是为了支持方法调用过程中的动态链接（Dynamic Linking）。\n在一个class 文件中，一个方法调用其他方法，需要将这些方法的符号引用转化为其所在内存地址中的直接引用；而符号引用存在于方法区中。\n在Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈中所属方法的符号引用，持有这个引用的目的就是为了支持方法调用过程中的动态链接（Dynamic Linking）。\n1.2.1.4 返回地址当一个方法开始执行后，只有两种方式可以退出这个方法：\n\n正常退出 ：指方法中的代码正常完成，或者遇到任意一个方法返回的字节码指令（如return）并退出，没有抛出任何异常；\n异常退出 ：指方法执行过程中遇到异常，并且这个异常在方法体中没有得到处理，导致方法退出。\n\n无论当前方法采用何种方式退出，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行。而虚拟机栈中所说的返回地址就是用来帮助当前方法恢复它的上层方法执行状态。\n一般来说，方法正常退出时，调用者的 PC 计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理表确定的，栈帧中一般不会保存此部分信息。\n实例讲解：\n用一个简单的add() 代码来演示\npublic int add() {\n  int i = 1;\n  int j = 2;\n  int result = i + j;\n  return result + 10;\n}\n经过 javap -v之后的字节码指令如下：\n0: iconst_1    （把常量 1 压入操作数栈栈顶）\n1: istore_1    （把操作数栈栈顶的出栈放入局部变量表索引为 1 的位置）\n2: iconst_2    （把常量 2 压入操作数栈栈顶）\n3: istore_2    （把操作数栈栈顶的出栈放入局部变量表索引为 2 的位置）\n4: iload_1     （把局部变量表索引为 1 的值放入操作数栈栈顶）\n5: iload_2     （把局部变量表索引为 2 的值放入操作数栈栈顶）\n6: iadd        （将操作数栈栈顶的和栈顶下面的一个进行加法运算后放入栈顶）\n7: istore_3    （把操作数栈栈顶的出栈放入局部变量表索引为 3 的位置）\n8: iload_3     （把局部变量表索引为 3 的值放入操作数栈栈顶）\n9: bipush 10   （把常量 10 压入操作数栈栈顶）\n11: iadd       （将操作数栈栈顶的和栈顶下面的一个进行加法运算后放入栈顶）\n12: ireturn    （结束）\n可以看到：局部变量表和操作数栈在代码执行期间是协同合作来达到某一运算效果的。接下来通过图示来看下这几行代码执行期间，虚拟机栈的实际情况。\n\niconst 和 bipush，这两个指令都是将常量压入操作数栈顶，区别就是：当 int 取值 -15 采用 iconst 指令，取值 -128127 采用 bipush 指令。\nistore 将操作数栈顶的元素放入局部变量表的某索引位置，比如 istore_5 代表将操作数栈顶元素放入局部变量表下标为 5 的位置。\niload 将局部变量表中某下标上的值加载到操作数栈顶中，比如 iload_2 代表将局部变量表索引为 2 上的值压入操作数栈顶。\niadd 代表加法运算，具体是将操作数栈最上方的两个元素进行相加操作，然后将结果重新压入栈顶。\n\n首先在 .java 文件被编译成 .class 文件的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到的方法的Code 属性中。因此这会局部变量表的大小是确定的，add() 方法中有3 个局部变量，因此局部变量表大小为3，但是操作数栈此时为空。\n所以刚刚执行到 add() 方法时，局部变量表和操作数栈的情况如下：\n\n\niconst_1 将常量1压入操作数栈顶，结果如下：\n\n\nistore_1 把操作数栈顶的元素出栈并放入局部变量表下标为 1 的位置，结果如下：\n\n\n可以看出此时操作数栈重新变为空，并将出栈的元素 1 保存在局部变量表中。\niconst_2 把常量 2 压入操作数栈顶，结果如下：\n\n\nistore_2 把操作数栈顶的元素出栈并放入局部变量表下标为 2 的位置，结果如下：\n\n\n接下来是两步 iload 操作，分别是 iload_1 和 iload_2。分别代表的是将局部变量表中下标为 1 和下标为 2 的元素重新压入操作数栈中，结果如下：\n\n\n接下来进行 iadd 操作，这个操作会将栈顶最上方的两个元素（也就是 1、2）进行加法操作，然后将结果重新压入到栈顶，执行完之后的结果如下：\n\n\nistor_3 将操作数栈顶的元素出栈，并保存在局部变量表下标为 3 的位置。结果如下：\n\n\niload_3 将局部变量表中下标为 3 的元素重新压入到操作数栈顶，结果如下：\n\n\nbipush 10 将常量 10 压入到操作数栈中，结果如下：\n\n\n再次执行 iadd 操作，注意此时栈顶最上方的两个元素为 3 和 10，所以执行完结果如下：\n\n\n最后执行 return 指令，将操作数栈顶的元素 13 返回给上层方法。至此 add() 方法执行完毕。局部变量表和操作数栈也会相继被销毁。\n1.3 本地方法栈本地方法栈和上面所讲的虚拟机栈基本相同，只不过是针对本地（Native）方法。如果在开发中涉及 JNI 可能接触本地方法栈多一点。有些虚拟机的实现已经将两个栈合二为一了（比如HotSpot）。\n1.4 堆Java 堆（Heap）是 JVM 所管理的内存区域中最大的一块，该区域唯一的目的就是存放对象实例，几乎所有对象的实例都在堆里面分配，因此它也是 Java 垃圾收集器（GC）管理的主要区域，有时也叫 GC 堆。同时，它也是所有线程共享的内存区域，因此被分配在此区域的对象被多个线程访问的话，需要考虑线程安全问题。\n按照对象存储时间的不同，堆中的内存可以划分为新生代（Young）和老年代（Old），其中新生代又被划分为 Eden 和 Survivor 区。\n\n\n图中不同的存放区域具有不同的生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，进而提高垃圾回收效率。\n1.5 方法区方法区（Method Area）是 JVM 规范中规定的一块运行时数据区。方法区主要时存储已经被 JVM 加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码和数据。该区域和堆一样，也是被各个线程共享的内存区域。\n\n注意：关于方法区很多开发者会将其跟『永久区』混淆。\n\n方法区是 JVM 规范中规定的一块内存区域，但并不是实际实现，切记将规范和实现混为一谈，不同的 JVM 厂商可以有不同版本的『方法区』的实现。\nHotSpot 在 JDK 1.7 之前使用『永久区』（或者叫 Perm 区）来实现方法区 ，在JDK 1.8 之后『永久区』就被移除掉了，取而代之的是一个叫做 『元空间（metaspace）』的实现方式。\n\n\n总结一下就是：\n1. 方法区是规范层面的东西，规定了这一区域要存放哪些数据。\n2. 永久区或者metaspace是堆方法区的不同的实现，是实现层面的东西。1.6 异常情况1.6.1 StackOverflowError 栈溢出异常递归调用是造成 StackOverflowError 的一个常见场景，如以下代码：\npublic class StackOver{\n  private int number;\n\n  public static void main(String[] args){\n    StackOver so = new StackOver();\n    try{\n      so.method();\n    }catch(Exception e){\n      System.out.println(\"出现栈溢出\");\n    }\n  }\n\n\n  public void method(){\n    number++;\n    method();\n  }\n}\n在method方法中，递归调用了自身，并且没有设置递归结束条件。运行上述代码时，则会产生StackOverflowError。\n原因就是每调用一次method方法时，都会在虚拟机栈中创建出一个栈帧。因为是递归调用，method方法并不会退出，也不会将栈帧销毁，所以必然会导致StackOverflowError。因此当需要使用递归时，需要格外谨慎。\n1.6.2  OutOfMemeryError 内存溢出异常理论上，虚拟机栈、堆、方法区都有可能发生 OutOfMemeryError ，但是实际项目中，大多数发生在堆当中。如以下代码：\nimport java.util.ArraryList;\n\npublic class HeapError{\n  public static void main(String[] args){\n    ArraryList&lt;HeapError> list = new ArraryList();\n    while(true){\n      list.add(new HeapError());\n    }\n  }\n}\n在一个无限循环中，动态向ArrayList 中添加新的 HeapError 对象。这会不断的占用堆中的内存，当堆内存不够用时，必然会产生 OutOfMemeryError ，也就是内存溢出异常。\n总结对应 JVM 运行时内存分布，我们要记住，上面介绍的这 5 点都是在 Java 虚拟机规范中定义的规则，这些规则只是描述了各个区域做什么事情，存储什么样的数据，如何处理异常以及是否允许线程间共享等，不要理解成虚拟机的『具体实现』。\n虚拟机的具体实现又很多，比如Sun 公司的 HotSpot,JRocket,IBM J9 以及 Android Dalvik 和 ART 等。这些具体实现，在符合上面5中运行时数据区的前提下，又各自有不同的实现方式。\n\n总的来说，JVM 的运行时内存结构中一共有两个“栈”和一个“堆”，分别是：Java 虚拟机栈和本地方法栈，以及“GC堆”和方法区。除此之外还有一个程序计数器。 JVM 内存中只有堆和方法区是线程共享的数据区域，其它区域都是线程私有的。并且程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。\n","categories":["Android"],"tags":["Android","JVM"]},{"title":"Glide-4.11.0 浅析","url":"https://blog.onestravel.cn/20200403/5d609221eb6a/","content":"Glide-4.11.0 浅析Glide 是Google推荐使用的图片加载框架，在开发过程中我们也会经常使用到，使用起来也比较简单，一般一行代码就可以完成图片加载；如：\nGlide.with(mThumbIv).load(url).into(mThumbIv);\n今天我们来阅读一下Glide的源码，了解一下Glide 加载图标的原理，我们今天阅读的Glide源码是Glide:4.11.0版本的，是当前最新版本。源码获取地址为 https://github.com/bumptech/glide/releases/tag/v4.11.0。\n源码的阅读，是比较枯燥的；但是掌握了阅读代码的方法之后，一个人，一杯茶，一个电脑，也是一种特别的享受。\n开始阅读代码\n上面说了Glide加载的方法，一般使用时，在load之前，我们还会有其他的一些设置想，但是总体来说Glide加载图片就可以分为三步，第一步：with,第二步：load,第三步：into，接下来我们就从这三步来阅读代码\n1. withGlide.with(context) ;with是Glide类的静态方法，在 Glide类中有多个with方法的重载，代码如下：\n@NonNull\npublic static RequestManager with(@NonNull Context context) {\n  return getRetriever(context).get(context);\n}\n\n\n@NonNull\npublic static RequestManager with(@NonNull Activity activity) {\n  return getRetriever(activity).get(activity);\n}\n\n\n@NonNull\npublic static RequestManager with(@NonNull FragmentActivity activity) {\n  return getRetriever(activity).get(activity);\n}\n\n\n@NonNull\npublic static RequestManager with(@NonNull androidx.fragment.app.Fragment fragment) {\n  return getRetriever(fragment.getContext()).get(fragment);\n}\n\n\n@SuppressWarnings(\"deprecation\")\n@Deprecated\n@NonNull\npublic static RequestManager with(@NonNull android.app.Fragment fragment) {\n  return getRetriever(fragment.getActivity()).get(fragment);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull View view) {\n  return getRetriever(view.getContext()).get(view);\n}\n从上面代码中，我们可以看到，在调用Glide.with方法时，我们可以传入的参数有Context,Activity,FragmentActivity,androidx包下的Fragment和android包下的Fragment,View,无论传入什么参数，最终都调用了getRetriever().get()方法来返回了RequestManager对象;\n我们来看一下 getRetriever()方法的源码，\n@NonNull\nprivate static RequestManagerRetriever getRetriever(@Nullable Context context) {\n  // Context could be null for other reasons (ie the user passes in null), but in practice it will\n  // only occur due to errors with the Fragment lifecycle.\n  Preconditions.checkNotNull(\n      context,\n      \"You cannot start a load on a not yet attached View or a Fragment where getActivity() \"\n          + \"returns null (which usually occurs when getActivity() is called before the Fragment \"\n          + \"is attached or after the Fragment is destroyed).\");\n  return Glide.get(context).getRequestManagerRetriever();\n}\ngetRetriever()方法时通过调用Glide 类的get()方法来获取Glide的单例对象。然后通过初始化之后的Glide对象，获取RequestManagerRetriever对象；所以getRetriever()方法最终返回了一个RequestManagerRetriever对象。\nwith 方法中，在调用getRetriever()方法，拿到RequestManagerRetriever对象之后，调用了他的get()方法。传入了with方法传入的参数。我们来看一下RequestManagerRetriever对象中的get方法：\npublic RequestManagerRetriever(@Nullable RequestManagerFactory factory) {\n    this.factory = factory != null ? factory : DEFAULT_FACTORY;\n    handler = new Handler(Looper.getMainLooper(), this /* Callback */);\n  }\n\n  @NonNull\n  private RequestManager getApplicationManager(@NonNull Context context) {\n    // Either an application context or we're on a background thread.\n    if (applicationManager == null) {\n      synchronized (this) {\n        if (applicationManager == null) {\n          // Normally pause/resume is taken care of by the fragment we add to the fragment or\n          // activity. However, in this case since the manager attached to the application will not\n          // receive lifecycle events, we must force the manager to start resumed using\n          // ApplicationLifecycle.\n\n          // TODO(b/27524013): Factor out this Glide.get() call.\n          Glide glide = Glide.get(context.getApplicationContext());\n          applicationManager =\n              factory.build(\n                  glide,\n                  new ApplicationLifecycle(),\n                  new EmptyRequestManagerTreeNode(),\n                  context.getApplicationContext());\n        }\n      }\n    }\n    return applicationManager;\n  }\n\n  @NonNull\n  public RequestManager get(@NonNull Context context) {\n    if (context == null) {\n      throw new IllegalArgumentException(\"You cannot start a load on a null Context\");\n    } else if (Util.isOnMainThread() && !(context instanceof Application)) {\n      if (context instanceof FragmentActivity) {\n        return get((FragmentActivity) context);\n      } else if (context instanceof Activity) {\n        return get((Activity) context);\n      } else if (context instanceof ContextWrapper\n          // Only unwrap a ContextWrapper if the baseContext has a non-null application context.\n          // Context#createPackageContext may return a Context without an Application instance,\n          // in which case a ContextWrapper may be used to attach one.\n          && ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) {\n        return get(((ContextWrapper) context).getBaseContext());\n      }\n    }\n\n    return getApplicationManager(context);\n  }\n\n  @NonNull\n  public RequestManager get(@NonNull FragmentActivity activity) {\n    if (Util.isOnBackgroundThread()) {\n      return get(activity.getApplicationContext());\n    } else {\n      assertNotDestroyed(activity);\n      FragmentManager fm = activity.getSupportFragmentManager();\n      return supportFragmentGet(activity, fm, /*parentHint=*/ null, isActivityVisible(activity));\n    }\n  }\n\n  @NonNull\n  public RequestManager get(@NonNull Fragment fragment) {\n    Preconditions.checkNotNull(\n        fragment.getContext(),\n        \"You cannot start a load on a fragment before it is attached or after it is destroyed\");\n    if (Util.isOnBackgroundThread()) {\n      return get(fragment.getContext().getApplicationContext());\n    } else {\n      FragmentManager fm = fragment.getChildFragmentManager();\n      return supportFragmentGet(fragment.getContext(), fm, fragment, fragment.isVisible());\n    }\n  }\n\n  @SuppressWarnings(\"deprecation\")\n  @NonNull\n  public RequestManager get(@NonNull Activity activity) {\n    if (Util.isOnBackgroundThread()) {\n      return get(activity.getApplicationContext());\n    } else {\n      assertNotDestroyed(activity);\n      android.app.FragmentManager fm = activity.getFragmentManager();\n      return fragmentGet(activity, fm, /*parentHint=*/ null, isActivityVisible(activity));\n    }\n  }\n\n  @SuppressWarnings(\"deprecation\")\n  @NonNull\n  public RequestManager get(@NonNull View view) {\n    if (Util.isOnBackgroundThread()) {\n      return get(view.getContext().getApplicationContext());\n    }\n\n    Preconditions.checkNotNull(view);\n    Preconditions.checkNotNull(\n        view.getContext(), \"Unable to obtain a request manager for a view without a Context\");\n    Activity activity = findActivity(view.getContext());\n    // The view might be somewhere else, like a service.\n    if (activity == null) {\n      return get(view.getContext().getApplicationContext());\n    }\n\n    if (activity instanceof FragmentActivity) {\n      Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);\n      return fragment != null ? get(fragment) : get((FragmentActivity) activity);\n    }\n\n    // Standard Fragments.\n    android.app.Fragment fragment = findFragment(view, activity);\n    if (fragment == null) {\n      return get(activity);\n    }\n    return get(fragment);\n  }\n\n  private static void findAllSupportFragmentsWithViews(\n      @Nullable Collection topLevelFragments, @NonNull Map result) {\n    if (topLevelFragments == null) {\n      return;\n    }\n    for (Fragment fragment : topLevelFragments) {\n      // getFragment()s in the support FragmentManager may contain null values, see #1991.\n      if (fragment == null || fragment.getView() == null) {\n        continue;\n      }\n      result.put(fragment.getView(), fragment);\n      findAllSupportFragmentsWithViews(fragment.getChildFragmentManager().getFragments(), result);\n    }\n  }\n\n  @Nullable\n  private Fragment findSupportFragment(@NonNull View target, @NonNull FragmentActivity activity) {\n    tempViewToSupportFragment.clear();\n    findAllSupportFragmentsWithViews(\n        activity.getSupportFragmentManager().getFragments(), tempViewToSupportFragment);\n    Fragment result = null;\n    View activityRoot = activity.findViewById(android.R.id.content);\n    View current = target;\n    while (!current.equals(activityRoot)) {\n      result = tempViewToSupportFragment.get(current);\n      if (result != null) {\n        break;\n      }\n      if (current.getParent() instanceof View) {\n        current = (View) current.getParent();\n      } else {\n        break;\n      }\n    }\n\n    tempViewToSupportFragment.clear();\n    return result;\n  }\n\n  @SuppressWarnings({\"deprecation\", \"DeprecatedIsStillUsed\"})\n  @Deprecated\n  @Nullable\n  private android.app.Fragment findFragment(@NonNull View target, @NonNull Activity activity) {\n    tempViewToFragment.clear();\n    findAllFragmentsWithViews(activity.getFragmentManager(), tempViewToFragment);\n\n    android.app.Fragment result = null;\n\n    View activityRoot = activity.findViewById(android.R.id.content);\n    View current = target;\n    while (!current.equals(activityRoot)) {\n      result = tempViewToFragment.get(current);\n      if (result != null) {\n        break;\n      }\n      if (current.getParent() instanceof View) {\n        current = (View) current.getParent();\n      } else {\n        break;\n      }\n    }\n    tempViewToFragment.clear();\n    return result;\n  }\n\n  // TODO: Consider using an accessor class in the support library package to more directly retrieve\n  // non-support Fragments.\n  @SuppressWarnings(\"deprecation\")\n  @Deprecated\n  @TargetApi(Build.VERSION_CODES.O)\n  private void findAllFragmentsWithViews(\n      @NonNull android.app.FragmentManager fragmentManager,\n      @NonNull ArrayMap result) {\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n      for (android.app.Fragment fragment : fragmentManager.getFragments()) {\n        if (fragment.getView() != null) {\n          result.put(fragment.getView(), fragment);\n          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);\n        }\n      }\n    } else {\n      findAllFragmentsWithViewsPreO(fragmentManager, result);\n    }\n  }\n\n  @SuppressWarnings(\"deprecation\")\n  @Deprecated\n  private void findAllFragmentsWithViewsPreO(\n      @NonNull android.app.FragmentManager fragmentManager,\n      @NonNull ArrayMap result) {\n    int index = 0;\n    while (true) {\n      tempBundle.putInt(FRAGMENT_INDEX_KEY, index++);\n      android.app.Fragment fragment = null;\n      try {\n        fragment = fragmentManager.getFragment(tempBundle, FRAGMENT_INDEX_KEY);\n      } catch (Exception e) {\n        // This generates log spam from FragmentManager anyway.\n      }\n      if (fragment == null) {\n        break;\n      }\n      if (fragment.getView() != null) {\n        result.put(fragment.getView(), fragment);\n        if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR1) {\n          findAllFragmentsWithViews(fragment.getChildFragmentManager(), result);\n        }\n      }\n    }\n  }\n\n  @Nullable\n  private static Activity findActivity(@NonNull Context context) {\n    if (context instanceof Activity) {\n      return (Activity) context;\n    } else if (context instanceof ContextWrapper) {\n      return findActivity(((ContextWrapper) context).getBaseContext());\n    } else {\n      return null;\n    }\n  }\n\n  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)\n  private static void assertNotDestroyed(@NonNull Activity activity) {\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 && activity.isDestroyed()) {\n      throw new IllegalArgumentException(\"You cannot start a load for a destroyed activity\");\n    }\n  }\n\n  @SuppressWarnings(\"deprecation\")\n  @Deprecated\n  @NonNull\n  @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)\n  public RequestManager get(@NonNull android.app.Fragment fragment) {\n    if (fragment.getActivity() == null) {\n      throw new IllegalArgumentException(\n          \"You cannot start a load on a fragment before it is attached\");\n    }\n    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\n      return get(fragment.getActivity().getApplicationContext());\n    } else {\n      android.app.FragmentManager fm = fragment.getChildFragmentManager();\n      return fragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());\n    }\n  }\n\n  @SuppressWarnings(\"deprecation\")\n  @Deprecated\n  @NonNull\n  RequestManagerFragment getRequestManagerFragment(Activity activity) {\n    return getRequestManagerFragment(\n        activity.getFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));\n  }\n\n  @SuppressWarnings(\"deprecation\")\n  @NonNull\n  private RequestManagerFragment getRequestManagerFragment(\n      @NonNull final android.app.FragmentManager fm,\n      @Nullable android.app.Fragment parentHint,\n      boolean isParentVisible) {\n    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);\n    if (current == null) {\n      current = pendingRequestManagerFragments.get(fm);\n      if (current == null) {\n        current = new RequestManagerFragment();\n        current.setParentFragmentHint(parentHint);\n        if (isParentVisible) {\n          current.getGlideLifecycle().onStart();\n        }\n        pendingRequestManagerFragments.put(fm, current);\n        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n        handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();\n      }\n    }\n    return current;\n  }\n\n  @SuppressWarnings({\"deprecation\", \"DeprecatedIsStillUsed\"})\n  @Deprecated\n  @NonNull\n  private RequestManager fragmentGet(\n      @NonNull Context context,\n      @NonNull android.app.FragmentManager fm,\n      @Nullable android.app.Fragment parentHint,\n      boolean isParentVisible) {\n    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);\n    RequestManager requestManager = current.getRequestManager();\n    if (requestManager == null) {\n      // TODO(b/27524013): Factor out this Glide.get() call.\n      Glide glide = Glide.get(context);\n      requestManager =\n          factory.build(\n              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);\n      current.setRequestManager(requestManager);\n    }\n    return requestManager;\n  }\n\n  @NonNull\n  SupportRequestManagerFragment getSupportRequestManagerFragment(\n      Context context, FragmentManager fragmentManager) {\n    return getSupportRequestManagerFragment(\n        fragmentManager, /*parentHint=*/ null, isActivityVisible(context));\n  }\n\n  private static boolean isActivityVisible(Context context) {\n    // This is a poor heuristic, but it's about all we have. We'd rather err on the side of visible\n    // and start requests than on the side of invisible and ignore valid requests.\n    Activity activity = findActivity(context);\n    return activity == null || !activity.isFinishing();\n  }\n\n  @NonNull\n  private SupportRequestManagerFragment getSupportRequestManagerFragment(\n      @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) {\n    SupportRequestManagerFragment current =\n        (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);\n    if (current == null) {\n      current = pendingSupportRequestManagerFragments.get(fm);\n      if (current == null) {\n        current = new SupportRequestManagerFragment();\n        current.setParentFragmentHint(parentHint);\n        if (isParentVisible) {\n          current.getGlideLifecycle().onStart();\n        }\n        pendingSupportRequestManagerFragments.put(fm, current);\n        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n        handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();\n      }\n    }\n    return current;\n  }\n\n  @NonNull\n  private RequestManager supportFragmentGet(\n      @NonNull Context context,\n      @NonNull FragmentManager fm,\n      @Nullable Fragment parentHint,\n      boolean isParentVisible) {\n    SupportRequestManagerFragment current =\n        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);\n    RequestManager requestManager = current.getRequestManager();\n    if (requestManager == null) {\n      // TODO(b/27524013): Factor out this Glide.get() call.\n      Glide glide = Glide.get(context);\n      requestManager =\n          factory.build(\n              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);\n      current.setRequestManager(requestManager);\n    }\n    return requestManager;\n  }\n\n  @Override\n  public boolean handleMessage(Message message) {\n    boolean handled = true;\n    Object removed = null;\n    Object key = null;\n    switch (message.what) {\n      case ID_REMOVE_FRAGMENT_MANAGER:\n        android.app.FragmentManager fm = (android.app.FragmentManager) message.obj;\n        key = fm;\n        removed = pendingRequestManagerFragments.remove(fm);\n        break;\n      case ID_REMOVE_SUPPORT_FRAGMENT_MANAGER:\n        FragmentManager supportFm = (FragmentManager) message.obj;\n        key = supportFm;\n        removed = pendingSupportRequestManagerFragments.remove(supportFm);\n        break;\n      default:\n        handled = false;\n        break;\n    }\n    if (handled && removed == null && Log.isLoggable(TAG, Log.WARN)) {\n      Log.w(TAG, \"Failed to remove expected request manager fragment, manager: \" + key);\n    }\n    return handled;\n  }\n\n  /** Used internally to create {@link RequestManager}s. */\n  public interface RequestManagerFactory {\n    @NonNull\n    RequestManager build(\n        @NonNull Glide glide,\n        @NonNull Lifecycle lifecycle,\n        @NonNull RequestManagerTreeNode requestManagerTreeNode,\n        @NonNull Context context);\n  }\n\n  private static final RequestManagerFactory DEFAULT_FACTORY =\n      new RequestManagerFactory() {\n        @NonNull\n        @Override\n        public RequestManager build(\n            @NonNull Glide glide,\n            @NonNull Lifecycle lifecycle,\n            @NonNull RequestManagerTreeNode requestManagerTreeNode,\n            @NonNull Context context) {\n          return new RequestManager(glide, lifecycle, requestManagerTreeNode, context);\n        }\n      };\n}\n\n从第33行，我们可以看到，在该get()方法中，根据Context类型，整体分为两类，一类是非Application的Context，一类是Application的Context，Application的Context，直接执行第7行getApplicationManager(context)方法，来创建和Application同生命周期的RequestManager对象；当应用关闭后，Glide也就停止加载；\n传入非Application的Context，无论实Activity,Fragment,最终都是根据是否是FragmentActivity的子类或者Activity的子类来创建一个隐藏的SupportRequestManagerFragment  或 RequestManagerFragment对象（第302行和第356行），该对象继承自Fragment；来实现对应的Activity的生命周期的控制；当该Activity销毁时，对应的Glide也停止加载。\n总体来说：with方法就是创建一个RequestManager 对象，然后根据传入的context来控制图片加载的生命周期\n2. load接下来我们来看load方法，在上一步中，我们通过with方法，获取到了RequestManager 对象；那么load方法，就在RequestManager类中，我们来看一下RequestManager类\n  @NonNull\n  @CheckResult\n  public RequestBuilder&lt;Bitmap> asBitmap() {\n    return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);\n  }\n\n  @NonNull\n  @CheckResult\n  public RequestBuilder&lt;GifDrawable> asGif() {\n    return as(GifDrawable.class).apply(DECODE_TYPE_GIF);\n  }\n\n  @NonNull\n  @CheckResult\n  public RequestBuilder&lt;Drawable> asDrawable() {\n    return as(Drawable.class);\n  }\n\n  @NonNull\n  @CheckResult\n  @Override\n  public RequestBuilder&lt;Drawable> load(@Nullable Bitmap bitmap) {\n    return asDrawable().load(bitmap);\n  }\n\n\n  @NonNull\n  @CheckResult\n  @Override\n  public RequestBuilder&lt;Drawable> load(@Nullable Drawable drawable) {\n    return asDrawable().load(drawable);\n  }\n\n  @NonNull\n  @CheckResult\n  @Override\n  public RequestBuilder&lt;Drawable> load(@Nullable String string) {\n    return asDrawable().load(string);\n  }\n\n\n  @NonNull\n  @CheckResult\n  @Override\n  public RequestBuilder&lt;Drawable> load(@Nullable Uri uri) {\n    return asDrawable().load(uri);\n  }\n\n  @NonNull\n  @CheckResult\n  @Override\n  public RequestBuilder&lt;Drawable> load(@Nullable File file) {\n    return asDrawable().load(file);\n  }\n\n\n  @SuppressWarnings(\"deprecation\")\n  @NonNull\n  @CheckResult\n  @Override\n  public RequestBuilder&lt;Drawable> load(@RawRes @DrawableRes @Nullable Integer resourceId) {\n    return asDrawable().load(resourceId);\n  }\n\n\n  @SuppressWarnings(\"deprecation\")\n  @CheckResult\n  @Override\n  @Deprecated\n  public RequestBuilder&lt;Drawable> load(@Nullable URL url) {\n    return asDrawable().load(url);\n  }\n\n\n  @NonNull\n  @CheckResult\n  @Override\n  public RequestBuilder&lt;Drawable> load(@Nullable byte[] model) {\n    return asDrawable().load(model);\n  }\n\n\n  @NonNull\n  @CheckResult\n  @Override\n  public RequestBuilder&lt;Drawable> load(@Nullable Object model) {\n    return asDrawable().load(model);\n  }\n\n  @NonNull\n  @CheckResult\n  public RequestBuilder&lt;File> downloadOnly() {\n    return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);\n  }\n\n\n  @NonNull\n  @CheckResult\n  public RequestBuilder&lt;File> download(@Nullable Object model) {\n    return downloadOnly().load(model);\n  }\n\n  @NonNull\n  @CheckResult\n  public RequestBuilder&lt;File> asFile() {\n    return as(File.class).apply(skipMemoryCacheOf(true));\n  }\n\n  @NonNull\n  @CheckResult\n  public &lt;ResourceType> RequestBuilder&lt;ResourceType> as(\n      @NonNull Class&lt;ResourceType> resourceClass) {\n    return new RequestBuilder&lt;>(glide, this, resourceClass, context);\n  }\n\n在RequestManager类中，我们可以看到有很多load方法的重载方法，可以传入不同的图片资源来加载图片资源；在load方法中我们可以看到都是调用了asDrawable()方法返回一个RequestBuilder&lt;Drawable&gt;对象，再调用RequestBuilder&lt;Drawable&gt;对象中的load方法，传入对应的图片资源或地址，进行加载图片；我们来看一下asDrawable() 方法,在第15行，看到asDrawable() 方法中调用了as()方法（第111行）生成了RequestBuilder&lt;Drawable&gt;对象  ，传入了glide对象，当前的   RequestManager 对象，泛型的具体类，和context；  除了asDrawable() 方法，还有三个方法asGif()，asBitmap()和asFile()也调用了as()方法生成了对应类型的RequestBuilder对象。\n可以看到，最终是将图片资源传入到了RequestBuilder&lt;TranscodeType&gt;类中的load方法中，接下来我们看一下RequestBuilder&lt;TranscodeType&gt;类中的load方法:\n public RequestBuilder load(@Nullable Bitmap bitmap) {\n    return loadGeneric(bitmap).apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));\n  }\n\n  public RequestBuilder load(@Nullable Drawable drawable) {\n    return loadGeneric(drawable).apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));\n  }\n\n  public RequestBuilder load(@Nullable String string) {\n    return loadGeneric(string);\n  }\n\n  public RequestBuilder load(@Nullable Uri uri) {\n    return loadGeneric(uri);\n  }\n\n  public RequestBuilder load(@Nullable File file) {\n    return loadGeneric(file);\n  }\n\n  public RequestBuilder load(@RawRes @DrawableRes @Nullable Integer resourceId) {\n    return loadGeneric(resourceId).apply(signatureOf(AndroidResourceSignature.obtain(context)));\n  }\n\n\n  public RequestBuilder load(@Nullable URL url) {\n    return loadGeneric(url);\n  }\n\n\n  public RequestBuilder load(@Nullable byte[] model) {\n    RequestBuilder result = loadGeneric(model);\n    if (!result.isDiskCacheStrategySet()) {\n      result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));\n    }\n    if (!result.isSkipMemoryCacheSet()) {\n      result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));\n    }\n    return result;\n  }\n\npublic RequestBuilder load(@Nullable Object model) {\n  return loadGeneric(model);\n}\n\n@NonNull\nprivate RequestBuilder loadGeneric(@Nullable Object model) {\n  this.model = model;\n  isModelSet = true;\n  return this;\n}\n可以看到在load方法中都调用了该类中的loadGeneric方法，传入了Object类型的model参数，这个model参数就是我吗传入的图片资源或者图片地址；看到这里，我们是不是有点疑惑，在load方法中调用了loadGeneric方法赋值后，返回RequestBuilder&lt;TranscodeType&gt;对象，Glide的load方法到这里就结束了他的工作。\n3. into在上面的with和load方法中，我们还没有看到真正的图片加载和显示的代码，所以，可以想到，图片的加载和显示，都是通过into方法来调用执行的，所以，into方法是相对比较难分析的一个方法；接下来我们就一起看一下into方法所承担的重要职责。\n执行完load方法，我们获得了RequestBuilder&lt;TranscodeType&gt;对象，所以，into方法，就在RequestBuilder&lt;TranscodeType&gt;类中，我们一起看一张这个类：\npublic class RequestBuilder extends BaseRequestOptions<RequestBuilder>\n    implements Cloneable, ModelTypes<RequestBuilder> {\n\n@NonNull\npublic <Y extends Target> Y into(@NonNull Y target) {\n  return into(target, /*targetListener=*/ null, Executors.mainThreadExecutor());\n}\n\n@NonNull\n@Synthetic\n<Y extends Target> Y into(\n    @NonNull Y target,\n    @Nullable RequestListener targetListener,\n    Executor callbackExecutor) {\n  return into(target, targetListener, /*options=*/ this, callbackExecutor);\n}\n\nprivate <Y extends Target> Y into(\n    @NonNull Y target,\n    @Nullable RequestListener targetListener,\n    BaseRequestOptions options,\n    Executor callbackExecutor) {\n  Preconditions.checkNotNull(target);\n  if (!isModelSet) {\n    throw new IllegalArgumentException(\"You must call #load() before calling #into()\");\n  }\n\n  Request request = buildRequest(target, targetListener, options, callbackExecutor);\n\n  Request previous = target.getRequest();\n  if (request.isEquivalentTo(previous)\n      && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {\n    if (!Preconditions.checkNotNull(previous).isRunning()) {\n      previous.begin();\n    }\n    return target;\n  }\n\n  requestManager.clear(target);\n  target.setRequest(request);\n  requestManager.track(target, request);\n\n  return target;\n}\n\n\nprivate boolean isSkipMemoryCacheWithCompletePreviousRequest(\n    BaseRequestOptions options, Request previous) {\n  return !options.isMemoryCacheable() && previous.isComplete();\n}\n\n@NonNull\npublic ViewTarget into(@NonNull ImageView view) {\n  Util.assertMainThread();\n  Preconditions.checkNotNull(view);\n\n  BaseRequestOptions requestOptions = this;\n  if (!requestOptions.isTransformationSet()\n      && requestOptions.isTransformationAllowed()\n      && view.getScaleType() != null) {\n    switch (view.getScaleType()) {\n      case CENTER_CROP:\n        requestOptions = requestOptions.clone().optionalCenterCrop();\n        break;\n      case CENTER_INSIDE:\n        requestOptions = requestOptions.clone().optionalCenterInside();\n        break;\n      case FIT_CENTER:\n      case FIT_START:\n      case FIT_END:\n        requestOptions = requestOptions.clone().optionalFitCenter();\n        break;\n      case FIT_XY:\n        requestOptions = requestOptions.clone().optionalCenterInside();\n        break;\n      case CENTER:\n      case MATRIX:\n      default:\n        // Do nothing.\n    }\n  }\n\n  return into(\n      glideContext.buildImageViewTarget(view, transcodeClass),\n      /*targetListener=*/ null,\n      requestOptions,\n      Executors.mainThreadExecutor());\n}\n\n\n@Deprecated\npublic FutureTarget into(int width, int height) {\n  return submit(width, height);\n}\n\n\n@NonNull\npublic FutureTarget submit() {\n  return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);\n}\n\n\n@NonNull\npublic FutureTarget submit(int width, int height) {\n  final RequestFutureTarget target = new RequestFutureTarget<>(width, height);\n  return into(target, target, Executors.directExecutor());\n}\n\n\n@NonNull\npublic Target preload(int width, int height) {\n  final PreloadTarget target = PreloadTarget.obtain(requestManager, width, height);\n  return into(target);\n}\n\n\n@NonNull\npublic Target preload() {\n  return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);\n}\n}\n可以看到，我们调用的into方法，是第53行参数为ImageView的方法，在这个方法中根据apply方法中传的RequestOptions对象和图片显示类型scaleType来设置RequestOptions对象（当前对象，RequestBuilder 继承自BaseRequestOptions）的Transform类型。并且通过glideContext.buildImageViewTarget(view, transcodeClass)来创建了一个ViewTarget&lt;ImageView, X&gt;对象（BitmapImageViewTarget(view)或DrawableImageViewTarget(view)）,然后将ViewTarget&lt;ImageView, X&gt;对象，RequestOptions对象和Executors.mainThreadExecutor()（主线程的一个线程执行器，内部有一个主线程的handler对象用了执行runnable对象）传入到第18行的into方法，接下来我们看一下，在这个into方法中做了什么操作。\n在第28行可以看到通过buildRequest(target, targetListener, options, callbackExecutor)方法得到了一个Request对象 request,稍后来看这个方法。继续往下看，第30行，通过传入的target.getRequest()方法也获得了一个Request对象 previous然后判断这两个Request对象是否是同一个请求（判断请求的参数和资源地址），如果是同一个请求，并且未跳过内存缓存完成请求，则target的Request对象开始请求previous.begin();\n如果两个Request对象不满足上面的条件，则将该request对象设置给target的Request对象，并且将该request对象通过RequestManager对象的track(target, request)方法，将该request对象添加到请求追踪器RequestTracker对象中进行请求（runRequest(Request request)）；粘一下代码\n\nRequestManager对象的track(target, request)方法\n\nsynchronized void track(@NonNull Target&lt;?> target, @NonNull Request request) {\n  targetTracker.track(target);\n  requestTracker.runRequest(request);\n}\n\nRequestTracker对象中的runRequest(Request request)方法\n\npublic void runRequest(@NonNull Request request) {\n  requests.add(request);\n  if (!isPaused) {\n    request.begin();\n  } else {\n    request.clear();\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      Log.v(TAG, \"Paused, delaying request\");\n    }\n    pendingRequests.add(request);\n  }\n}\n可以看到在runRequest(Request request)方法中，先将该请求添加到请求的集合中，并且判断当前是否处于暂停加载的状态，如果不处于暂停加载状态，则执行请求对象的begin()方法开始请求图片，如果处于暂停加载状态，则清除加载列表，并将该请求加入等待请求的队列，待下次重新开始请求时进行请求。\n接下来我们来了解一下buildRequest方法的内容\nprivate Request buildRequest(\n    Target&lt;TranscodeType> target,\n    @Nullable RequestListener&lt;TranscodeType> targetListener,\n    BaseRequestOptions&lt;?> requestOptions,\n    Executor callbackExecutor) {\n  return buildRequestRecursive(\n      /*requestLock=*/ new Object(),\n      target,\n      targetListener,\n      /*parentCoordinator=*/ null,\n      transitionOptions,\n      requestOptions.getPriority(),\n      requestOptions.getOverrideWidth(),\n      requestOptions.getOverrideHeight(),\n      requestOptions,\n      callbackExecutor);\n}\n\nprivate Request buildRequestRecursive(\n    Object requestLock,\n    Target&lt;TranscodeType> target,\n    @Nullable RequestListener&lt;TranscodeType> targetListener,\n    @Nullable RequestCoordinator parentCoordinator,\n    TransitionOptions&lt;?, ? super TranscodeType> transitionOptions,\n    Priority priority,\n    int overrideWidth,\n    int overrideHeight,\n    BaseRequestOptions&lt;?> requestOptions,\n    Executor callbackExecutor) {\n\n  // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator.\n  ErrorRequestCoordinator errorRequestCoordinator = null;\n  if (errorBuilder != null) {\n    errorRequestCoordinator = new ErrorRequestCoordinator(requestLock, parentCoordinator);\n    parentCoordinator = errorRequestCoordinator;\n  }\n\n  Request mainRequest =\n      buildThumbnailRequestRecursive(\n          requestLock,\n          target,\n          targetListener,\n          parentCoordinator,\n          transitionOptions,\n          priority,\n          overrideWidth,\n          overrideHeight,\n          requestOptions,\n          callbackExecutor);\n\n  if (errorRequestCoordinator == null) {\n    return mainRequest;\n  }\n\n  int errorOverrideWidth = errorBuilder.getOverrideWidth();\n  int errorOverrideHeight = errorBuilder.getOverrideHeight();\n  if (Util.isValidDimensions(overrideWidth, overrideHeight) &amp;&amp; !errorBuilder.isValidOverride()) {\n    errorOverrideWidth = requestOptions.getOverrideWidth();\n    errorOverrideHeight = requestOptions.getOverrideHeight();\n  }\n\n  Request errorRequest =\n      errorBuilder.buildRequestRecursive(\n          requestLock,\n          target,\n          targetListener,\n          errorRequestCoordinator,\n          errorBuilder.transitionOptions,\n          errorBuilder.getPriority(),\n          errorOverrideWidth,\n          errorOverrideHeight,\n          errorBuilder,\n          callbackExecutor);\n  errorRequestCoordinator.setRequests(mainRequest, errorRequest);\n  return errorRequestCoordinator;\n}\n\nprivate Request buildThumbnailRequestRecursive(\n    Object requestLock,\n    Target&lt;TranscodeType> target,\n    RequestListener&lt;TranscodeType> targetListener,\n    @Nullable RequestCoordinator parentCoordinator,\n    TransitionOptions&lt;?, ? super TranscodeType> transitionOptions,\n    Priority priority,\n    int overrideWidth,\n    int overrideHeight,\n    BaseRequestOptions&lt;?> requestOptions,\n    Executor callbackExecutor) {\n  if (thumbnailBuilder != null) {\n    // Recursive case: contains a potentially recursive thumbnail request builder.\n    if (isThumbnailBuilt) {\n      throw new IllegalStateException(\n          \"You cannot use a request as both the main request and a \"\n              + \"thumbnail, consider using clone() on the request(s) passed to thumbnail()\");\n    }\n\n    TransitionOptions&lt;?, ? super TranscodeType> thumbTransitionOptions =\n        thumbnailBuilder.transitionOptions;\n\n    // Apply our transition by default to thumbnail requests but avoid overriding custom options\n    // that may have been applied on the thumbnail request explicitly.\n    if (thumbnailBuilder.isDefaultTransitionOptionsSet) {\n      thumbTransitionOptions = transitionOptions;\n    }\n\n    Priority thumbPriority =\n        thumbnailBuilder.isPrioritySet()\n            ? thumbnailBuilder.getPriority()\n            : getThumbnailPriority(priority);\n\n    int thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();\n    int thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();\n    if (Util.isValidDimensions(overrideWidth, overrideHeight)\n        &amp;&amp; !thumbnailBuilder.isValidOverride()) {\n      thumbOverrideWidth = requestOptions.getOverrideWidth();\n      thumbOverrideHeight = requestOptions.getOverrideHeight();\n    }\n\n    ThumbnailRequestCoordinator coordinator =\n        new ThumbnailRequestCoordinator(requestLock, parentCoordinator);\n    Request fullRequest =\n        obtainRequest(\n            requestLock,\n            target,\n            targetListener,\n            requestOptions,\n            coordinator,\n            transitionOptions,\n            priority,\n            overrideWidth,\n            overrideHeight,\n            callbackExecutor);\n    isThumbnailBuilt = true;\n    // Recursively generate thumbnail requests.\n    Request thumbRequest =\n        thumbnailBuilder.buildRequestRecursive(\n            requestLock,\n            target,\n            targetListener,\n            coordinator,\n            thumbTransitionOptions,\n            thumbPriority,\n            thumbOverrideWidth,\n            thumbOverrideHeight,\n            thumbnailBuilder,\n            callbackExecutor);\n    isThumbnailBuilt = false;\n    coordinator.setRequests(fullRequest, thumbRequest);\n    return coordinator;\n  } else if (thumbSizeMultiplier != null) {\n    // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.\n    ThumbnailRequestCoordinator coordinator =\n        new ThumbnailRequestCoordinator(requestLock, parentCoordinator);\n    Request fullRequest =\n        obtainRequest(\n            requestLock,\n            target,\n            targetListener,\n            requestOptions,\n            coordinator,\n            transitionOptions,\n            priority,\n            overrideWidth,\n            overrideHeight,\n            callbackExecutor);\n    BaseRequestOptions&lt;?> thumbnailOptions =\n        requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);\n\n    Request thumbnailRequest =\n        obtainRequest(\n            requestLock,\n            target,\n            targetListener,\n            thumbnailOptions,\n            coordinator,\n            transitionOptions,\n            getThumbnailPriority(priority),\n            overrideWidth,\n            overrideHeight,\n            callbackExecutor);\n\n    coordinator.setRequests(fullRequest, thumbnailRequest);\n    return coordinator;\n  } else {\n    // Base case: no thumbnail.\n    return obtainRequest(\n        requestLock,\n        target,\n        targetListener,\n        requestOptions,\n        parentCoordinator,\n        transitionOptions,\n        priority,\n        overrideWidth,\n        overrideHeight,\n        callbackExecutor);\n  }\n}\n\nprivate Request obtainRequest(\n    Object requestLock,\n    Target&lt;TranscodeType> target,\n    RequestListener&lt;TranscodeType> targetListener,\n    BaseRequestOptions&lt;?> requestOptions,\n    RequestCoordinator requestCoordinator,\n    TransitionOptions&lt;?, ? super TranscodeType> transitionOptions,\n    Priority priority,\n    int overrideWidth,\n    int overrideHeight,\n    Executor callbackExecutor) {\n  return SingleRequest.obtain(\n      context,\n      glideContext,\n      requestLock,\n      model,\n      transcodeClass,\n      requestOptions,\n      overrideWidth,\n      overrideHeight,\n      priority,\n      target,\n      targetListener,\n      requestListeners,\n      requestCoordinator,\n      glideContext.getEngine(),\n      transitionOptions.getTransitionFactory(),\n      callbackExecutor);\n}\n可以看到在第1行buildRequest()方法中调用了buildRequestRecursive方法（第19行），在该方法中，根据在RequestBuilder类对象中设置的errorBuilder（类型为RequestBuilder）来创建不同的Request对象，buildThumbnailRequestRecursive方法中判断是否存在缩略图来创建不同的Request对象（创建一个拥有请求原图的Request对象和请求缩略图的Request对象的ThumbnailRequestCoordinator对象，或者只有单个请求的SingleRequest对象），最终都是执行了Request对象的begin()方法取请求图片资源；在上面的方法中可以看到，多次执行之后，最终大部分都Request对象中包含了SingleRequest对象，其中的begin()方法也是调用了SingleRequest对象中的begin()方法，接下来我们来看一下SingleRequest对象中的begin()方法；分析到现在为止，我们还没有看到请求图片资源的代码，所以猜想SingleRequest对象中的begin()方法接下来应该就是调起网络请求的方法。\n@Override\npublic void begin() {\n  synchronized (requestLock) {\n    assertNotCallingCallbacks();\n    stateVerifier.throwIfRecycled();\n    startTime = LogTime.getLogTime();\n    if (model == null) {\n      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n        width = overrideWidth;\n        height = overrideHeight;\n      }\n      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;\n      onLoadFailed(new GlideException(\"Received null model\"), logLevel);\n      return;\n    }\n\n    if (status == Status.RUNNING) {\n      throw new IllegalArgumentException(\"Cannot restart a running request\");\n    }\n\n    if (status == Status.COMPLETE) {\n      onResourceReady(resource, DataSource.MEMORY_CACHE);\n      return;\n    }\n\n    status = Status.WAITING_FOR_SIZE;\n    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n      onSizeReady(overrideWidth, overrideHeight);\n    } else {\n      target.getSize(this);\n    }\n\n    if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)\n        &amp;&amp; canNotifyStatusChanged()) {\n      target.onLoadStarted(getPlaceholderDrawable());\n    }\n    if (IS_VERBOSE_LOGGABLE) {\n      logV(\"finished run method in \" + LogTime.getElapsedMillis(startTime));\n    }\n  }\n}\n private void onLoadFailed(GlideException e, int maxLogLevel) {\n    stateVerifier.throwIfRecycled();\n    synchronized (requestLock) {\n      e.setOrigin(requestOrigin);\n      int logLevel = glideContext.getLogLevel();\n      if (logLevel &lt;= maxLogLevel) {\n        Log.w(\n            GLIDE_TAG, \"Load failed for \" + model + \" with size [\" + width + \"x\" + height + \"]\", e);\n        if (logLevel &lt;= Log.INFO) {\n          e.logRootCauses(GLIDE_TAG);\n        }\n      }\n\n      loadStatus = null;\n      status = Status.FAILED;\n\n      isCallingCallbacks = true;\n      try {\n        // TODO: what if this is a thumbnail request?\n        boolean anyListenerHandledUpdatingTarget = false;\n        if (requestListeners != null) {\n          for (RequestListener&lt;R> listener : requestListeners) {\n            anyListenerHandledUpdatingTarget |=\n                listener.onLoadFailed(e, model, target, isFirstReadyResource());\n          }\n        }\n        anyListenerHandledUpdatingTarget |=\n            targetListener != null\n                &amp;&amp; targetListener.onLoadFailed(e, model, target, isFirstReadyResource());\n\n        if (!anyListenerHandledUpdatingTarget) {\n          setErrorPlaceholder();\n        }\n      } finally {\n        isCallingCallbacks = false;\n      }\n\n      notifyLoadFailed();\n    }\n  }\n\n private void setErrorPlaceholder() {\n    if (!canNotifyStatusChanged()) {\n      return;\n    }\n\n    Drawable error = null;\n    if (model == null) {\n      error = getFallbackDrawable();\n    }\n    // Either the model isn't null, or there was no fallback drawable set.\n    if (error == null) {\n      error = getErrorDrawable();\n    }\n    // The model isn't null, no fallback drawable was set or no error drawable was set.\n    if (error == null) {\n      error = getPlaceholderDrawable();\n    }\n    target.onLoadFailed(error);\n  }\n可以看到在这个方法里，stateVerifier.throwIfRecycled(),中判断了生命周期，如果没销毁，则抛出异常。\n然后判断了model == null，这里的model就是我们之前传入的图片资源（图片地址），为空的时候，则不需要加载，直接执行onLoadFailed方法，在onLoadFailed方法中则是判断加载的监听器是否处理了onLoadFailed事件，如果没有处理，则设置加载错误的占位图片（第73行），最终则执行target的target.onLoadFailed(error);回调方法将错误占位图显示出来\n当model不为空，继续向下执行，判断了当前状态是否在运行中(第17行)，如果是，抛出异常，如果不是，继续判读状态是否已完成，如果已完成，则执行onResourceReady回调方法（第22行），这个方法我们稍后在看，如果状态不是已完成状态，则继续向下执行，判断宽度和高度是否有效（&gt;0或者为自适应），如果有效执行onSizeReady方法，如果无效，则执行target.getSize(this);方法，重新获取宽度和高度，target.getSize(this)是ViewTarget中的方法，在该方法中获取了当前target的宽度和高度，获取有效宽度和高度之后，回调继续执行onSizeReady方法。这里的cb就是在target.getSize(this);方法中传递过来的this，也就是SingleRequest类对象\n\ntarget.getSize(this) 方法\n\nvoid getSize(@NonNull SizeReadyCallback cb) {\n  int currentWidth = getTargetWidth();\n  int currentHeight = getTargetHeight();\n  if (isViewStateAndSizeValid(currentWidth, currentHeight)) {\n    cb.onSizeReady(currentWidth, currentHeight);\n    return;\n  }\n\n  // We want to notify callbacks in the order they were added and we only expect one or two\n  // callbacks to be added a time, so a List is a reasonable choice.\n  if (!cbs.contains(cb)) {\n    cbs.add(cb);\n  }\n  if (layoutListener == null) {\n    ViewTreeObserver observer = view.getViewTreeObserver();\n    layoutListener = new SizeDeterminerLayoutListener(this);\n    observer.addOnPreDrawListener(layoutListener);\n  }\n}\n可以看到target.getSize(this)最终还是执行了onSizeReady方法，接下来我们看一下在onSizeReady方法中做了什么\n\nSingleRequest类对象中的onSizeReady方法\n\npublic void onSizeReady(int width, int height) {\n  stateVerifier.throwIfRecycled();\n  synchronized (requestLock) {\n    if (IS_VERBOSE_LOGGABLE) {\n      logV(\"Got onSizeReady in \" + LogTime.getElapsedMillis(startTime));\n    }\n    if (status != Status.WAITING_FOR_SIZE) {\n      return;\n    }\n    status = Status.RUNNING;\n\n    float sizeMultiplier = requestOptions.getSizeMultiplier();\n    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);\n    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);\n\n    if (IS_VERBOSE_LOGGABLE) {\n      logV(\"finished setup for calling load in \" + LogTime.getElapsedMillis(startTime));\n    }\n    loadStatus =\n        engine.load(\n            glideContext,\n            model,\n            requestOptions.getSignature(),\n            this.width,\n            this.height,\n            requestOptions.getResourceClass(),\n            transcodeClass,\n            priority,\n            requestOptions.getDiskCacheStrategy(),\n            requestOptions.getTransformations(),\n            requestOptions.isTransformationRequired(),\n            requestOptions.isScaleOnlyOrNoTransform(),\n            requestOptions.getOptions(),\n            requestOptions.isMemoryCacheable(),\n            requestOptions.getUseUnlimitedSourceGeneratorsPool(),\n            requestOptions.getUseAnimationPool(),\n            requestOptions.getOnlyRetrieveFromCache(),\n            this,\n            callbackExecutor);\n\n    // This is a hack that's only useful for testing right now where loads complete synchronously\n    // even though under any executor running on any thread but the main thread, the load would\n    // have completed asynchronously.\n    if (status != Status.RUNNING) {\n      loadStatus = null;\n    }\n    if (IS_VERBOSE_LOGGABLE) {\n      logV(\"finished onSizeReady in \" + LogTime.getElapsedMillis(startTime));\n    }\n  }\n}\n可以看到，在第20行，调用了engine.load方法，传入了很多的参数，大部分都是根图片相关的倒数第二款参数this，可前面一样，也是ResourceCallback类型的，用于回调；接下来进入到engine.load方法看一下\npublic &lt;R> LoadStatus load(\n    GlideContext glideContext,\n    Object model,\n    Key signature,\n    int width,\n    int height,\n    Class&lt;?> resourceClass,\n    Class&lt;R> transcodeClass,\n    Priority priority,\n    DiskCacheStrategy diskCacheStrategy,\n    Map&lt;Class&lt;?>, Transformation&lt;?>> transformations,\n    boolean isTransformationRequired,\n    boolean isScaleOnlyOrNoTransform,\n    Options options,\n    boolean isMemoryCacheable,\n    boolean useUnlimitedSourceExecutorPool,\n    boolean useAnimationPool,\n    boolean onlyRetrieveFromCache,\n    ResourceCallback cb,\n    Executor callbackExecutor) {\n  long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;\n\n  EngineKey key =\n      keyFactory.buildKey(\n          model,\n          signature,\n          width,\n          height,\n          transformations,\n          resourceClass,\n          transcodeClass,\n          options);\n\n  EngineResource&lt;?> memoryResource;\n  synchronized (this) {\n    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);\n\n    if (memoryResource == null) {\n      return waitForExistingOrStartNewJob(\n          glideContext,\n          model,\n          signature,\n          width,\n          height,\n          resourceClass,\n          transcodeClass,\n          priority,\n          diskCacheStrategy,\n          transformations,\n          isTransformationRequired,\n          isScaleOnlyOrNoTransform,\n          options,\n          isMemoryCacheable,\n          useUnlimitedSourceExecutorPool,\n          useAnimationPool,\n          onlyRetrieveFromCache,\n          cb,\n          callbackExecutor,\n          key,\n          startTime);\n    }\n  }\n\n  // Avoid calling back while holding the engine lock, doing so makes it easier for callers to\n  // deadlock.\n  cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE);\n  return null;\n}\nprivate EngineResource&lt;?> loadFromMemory(\n      EngineKey key, boolean isMemoryCacheable, long startTime) {\n    if (!isMemoryCacheable) {\n      return null;\n    }\n\n    EngineResource&lt;?> active = loadFromActiveResources(key);\n    if (active != null) {\n      if (VERBOSE_IS_LOGGABLE) {\n        logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n      }\n      return active;\n    }\n\n    EngineResource&lt;?> cached = loadFromCache(key);\n    if (cached != null) {\n      if (VERBOSE_IS_LOGGABLE) {\n        logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n      }\n      return cached;\n    }\n\n    return null;\n  }\n\n  private static void logWithTimeAndKey(String log, long startTime, Key key) {\n    Log.v(TAG, log + \" in \" + LogTime.getElapsedMillis(startTime) + \"ms, key: \" + key);\n  }\n\n  @Nullable\n  private EngineResource&lt;?> loadFromActiveResources(Key key) {\n    EngineResource&lt;?> active = activeResources.get(key);\n    if (active != null) {\n      active.acquire();\n    }\n\n    return active;\n  }\n\n  private EngineResource&lt;?> loadFromCache(Key key) {\n    EngineResource&lt;?> cached = getEngineResourceFromCache(key);\n    if (cached != null) {\n      cached.acquire();\n      activeResources.activate(key, cached);\n    }\n    return cached;\n  }\n\n private EngineResource&lt;?> getEngineResourceFromCache(Key key) {\n    Resource&lt;?> cached = cache.remove(key);\n\n    final EngineResource&lt;?> result;\n    if (cached == null) {\n      result = null;\n    } else if (cached instanceof EngineResource) {\n      // Save an object allocation if we've cached an EngineResource (the typical case).\n      result = (EngineResource&lt;?>) cached;\n    } else {\n      result =\n          new EngineResource&lt;>(\n              cached, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, key, /*listener=*/ this);\n    }\n    return result;\n  }\n在engine.load方法中，可以看到，第23行，根据传入的请求地址，宽度和高度，签名等其他请求参数，生成了一个EngineKey对象key，这个对象就是用了标识每一个请求，不难想到，如果参数全部相同，则生成的key对象也相同；在第36行中，看到执行了loadFromMemory方法，在该方法中先是通过loadFromActiveResources方法，从内存中查找是否有对象key 的缓存资源，如果有返回；如果没有，则通过loadFromCache方法从缓存中查找是否有对象key的缓存资源，在getEngineResourceFromCache方法中，通过cache.remove(key)方法来获取到一个缓存对象，这里的cahce对象就是LruResourceCache的类对象，是通过LruResourceCache的类对象来缓存资源。\n看完了获取缓存的方法之后，我们回过头来继续看加载的方法，第38行，当获取的缓存为空时，返回了waitForExistingOrStartNewJob方法的结果，我们来看一下waitForExistingOrStartNewJob方法\nprivate &lt;R> LoadStatus waitForExistingOrStartNewJob(\n    GlideContext glideContext,\n    Object model,\n    Key signature,\n    int width,\n    int height,\n    Class&lt;?> resourceClass,\n    Class&lt;R> transcodeClass,\n    Priority priority,\n    DiskCacheStrategy diskCacheStrategy,\n    Map&lt;Class&lt;?>, Transformation&lt;?>> transformations,\n    boolean isTransformationRequired,\n    boolean isScaleOnlyOrNoTransform,\n    Options options,\n    boolean isMemoryCacheable,\n    boolean useUnlimitedSourceExecutorPool,\n    boolean useAnimationPool,\n    boolean onlyRetrieveFromCache,\n    ResourceCallback cb,\n    Executor callbackExecutor,\n    EngineKey key,\n    long startTime) {\n\n  EngineJob&lt;?> current = jobs.get(key, onlyRetrieveFromCache);\n  if (current != null) {\n    current.addCallback(cb, callbackExecutor);\n    if (VERBOSE_IS_LOGGABLE) {\n      logWithTimeAndKey(\"Added to existing load\", startTime, key);\n    }\n    return new LoadStatus(cb, current);\n  }\n\n  EngineJob&lt;R> engineJob =\n      engineJobFactory.build(\n          key,\n          isMemoryCacheable,\n          useUnlimitedSourceExecutorPool,\n          useAnimationPool,\n          onlyRetrieveFromCache);\n\n  DecodeJob&lt;R> decodeJob =\n      decodeJobFactory.build(\n          glideContext,\n          model,\n          key,\n          signature,\n          width,\n          height,\n          resourceClass,\n          transcodeClass,\n          priority,\n          diskCacheStrategy,\n          transformations,\n          isTransformationRequired,\n          isScaleOnlyOrNoTransform,\n          onlyRetrieveFromCache,\n          options,\n          engineJob);\n\n  jobs.put(key, engineJob);\n\n  engineJob.addCallback(cb, callbackExecutor);\n  engineJob.start(decodeJob);\n\n  if (VERBOSE_IS_LOGGABLE) {\n    logWithTimeAndKey(\"Started new load\", startTime, key);\n  }\n  return new LoadStatus(cb, engineJob);\n}\n前面看了load方法中，已经从缓存中取了资源，没有取到，在执行该方法，可想而知，真正的网络请求，则是在该方法中执行的；看到在第24行中，通过jobs对象获取了EngineJob对象current，如果有取到，则说明有正在请求的对象，将回调加入到当前对象中，返回当前请求状态；如果没有取到，则创建一个engineJob对象和一个decodeJob对象；然后为该请求对象添加回调接口对象，并且传入decodeJob进行启动加载（第63行）；看下engineJob.start方法.\npublic synchronized void start(DecodeJob&lt;R> decodeJob) {\n  this.decodeJob = decodeJob;\n  GlideExecutor executor =\n      decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();\n  executor.execute(decodeJob);\n}\n在该方法中根据decodeJob.willDecodeFromCache()获取到了一个GlideExecutor对象，该对象实现了ExecutorService接口类，是一个用了处理请求任务的线程池，在看一下executor.execute(decodeJob)方法需要传入一个Runnable对象，然后我吗回去看DecodeJob类是实现了Runnable接口，所以可以想到上面的engineJob对象是一个处理线程的线程池对象，真正的请求工作是在decodeJob对象的run方法中执行。\n@Override\npublic void run() {\n  GlideTrace.beginSectionFormat(\"DecodeJob#run(model=%s)\", model);\n  DataFetcher&lt;?> localFetcher = currentFetcher;\n  try {\n    if (isCancelled) {\n      notifyFailed();\n      return;\n    }\n    runWrapped();\n  } catch (CallbackException e) {\n    throw e;\n  } catch (Throwable t) {\n    if (Log.isLoggable(TAG, Log.DEBUG)) {\n      Log.d(\n          TAG,\n          \"DecodeJob threw unexpectedly\" + \", isCancelled: \" + isCancelled + \", stage: \" + stage,\n          t);\n    }\n    if (stage != Stage.ENCODE) {\n      throwables.add(t);\n      notifyFailed();\n    }\n    if (!isCancelled) {\n      throw t;\n    }\n    throw t;\n  } finally {\n    if (localFetcher != null) {\n      localFetcher.cleanup();\n    }\n    GlideTrace.endSection();\n  }\n}\n\nprivate void runWrapped() {\n  switch (runReason) {\n    case INITIALIZE:\n      stage = getNextStage(Stage.INITIALIZE);\n      currentGenerator = getNextGenerator();\n      runGenerators();\n      break;\n    case SWITCH_TO_SOURCE_SERVICE:\n      runGenerators();\n      break;\n    case DECODE_DATA:\n      decodeFromRetrievedData();\n      break;\n    default:\n      throw new IllegalStateException(\"Unrecognized run reason: \" + runReason);\n  }\n}\n\nprivate DataFetcherGenerator getNextGenerator() {\n  switch (stage) {\n    case RESOURCE_CACHE:\n      return new ResourceCacheGenerator(decodeHelper, this);\n    case DATA_CACHE:\n      return new DataCacheGenerator(decodeHelper, this);\n    case SOURCE:\n      return new SourceGenerator(decodeHelper, this);\n    case FINISHED:\n      return null;\n    default:\n      throw new IllegalStateException(\"Unrecognized stage: \" + stage);\n  }\n}\n\nprivate void runGenerators() {\n  currentThread = Thread.currentThread();\n  startFetchTime = LogTime.getLogTime();\n  boolean isStarted = false;\n  while (!isCancelled\n      &amp;&amp; currentGenerator != null\n      &amp;&amp; !(isStarted = currentGenerator.startNext())) {\n    stage = getNextStage(stage);\n    currentGenerator = getNextGenerator();\n\n    if (stage == Stage.SOURCE) {\n      reschedule();\n      return;\n    }\n  }\n  if ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) {\n    notifyFailed();\n  }\n\n}\n可以看到，在run方法中，除了一些判断和释放资源的操作，主要是执行了runWrapped()方法；在runWrapped()方法中，根据不同的runReason,执行了getNextGenerator()和runGenerators()方法，getNextGenerator()方法根据不同的stage生成不同的DataFetcherGenerator对象赋值给currentGenerator；在runGenerators()方法中，循环调用了http请求，来请求图片数据，调用方法为currentGenerator.startNext()，在startNext方法中可以看到loadData.fetcher.loadData()方法来获取图片数据\n\nResourceCacheGenerator类下的startNext()；第61行\n\n@Override\npublic boolean startNext() {\n  List&lt;Key> sourceIds = helper.getCacheKeys();\n  if (sourceIds.isEmpty()) {\n    return false;\n  }\n  List&lt;Class&lt;?>> resourceClasses = helper.getRegisteredResourceClasses();\n  if (resourceClasses.isEmpty()) {\n    if (File.class.equals(helper.getTranscodeClass())) {\n      return false;\n    }\n    throw new IllegalStateException(\n        \"Failed to find any load path from \"\n            + helper.getModelClass()\n            + \" to \"\n            + helper.getTranscodeClass());\n  }\n  while (modelLoaders == null || !hasNextModelLoader()) {\n    resourceClassIndex++;\n    if (resourceClassIndex >= resourceClasses.size()) {\n      sourceIdIndex++;\n      if (sourceIdIndex >= sourceIds.size()) {\n        return false;\n      }\n      resourceClassIndex = 0;\n    }\n\n    Key sourceId = sourceIds.get(sourceIdIndex);\n    Class&lt;?> resourceClass = resourceClasses.get(resourceClassIndex);\n    Transformation&lt;?> transformation = helper.getTransformation(resourceClass);\n    // PMD.AvoidInstantiatingObjectsInLoops Each iteration is comparatively expensive anyway,\n    // we only run until the first one succeeds, the loop runs for only a limited\n    // number of iterations on the order of 10-20 in the worst case.\n    currentKey =\n        new ResourceCacheKey( // NOPMD AvoidInstantiatingObjectsInLoops\n            helper.getArrayPool(),\n            sourceId,\n            helper.getSignature(),\n            helper.getWidth(),\n            helper.getHeight(),\n            transformation,\n            resourceClass,\n            helper.getOptions());\n    cacheFile = helper.getDiskCache().get(currentKey);\n    if (cacheFile != null) {\n      sourceKey = sourceId;\n      modelLoaders = helper.getModelLoaders(cacheFile);\n      modelLoaderIndex = 0;\n    }\n  }\n\n  loadData = null;\n  boolean started = false;\n  while (!started &amp;&amp; hasNextModelLoader()) {\n    ModelLoader&lt;File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);\n    loadData =\n        modelLoader.buildLoadData(\n            cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());\n    if (loadData != null &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) {\n      started = true;\n      loadData.fetcher.loadData(helper.getPriority(), this);\n    }\n  }\n\n  return started;\n}\n\nDataCacheGenerator类下的startNext()；第31行\n\n@Override\npublic boolean startNext() {\n  while (modelLoaders == null || !hasNextModelLoader()) {\n    sourceIdIndex++;\n    if (sourceIdIndex >= cacheKeys.size()) {\n      return false;\n    }\n\n    Key sourceId = cacheKeys.get(sourceIdIndex);\n    // PMD.AvoidInstantiatingObjectsInLoops The loop iterates a limited number of times\n    // and the actions it performs are much more expensive than a single allocation.\n    @SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\n    Key originalKey = new DataCacheKey(sourceId, helper.getSignature());\n    cacheFile = helper.getDiskCache().get(originalKey);\n    if (cacheFile != null) {\n      this.sourceKey = sourceId;\n      modelLoaders = helper.getModelLoaders(cacheFile);\n      modelLoaderIndex = 0;\n    }\n  }\n\n  loadData = null;\n  boolean started = false;\n  while (!started &amp;&amp; hasNextModelLoader()) {\n    ModelLoader&lt;File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);\n    loadData =\n        modelLoader.buildLoadData(\n            cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());\n    if (loadData != null &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) {\n      started = true;\n      loadData.fetcher.loadData(helper.getPriority(), this);\n    }\n  }\n  return started;\n}\n\nSourceGenerator类下的startNext()；第29行\n\n@Override\npublic boolean startNext() {\n  if (dataToCache != null) {\n    Object data = dataToCache;\n    dataToCache = null;\n    cacheData(data);\n  }\n\n  if (sourceCacheGenerator != null &amp;&amp; sourceCacheGenerator.startNext()) {\n    return true;\n  }\n  sourceCacheGenerator = null;\n\n  loadData = null;\n  boolean started = false;\n  while (!started &amp;&amp; hasNextModelLoader()) {\n    loadData = helper.getLoadData().get(loadDataListIndex++);\n    if (loadData != null\n        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())\n            || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {\n      started = true;\n      startNextLoad(loadData);\n    }\n  }\n  return started;\n}\n\nprivate void startNextLoad(final LoadData&lt;?> toStart) {\n  loadData.fetcher.loadData(\n      helper.getPriority(),\n      new DataCallback&lt;Object>() {\n        @Override\n        public void onDataReady(@Nullable Object data) {\n          if (isCurrentRequest(toStart)) {\n            onDataReadyInternal(toStart, data);\n          }\n        }\n\n        @Override\n        public void onLoadFailed(@NonNull Exception e) {\n          if (isCurrentRequest(toStart)) {\n            onLoadFailedInternal(toStart, e);\n          }\n        }\n      });\n}\nloadData.fetcher.loadData()方法中就是用了请求图片数据的，有很多实现类，下面取HttpUrlFetcher类的loadData()方法粘下代码看一下\n@Override\npublic void loadData(\n    @NonNull Priority priority, @NonNull DataCallback&lt;? super InputStream> callback) {\n  long startTime = LogTime.getLogTime();\n  try {\n    InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());\n    callback.onDataReady(result);\n  } catch (IOException e) {\n    if (Log.isLoggable(TAG, Log.DEBUG)) {\n      Log.d(TAG, \"Failed to load data for url\", e);\n    }\n    callback.onLoadFailed(e);\n  } finally {\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      Log.v(TAG, \"Finished http url fetcher fetch in \" + LogTime.getElapsedMillis(startTime));\n    }\n  }\n}\n\nprivate InputStream loadDataWithRedirects(\n    URL url, int redirects, URL lastUrl, Map&lt;String, String> headers) throws IOException {\n  if (redirects >= MAXIMUM_REDIRECTS) {\n    throw new HttpException(\"Too many (> \" + MAXIMUM_REDIRECTS + \") redirects!\");\n  } else {\n    // Comparing the URLs using .equals performs additional network I/O and is generally broken.\n    // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.\n    try {\n      if (lastUrl != null &amp;&amp; url.toURI().equals(lastUrl.toURI())) {\n        throw new HttpException(\"In re-direct loop\");\n      }\n    } catch (URISyntaxException e) {\n      // Do nothing, this is best effort.\n    }\n  }\n\n  urlConnection = connectionFactory.build(url);\n  for (Map.Entry&lt;String, String> headerEntry : headers.entrySet()) {\n    urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());\n  }\n  urlConnection.setConnectTimeout(timeout);\n  urlConnection.setReadTimeout(timeout);\n  urlConnection.setUseCaches(false);\n  urlConnection.setDoInput(true);\n\n  // Stop the urlConnection instance of HttpUrlConnection from following redirects so that\n  // redirects will be handled by recursive calls to this method, loadDataWithRedirects.\n  urlConnection.setInstanceFollowRedirects(false);\n\n  // Connect explicitly to avoid errors in decoders if connection fails.\n  urlConnection.connect();\n  // Set the stream so that it's closed in cleanup to avoid resource leaks. See #2352.\n  stream = urlConnection.getInputStream();\n  if (isCancelled) {\n    return null;\n  }\n  final int statusCode = urlConnection.getResponseCode();\n  if (isHttpOk(statusCode)) {\n    return getStreamForSuccessfulRequest(urlConnection);\n  } else if (isHttpRedirect(statusCode)) {\n    String redirectUrlString = urlConnection.getHeaderField(\"Location\");\n    if (TextUtils.isEmpty(redirectUrlString)) {\n      throw new HttpException(\"Received empty or null redirect url\");\n    }\n    URL redirectUrl = new URL(url, redirectUrlString);\n    // Closing the stream specifically is required to avoid leaking ResponseBodys in addition\n    // to disconnecting the url connection below. See #2352.\n    cleanup();\n    return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);\n  } else if (statusCode == INVALID_STATUS_CODE) {\n    throw new HttpException(statusCode);\n  } else {\n    throw new HttpException(urlConnection.getResponseMessage(), statusCode);\n  }\n}\n在loadDataWithRedirects方法中可以看到网络请求的操作，之后返回请求的数据流；到这里就拿到请求的数据了，然后应该回显到target上\n可以看到在请求的回调方法onDataReady中，调用回调函数cb.onDataFetcherReady()回调到DecodeJob对象中\n\nDecodeJob对象中的 onDataFetcherReady()方法\n\n@Override\npublic void onDataFetcherReady(\n    Key sourceKey, Object data, DataFetcher&lt;?> fetcher, DataSource dataSource, Key attemptedKey) {\n  this.currentSourceKey = sourceKey;\n  this.currentData = data;\n  this.currentFetcher = fetcher;\n  this.currentDataSource = dataSource;\n  this.currentAttemptingKey = attemptedKey;\n  if (Thread.currentThread() != currentThread) {\n    runReason = RunReason.DECODE_DATA;\n    callback.reschedule(this);\n  } else {\n    GlideTrace.beginSection(\"DecodeJob.decodeFromRetrievedData\");\n    try {\n      decodeFromRetrievedData();\n    } finally {\n      GlideTrace.endSection();\n    }\n  }\n}\n\n@Override\npublic void onDataFetcherFailed(\n    Key attemptedKey, Exception e, DataFetcher&lt;?> fetcher, DataSource dataSource) {\n  fetcher.cleanup();\n  GlideException exception = new GlideException(\"Fetching data failed\", e);\n  exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());\n  throwables.add(exception);\n  if (Thread.currentThread() != currentThread) {\n    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;\n    callback.reschedule(this);\n  } else {\n    runGenerators();\n  }\n}\n\nprivate void decodeFromRetrievedData() {\n  if (Log.isLoggable(TAG, Log.VERBOSE)) {\n    logWithTimeAndKey(\n        \"Retrieved data\",\n        startFetchTime,\n        \"data: \"\n            + currentData\n            + \", cache key: \"\n            + currentSourceKey\n            + \", fetcher: \"\n            + currentFetcher);\n  }\n  Resource&lt;R> resource = null;\n  try {\n    resource = decodeFromData(currentFetcher, currentData, currentDataSource);\n  } catch (GlideException e) {\n    e.setLoggingDetails(currentAttemptingKey, currentDataSource);\n    throwables.add(e);\n  }\n  if (resource != null) {\n    notifyEncodeAndRelease(resource, currentDataSource);\n  } else {\n    runGenerators();\n  }\n}\n\nprivate void notifyEncodeAndRelease(Resource&lt;R> resource, DataSource dataSource) {\n  if (resource instanceof Initializable) {\n    ((Initializable) resource).initialize();\n  }\n\n  Resource&lt;R> result = resource;\n  LockedResource&lt;R> lockedResource = null;\n  if (deferredEncodeManager.hasResourceToEncode()) {\n    lockedResource = LockedResource.obtain(resource);\n    result = lockedResource;\n  }\n\n  notifyComplete(result, dataSource);\n\n  stage = Stage.ENCODE;\n  try {\n    if (deferredEncodeManager.hasResourceToEncode()) {\n      deferredEncodeManager.encode(diskCacheProvider, options);\n    }\n  } finally {\n    if (lockedResource != null) {\n      lockedResource.unlock();\n    }\n  }\n  // Call onEncodeComplete outside the finally block so that it's not called if the encode process\n  // throws.\n  onEncodeComplete();\n}\n\nprivate void notifyComplete(Resource&lt;R> resource, DataSource dataSource) {\n    setNotifiedOrThrow();\n    callback.onResourceReady(resource, dataSource);\n  }\n在onDataFetcherReady方法中调用decodeFromRetrievedData();方法进行解码图片数据，成功拿到解码后的图片资源数据之后，调用notifyEncodeAndRelease方法将Resource&lt;R&gt;对象封装成LockedResource对象，并调用notifyComplete(result, dataSource);方法，在notifyComplete(result, dataSource);方法中通过callback.onResourceReady(resource, dataSource)将资源数据回调到EngineJob&lt;R&gt;对象中的onResourceReady方法\n@Override\npublic void onResourceReady(Resource&lt;R> resource, DataSource dataSource) {\n  synchronized (this) {\n    this.resource = resource;\n    this.dataSource = dataSource;\n  }\n  notifyCallbacksOfResult();\n}\n\n@Override\npublic void onLoadFailed(GlideException e) {\n  synchronized (this) {\n    this.exception = e;\n  }\n  notifyCallbacksOfException();\n}\n\nvoid notifyCallbacksOfResult() {\n    ResourceCallbacksAndExecutors copy;\n    Key localKey;\n    EngineResource&lt;?> localResource;\n    synchronized (this) {\n      stateVerifier.throwIfRecycled();\n      if (isCancelled) {\n        resource.recycle();\n        release();\n        return;\n      } else if (cbs.isEmpty()) {\n        throw new IllegalStateException(\"Received a resource without any callbacks to notify\");\n      } else if (hasResource) {\n        throw new IllegalStateException(\"Already have resource\");\n      }\n      engineResource = engineResourceFactory.build(resource, isCacheable, key, resourceListener);\n      hasResource = true;\n      copy = cbs.copy();\n      incrementPendingCallbacks(copy.size() + 1);\n\n      localKey = key;\n      localResource = engineResource;\n    }\n\n    engineJobListener.onEngineJobComplete(this, localKey, localResource);\n\n    for (final ResourceCallbackAndExecutor entry : copy) {\n      entry.executor.execute(new CallResourceReady(entry.cb));\n    }\n    decrementPendingCallbacks();\n  }\n\n  @SuppressWarnings(\"WeakerAccess\")\n  @Synthetic\n  synchronized void incrementPendingCallbacks(int count) {\n    Preconditions.checkArgument(isDone(), \"Not yet complete!\");\n    if (pendingCallbacks.getAndAdd(count) == 0 &amp;&amp; engineResource != null) {\n      engineResource.acquire();\n    }\n  }\n\n  @SuppressWarnings(\"WeakerAccess\")\n  @Synthetic\n  void decrementPendingCallbacks() {\n    EngineResource&lt;?> toRelease = null;\n    synchronized (this) {\n      stateVerifier.throwIfRecycled();\n      Preconditions.checkArgument(isDone(), \"Not yet complete!\");\n      int decremented = pendingCallbacks.decrementAndGet();\n      Preconditions.checkArgument(decremented >= 0, \"Can't decrement below 0\");\n      if (decremented == 0) {\n        toRelease = engineResource;\n\n        release();\n      }\n    }\n\n    if (toRelease != null) {\n      toRelease.release();\n    }\n  }\n在EngineJob&lt;R&gt;对象中的onResourceReady方法中通过第45行执行CallResourceReady这个Runnable的实现类，\nCallResourceReady实现类如下：\nprivate class CallResourceReady implements Runnable {\n\n  private final ResourceCallback cb;\n\n  CallResourceReady(ResourceCallback cb) {\n    this.cb = cb;\n  }\n\n  @Override\n  public void run() {\n    // Make sure we always acquire the request lock, then the EngineJob lock to avoid deadlock\n    // (b/136032534).\n    synchronized (cb.getLock()) {\n      synchronized (EngineJob.this) {\n        if (cbs.contains(cb)) {\n          // Acquire for this particular callback.\n          engineResource.acquire();\n          callCallbackOnResourceReady(cb);\n          removeCallback(cb);\n        }\n        decrementPendingCallbacks();\n      }\n    }\n  }\n}\n在这个实现类中的run方法里，调用了EngineJob&lt;R&gt;对象的callCallbackOnResourceReady方法\n@SuppressWarnings(\"WeakerAccess\")\n@Synthetic\n@GuardedBy(\"this\")\nvoid callCallbackOnResourceReady(ResourceCallback cb) {\n  try {\n    // This is overly broad, some Glide code is actually called here, but it's much\n    // simpler to encapsulate here than to do so at the actual call point in the\n    // Request implementation.\n    cb.onResourceReady(engineResource, dataSource);\n  } catch (Throwable t) {\n    throw new CallbackException(t);\n  }\n}\n在这个方法中通过ResourceCallback回调接口类的onResourceReady回调到SingleRequest对象中\n再贴一下SingleRequest对象中的代码\npublic void onResourceReady(Resource&lt;?> resource, DataSource dataSource) {\n  stateVerifier.throwIfRecycled();\n  Resource&lt;?> toRelease = null;\n  try {\n    synchronized (requestLock) {\n      loadStatus = null;\n      if (resource == null) {\n        GlideException exception =\n            new GlideException(\n                \"Expected to receive a Resource&lt;R> with an \"\n                    + \"object of \"\n                    + transcodeClass\n                    + \" inside, but instead got null.\");\n        onLoadFailed(exception);\n        return;\n      }\n\n      Object received = resource.get();\n      if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {\n        toRelease = resource;\n        this.resource = null;\n        GlideException exception =\n            new GlideException(\n                \"Expected to receive an object of \"\n                    + transcodeClass\n                    + \" but instead\"\n                    + \" got \"\n                    + (received != null ? received.getClass() : \"\")\n                    + \"{\"\n                    + received\n                    + \"} inside\"\n                    + \" \"\n                    + \"Resource{\"\n                    + resource\n                    + \"}.\"\n                    + (received != null\n                        ? \"\"\n                        : \" \"\n                            + \"To indicate failure return a null Resource \"\n                            + \"object, rather than a Resource object containing null data.\"));\n        onLoadFailed(exception);\n        return;\n      }\n\n      if (!canSetResource()) {\n        toRelease = resource;\n        this.resource = null;\n        // We can't put the status to complete before asking canSetResource().\n        status = Status.COMPLETE;\n        return;\n      }\n\n      onResourceReady((Resource&lt;R>) resource, (R) received, dataSource);\n    }\n  } finally {\n    if (toRelease != null) {\n      engine.release(toRelease);\n    }\n  }\n}\n\n/**\n * Internal {@link #onResourceReady(Resource, DataSource)} where arguments are known to be safe.\n *\n * @param resource original {@link Resource}, never &lt;code>null&lt;/code>\n * @param result object returned by {@link Resource#get()}, checked for type and never &lt;code>null\n *     &lt;/code>\n */\n@GuardedBy(\"requestLock\")\nprivate void onResourceReady(Resource&lt;R> resource, R result, DataSource dataSource) {\n  // We must call isFirstReadyResource before setting status.\n  boolean isFirstResource = isFirstReadyResource();\n  status = Status.COMPLETE;\n  this.resource = resource;\n\n  if (glideContext.getLogLevel() &lt;= Log.DEBUG) {\n    Log.d(\n        GLIDE_TAG,\n        \"Finished loading \"\n            + result.getClass().getSimpleName()\n            + \" from \"\n            + dataSource\n            + \" for \"\n            + model\n            + \" with size [\"\n            + width\n            + \"x\"\n            + height\n            + \"] in \"\n            + LogTime.getElapsedMillis(startTime)\n            + \" ms\");\n  }\n\n  isCallingCallbacks = true;\n  try {\n    boolean anyListenerHandledUpdatingTarget = false;\n    if (requestListeners != null) {\n      for (RequestListener&lt;R> listener : requestListeners) {\n        anyListenerHandledUpdatingTarget |=\n            listener.onResourceReady(result, model, target, dataSource, isFirstResource);\n      }\n    }\n    anyListenerHandledUpdatingTarget |=\n        targetListener != null\n            &amp;&amp; targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);\n\n    if (!anyListenerHandledUpdatingTarget) {\n      Transition&lt;? super R> animation = animationFactory.build(dataSource, isFirstResource);\n      target.onResourceReady(result, animation);\n    }\n  } finally {\n    isCallingCallbacks = false;\n  }\n\n  notifyLoadSuccess();\n}\n\n/** A callback method that should never be invoked directly. */\n@Override\npublic void onLoadFailed(GlideException e) {\n  onLoadFailed(e, Log.WARN);\n}\n在这里方法里通过target.onResourceReady回调方法，将请求到数图片数据显示到目标view上。\n至此，Glide加载的原理浅析就完成了，望共勉！\n","categories":["Android"],"tags":["Android","glide","code"]},{"title":"FiveFiveVideoPlayer 一个可以高度自定义的播放器","url":"https://blog.onestravel.cn/20200320/57ca58f70f21/","content":"FiveFiveVideoPlayerFiveFiveVideoPlayer 是一个可以高度自定义的播放器，手势改变亮度，音量，进度；支持调整倍速；可以轻松实现全屏视频播放，列表视频播放，小窗口视频播放\n1. 效果示例1.1 效果图竖屏效果\n\n横屏效果\n1.2 APK 功能体验demo比较粗糙，请勿介意\nAPK 下载 安装体验\n扫描二维码图片安装体验（浏览器扫描）\n\n2. 快速集成version:\n2.1 gradle 引入（$version 需要替换为上图对应的版本号）    implementation 'cn.onestravel:FiveFiveVideoPlayer:$version'\n例如：\n    implementation 'cn.onestravel:FiveFiveVideoPlayer:1.0.1'\n2.2 添加权限    &lt;uses-permission android:name=\"android.permission.INTERNET\" />\n2.3 使用 FiveVideoPlayerActivity 播放视频FiveVideoPlayerActivity 是一个集成播放器的Activity,在只需要播放视频的情况下可直接使用\n\n使用方式：在需要播放视频的地方添加以下代码，开始播放视频\n\n val path = \"http://vfx.mtime.cn/Video/2019/03/19/mp4/190319212559089721.mp4\"\n // 传入视频地址开始播放\n FiveVideoPlayerActivity.start(this, path)\n // 传入视频地址和视频标题开始播放\n FiveVideoPlayerActivity.start(this, path,\"玩具总动员\")\n // 传入视频地址和视频标题开始循环播放\n FiveVideoPlayerActivity.start(this, path,\"玩具总动员\",true)\n2.4 使用 FiveVideoPlayer 播放视频FiveVideoPlayer ：集成了视频播放，控制器，顶部标题栏，右侧选择窗口的View，可以直接使用在xml布局中，方便使用视频播放器时根据自己的情况更改视频播放器展示View；可以根据不同的设计方案进行控制器的替换（需实现控制器接口或继承现有控制器类，对需要调整部分进行更改）可以直接使用右侧选择窗口，实现倍速调整（功能已实现）或者 视频质量的切换（该功能暂未实现）\n\n使用方式：\n\n在布局 xml 文件中加入一下代码\n\n\n  &lt;cn.onestravel.fivefiveplayer.FiveVideoPlayer\n         android:id=\"@+id/fiveVideoPlayer\"\n         android:layout_width=\"match_parent\"\n         android:layout_height=\"match_parent\" />\n\n在Activity 中使用该 View 进行视频播放\n\n        fun initData {\n            val path = \"http://vfx.mtime.cn/Video/2019/03/19/mp4/190319212559089721.mp4\"\n            val title = \"玩具总动员\"\n            fiveVideoPlayer.setOnPreparedListener {\n                    it.start()\n                    it.setVideoDisplayType(PlayerInterface.VIDEO_DISPLAY_TYPE_FIT_CENTER)\n            }\n            fiveVideoPlayer.setDataSource(path,title)\n        }\n\n     override fun onDestroy() {\n        try {\n            fiveVideoPlayer?.let {\n                it.reset()\n                it.release()\n            }\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n        super.onDestroy()\n    }\n或\n    fun initData {\n        val path = \"http://vfx.mtime.cn/Video/2019/03/19/mp4/190319212559089721.mp4\"\n        val title = \"玩具总动员\"\n        val looping = false;\n        val mediaDataSource = MediaDataSource(title, Uri.parse(path), looping)\n        fiveVideoPlayer.setOnPreparedListener {\n            it.start()\n            it.setVideoDisplayType(PlayerInterface.VIDEO_DISPLAY_TYPE_FIT_CENTER)\n        }\n        fiveVideoPlayer.setDataSource(it)\n        }\n\n       override fun onDestroy() {\n           try {\n               fiveVideoPlayer?.let {\n                   it.reset()\n                   it.release()\n               }\n           } catch (e: Exception) {\n               e.printStackTrace()\n           }\n           super.onDestroy()\n       }\n2.5 使用 FiveVideoView 播放视频FiveVideoView ：视频播放的View，无控制栏，标题栏，可设置（单击/双击进行播放，暂停操作）可以直接使用在xml布局中，一般使用在自定义程度比较高的视频播放器中，或者在列表播放中使用；\n\n使用方式：\n\n在布局 xml 文件中加入一下代码\n\n\n   &lt;cn.onestravel.fivefiveplayer.FiveVideoView\n          android:id=\"@+id/fiveVideoView\"\n          android:layout_width=\"match_parent\"\n          android:layout_height=\"200dp\"\n          android:background=\"@android:color/black\"\n          app:layout_constraintTop_toTopOf=\"parent\" />\n\n在Activity 中使用该 View 进行视频播放\n\n    fun initData {\n          val path = \"http://vfx.mtime.cn/Video/2019/03/19/mp4/190319212559089721.mp4\"\n        fiveVideoView.setDataSource(path)\n        fiveVideoView.setOnPreparedListener {\n            it.start()\n            fiveVideoView.setVideoDisplayType(PlayerInterface.VIDEO_DISPLAY_TYPE_FIT_CENTER)\n    }\n\n     override fun onDestroy() {\n           try {\n               fiveVideoPlayer?.let {\n                   it.reset()\n                   it.release()\n               }\n           } catch (e: Exception) {\n               e.printStackTrace()\n           }\n           super.onDestroy()\n       }\n3. API 文档点击 FiveFiveVideoPlayer API 文档查看详细API\n4. 版本记录\nV 1.0.1\n\n1. 实现集成 IJKplayer 内核，可开启硬解码;\n\n2. 实现ExoPlayer内核;\n\n3. 实现可全局设置播放器内核功能;\n\n4. 修复已知bug\nV 1.0.0\n\n1. 集成 Media Player 内核\n\n2. 实现视频播放View,实现单击/双击进行暂停，播放\n\n3. 实现视频播放器View,视频播放器Activity\n\n4. 支持手势滑动调整音量，亮度，进度\n\n5. 支持自定义视频播放控制器，播放器内含默认视频控制器\n温馨提示：\n\n在使用过程中，如遇到任何问题，可发送邮件至server@onestravel.cn说明相关问题，我在看到邮件第一时间，会针对相应问题进行沟通解决，谢谢支持！\n","categories":["Android"],"tags":["Android","FiveFiveVideoPlayer"]},{"title":"OneActionBar 通用标题头","url":"https://blog.onestravel.cn/20190825/b85ce6818e52/","content":"OneActionBar 使用说明English Document\n简介自定义ActionBar，支持属性，java代码方式配置，可实现标题，标题带返回键，搜索，搜索带返回键的ActionBar；配置简单，方便使用，可适应大多数场景。\n效果图\n\n标准标题头，背景透明 style=&quot;@style/OneActionBar.Normal&quot;\n标准标题头，蓝色背景 style=&quot;@style/OneActionBar.Normal.Blue&quot;\n带返回键标题头，透明背景 style=&quot;@style/OneActionBar.Back&quot;\n带返回键标题头，蓝色背景 style=&quot;@style/OneActionBar.Back.Blue&quot;\n带搜索框标题头，透明背景 style=&quot;@style/OneActionBar.Search&quot;\n带搜索框标题头，蓝色背景 ``style=”@style/OneActionBar.Search.Blue”\n搜索框带返回键标题头，透明背景 style=&quot;@style/OneActionBar.Back.Search&quot;\n搜索框带返回键标题头，蓝色背景 style=&quot;@style/OneActionBar.Back.Search.Blue&quot;\n\n引入方式TAG:     \ngradle\n在项目中的根目录下的 build.gradle (与model同级的) 中增加如下配置\n\n    allprojects &#123;\n        repositories &#123;\n            ...\n            maven &#123; url &#39;https://jitpack.io&#39; &#125;\n        &#125;\n    &#125;\n\n在model 中的build.gradle 中增加依赖\n\ndependencies &#123;\n    implementation &#39;com.github.onestravel:OneActionBar:TAG&#39;\n&#125;\n属性说明\n\n\n属性名\n字段说明\n示例\n\n\n\napp:barBackColor\nActionBar 返回键颜色，图标和字体的颜色\napp:barBackColor=”#000000”\n\n\napp:barBackIconWidth\nActionBar 返回键图标的宽度\napp:barBackIconWidth=”25dp”\n\n\napp:barBackIconHeight\nActionBar 返回键图标的高度\napp:barBackIconHeight=”25dp”\n\n\napp:barBackText\nActionBar 返回键文字\napp:barBackText=”返回”\n\n\napp:barBackTextSize\nActionBar 返回键文字大小\napp:barBackTextSize=”13sp”\n\n\napp:barTitle\nActionBar 标题文字\napp:barTitle=”首页”\n\n\napp:barTitleColor\nActionBar 标题文字颜色\napp:barTitleColor=”#000000”\n\n\napp:barTitleSize\nActionBar 标题文字大小\napp:barTitleSize=”22sp”\n\n\napp:barType\nActionBar 样式，总共有四种样式：TYPE_NORMAL(普通样式)、TYPE_BACK(普通带返回键样式)、TYPE_SEARCH(搜索样式)、TYPE_BACK_SEARCH(带返回键搜索样式)、\napp:barType=”TYPE_NORMAL”\n\n\napp:barActionBtnColor\nActionBar 标题右侧操作按钮图标/文字颜色\napp:barActionBtnColor=”#FF0000”\n\n\napp:barActionBtnText\nActionBar 标题右侧操作按钮文字\napp:barActionBtnText=”下一步”\n\n\napp:barActionBtnTextSize\nActionBar 标题右侧操作按钮文字大小\napp:barActionBtnTextSize=”15sp”\n\n\napp:barBottomLineWidth\nActionBar 底部分割线的宽度\napp:barBottomLineWidth=”1dp”\n\n\napp:barBottomLineColor\nActionBar 底部分割线的颜色\napp:barBottomLineColor=”#1a1a1a”\n\n\napp:barActionBtnIcon\nActionBar 标题右侧操作按钮icon\napp:barActionBtnIcon=”@drawable/icon_next”\n\n\napp:barActionBtnIconWidth\nActionBar 标题右侧操作按钮宽度\napp:barActionBtnIconWidth=”25dp”\n\n\napp:barActionBtnIconHeight\nActionBar 标题右侧操作按钮高度\napp:barActionBtnIconHeight=”25dp”\n\n\napp:barSearchBackground\nActionBar 搜索样式背景\napp:barSearchBackground=”#FFFFFF”\n\n\napp:barSearchHint\nActionBar 搜索样式搜索框提示文字\napp:barSearchHint=”请输入搜索内容”\n\n\napp:barSearchText\nActionBar 搜索样式搜索框文字\napp:barSearchText=”今日新闻”\n\n\napp:barSearchHintColor\nActionBar 搜索样式搜索框提示文字颜色\napp:barSearchHintColor=”#E1E1E1”\n\n\napp:barSearchTextColor\nActionBar 搜索样式搜索框文字颜色\napp:barSearchTextColor=”#000000”\n\n\napp:barSearchTextSize\nActionBar 搜索样式搜索框文字大小\napp:barSearchTextSize=”20sp”\n\n\nandroid:background\nActionBar 背景颜色\nandroid:background=”#FFFFFF”\n\n\n样式说明根据图片效果，先自定义样式说明如下\n注：标号对应图片效果数字号码\n\n标准标题头，背景透明 style=&quot;@style/OneActionBar.Normal&quot;\n标准标题头，蓝色背景 style=&quot;@style/OneActionBar.Normal.Blue&quot;\n带返回键标题头，透明背景 style=&quot;@style/OneActionBar.Back&quot;\n带返回键标题头，蓝色背景 style=&quot;@style/OneActionBar.Back.Blue&quot;\n带搜索框标题头，透明背景 style=&quot;@style/OneActionBar.Search&quot;\n带搜索框标题头，蓝色背景 ``style=”@style/OneActionBar.Search.Blue”\n搜索框带返回键标题头，透明背景 style=&quot;@style/OneActionBar.Back.Search&quot;\n搜索框带返回键标题头，蓝色背景 style=&quot;@style/OneActionBar.Back.Search.Blue&quot;\n\n示例1、布局xml\n&lt;cn.onestravel.one.actionbar.OneActionBar\n        style=\"@style/OneActionBar.Back.Blue\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"50dp\"\n        app:barActionBtnText=\"下一步\"\n        app:barTitle=\"调查问卷\" />\n2、样式\n\n              22sp\n        16sp\n        TYPE_BACK\n        14sp\n        返回\n\n\n    #0080ff\n    @android:color/white\n    @android:color/white\n    @android:color/white\n\n","categories":["Android"],"tags":["Android","one-extend-lib"]},{"title":"调整数组顺序使奇数位于偶数前面","url":"https://blog.onestravel.cn/20190410/26a8869c22b1/","content":"15.调整数组顺序使奇数位于偶数前面题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n解题思路运用插入思想\n\n要想让相对位置不变，则需要相邻位置交换\n引入标志位k 表示前半部分最后一个奇数位置\n寻找到下一个奇数时，将标志位 k 之后到当前奇数位置上的数按照顺序从后向前相邻移动奇数到k位置\n\n代码实现java 代码    public void reOrderArray(int[] array) {\n        int k = 0;\n        for (int i = 0; i &lt; array.length; i++) {\n            if (array[i] % 2 != 0) {\n                for (int j = i; j > k; j--) {\n                    int temp = array[j - 1];\n                    array[j - 1] = array[j];\n                    array[j] = temp;\n                }\n                k++;\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        int[] arr = {4,1, 3, 2, 5, 7, 4, 6, 9, 8, 3};\n        reOrderArray(arr);\n        System.out.println(Arrays.toString(arr));\n    }\nKotlin 代码    /**\n     * 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n     * 运用插入思想\n     * 1. 要想让相对位置不变，则需要相邻位置交换\n     * 2. 引入标志位k 表示前半部分最后一个奇数位置\n     * 3. 寻找到下一个奇数时，将标志位 k 之后到当前奇数位置上的数按照顺序从后向前相邻移动奇数到k位置\n     * @param array\n     */\n    fun reOrderArray(array: IntArray) {\n        var k = 0\n        for (i in array.indices) {\n            if (array[i] % 2 != 0) {\n                for (j in i downTo k + 1) {\n                    val temp = array[j - 1]\n                    array[j - 1] = array[j]\n                    array[j] = temp\n                }\n                k++\n            }\n        }\n    }\n\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        val arr = intArrayOf(4, 1, 3, 2, 5, 7, 4, 6, 9, 8, 3)\n        reOrderArray(arr)\n        println(arr.contentToString())\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["数组"]},{"title":"数值的整数次方","url":"https://blog.onestravel.cn/20190408/65408e8169da/","content":"14.数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n保证base和exponent不同时为0\n解题思路\nbase = 0 时，返回0\nexponent = 0 时，任何数的0次方都为1;返回1\nexponent &lt; 0 时，base^exponent 为 1 除以 base的exponent的绝对值次方（base绝对值的exponent绝对值次方分之一）\nexponent &gt; 0 时，base^exponent 为 base的exponent的绝对值次方\n\n代码实现java 代码    /**\n     * 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n     *\n     * 保证base和exponent不同时为0\n     *\n     * 1. base = 0 时，返回0\n     * 2. exponent = 0 时，任何数的0次方都为1;返回1\n     * 3. exponent &lt; 0 时，base^exponent 为 1 除以 base的exponent的绝对值次方（base绝对值的exponent绝对值次方分之一）\n     * 4. exponent > 0 时，base^exponent 为 base的exponent的绝对值次方\n     * @param base 基数浮点数\n     * @param exponent 次幂\n     * @return\n     */\n    public double power(double base, int exponent) {\n        if (base == 0) {\n            return 0;\n        }\n        if (exponent == 0) {\n            return 1;\n        }\n        double res = 1;\n        if (exponent &lt; 0) {\n            base = 1 / base;\n            exponent = exponent * -1;\n        }\n        for (int i = 0; i &lt; exponent; i++) {\n            res *= base;\n        }\n        return res;\n    }\n\n    public static void main(String[] args){\n        System.out.println(power(-2, 3));\n        System.out.println(power(2, -3));\n    }\nKotlin 代码    /**\n     * 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n     *\n     * 保证base和exponent不同时为0\n     *\n     * 1. base = 0 时，返回0\n     * 2. exponent = 0 时，任何数的0次方都为1;返回1\n     * 3. exponent &lt; 0 时，base^exponent 为 1 除以 base的exponent的绝对值次方（base绝对值的exponent绝对值次方分之一）\n     * 4. exponent > 0 时，base^exponent 为 base的exponent的绝对值次方\n     * @param base 基数浮点数\n     * @param exponent 次幂\n     * @return\n     */\n    fun power(base: Double, exponent: Int): Double {\n        var base = base\n        var exponent = exponent\n        if (base == 0.0) {\n            return 0.0\n        }\n        if (exponent == 0) {\n            return 1.0\n        }\n        var res = 1.0\n        if (exponent &lt; 0) {\n            base = 1 / base\n            exponent *= -1\n        }\n        for (i in 0 until exponent) {\n            res *= base\n        }\n        return res\n    }\n\n\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        println(power(-2.0, 3))\n        println(power(2.0, -3))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["数学"]},{"title":"【FFmpeg】(二) 视频解码、像素格式转换与Native原生绘制","url":"https://blog.onestravel.cn/20190401/f3bded2d8605/","content":"视频解码、像素格式转换与Native原生绘制一、视频解码1、FFmpeg 库简介FFmpeg 一共包含8个库\n\navcodec：编解码（最重要的库）\navformat：封装格式处理\navfilter：滤镜特效处理\navdevice：各自设备的输入输出\navutil：工具库（大部分库都需要这个库的支持）\npostproc：后加工\nswresample：音频采样数据格式转换\nswscale：视频像素数据格式转换\n\n2、FFmpeg 解码的流程图/\n3、FFmpeg 数据格式简介\nAVFormatContext：封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息\nAVInputFormat：每种封装格式（例如FLV、MKV、MP4、AVI）对应一个该结构体。\nAVStream：视频文件中每个视频（音频）流对应一个该结构体\nAVCodeContext：编解码器上下文结构体，保存了视频（音频）编解码相关信息。\nAVCodec：每种视频（音频）编解码器（例如H.264解码器）对应一个该结构体\nAVPacket：存储一帧压缩编码数据\nAVFrame：存储一帧解码后的像素（采样）数据\n\n二、像素格式转换像素格式转换就是将yuv420p 的转成ARGB,可以使用 C/C++ 库 libyuv 来进行转换\nI420ToARGB参数按顺序如下：参数 | 类型　| 说明— | — | —src_y|  uint8_t*  | 来源的frame的 y 帧数据 yuv_frame-&gt;datasrc_stride_y|  int  | 来源的frame的y大小数据 yuv_frame-&gt;linesizesrc_u|  uint8_t*  | 来源的frame的 u 帧数据yuv_frame-&gt;datasrc_stride_u|  int  | 来源的frame的u大小数据 yuv_frame-&gt;linesizesrc_v|  uint8_t*  | 来源的frame的 v 帧数据yuv_frame-&gt;datasrc_stride_v|  int | 来源的frame的v大小数据 yuv_frame-&gt;linesizedst_argb|  uint8_t*  | 转换后的 rgb 的frame数据dst_stride_argb|  int  | 转换后的 rgb 的frame的大小数据width|  int  | 像素数据宽度height|  int  | 像素数据高度\n三、Native 原生绘制Native 原生绘制是使用ANativeWindow 将surface 和 缓冲区buffer绑定，进而去更新缓冲区的数据，并刷新到 surface 就可以实现原生绘制\n1、获取ANativeWindow指针,定义缓冲区    //Native 绘制\n    ANativeWindow *nativeWindow = ANativeWindow_fromSurface(env, surface);\n    //缓冲区buffer\n    ANativeWindow_Buffer windowBuffer;2、设置缓冲区参数//设置缓冲区参数\nANativeWindow_setBuffersGeometry(nativeWindow, avCodecContext-&gt;width,\n                                             avCodecContext-&gt;height, WINDOW_FORMAT_RGBA_8888);3、刷新数据到缓冲区\n对缓冲区进行加锁\n刷新转换后的数据到缓冲区\n对缓冲区数据进行解锁\n\n//LOCK\nANativeWindow_lock(nativeWindo&amp;windowBuffer, NULL\navpicture_fill((AVPicture rgba_frame, windowBuffer.bitPIX_FMT_RGBA,\n            avCodecContext-&gt;width,\n            avCodecContext-&gt;height\n//fix buffer\nI420ToARGB(\n        yuv_frame-&gt;data[0yuv_frame-&gt;linesize[0],\n        yuv_frame-&gt;data[2yuv_frame-&gt;linesize[2],\n        yuv_frame-&gt;data[1yuv_frame-&gt;linesize[1],\n        rgba_frame-&gt;data[0rgba_frame-&gt;linesize[0],\n        avCodecContext-&gt;widtavCodecContext-&gt;height\n//UNLOCK\nANativeWindow_unlockAndPost(natiindow);4、释放nativeWindowANativeWindow_release(nativeWindow);四、使用FFmpeg实现native原生绘制，显示视频图像之前说明了Android Studio 使用 CMake 来配置FFmpeg 的方法，这里就省略项目配置与Java代码部分，主要来实现C/C++代码部分,将像素数据会知道 Surface 上\n#include &quot;cn_onestravel_ndk_ffmpeg_render_VideoPlayer.h&quot;\n#include &lt;android/log.h&gt;\n#include &lt;unistd.h&gt;\n//编码\n#include &quot;include/libavcodec/avcodec.h&quot;\n//封装格式处理\n#include &quot;include/libavformat/avformat.h&quot;\n//像素处理\n#include &quot;include/libswscale/swscale.h&quot;\n#include &quot;include/libavutil/avutil.h&quot;\n#include &quot;include/libavutil/frame.h&quot;\n#include &lt;android/native_window.h&gt;\n#include &lt;android/native_window_jni.h&gt;\n#include &lt;libyuv.h&gt;\n#include &lt;pthread.h&gt;\n\n\n#define LOGI(FORMAT, ...) __android_log_print(ANDROID_LOG_INFO,&quot;FFMPEG&quot;,FORMAT,##__VA_ARGS__);\n#define LOGE(FORMAT, ...) __android_log_print(ANDROID_LOG_ERROR,&quot;FFMPEG&quot;,FORMAT,##__VA_ARGS__);\n\n\n/*\n * Class:     cn_onestravel_ndk_ffmpeg_render_VideoPlayer\n * Method:    render\n * Signature: (Ljava/lang/String;Landroid/view/Surface;)V\n */\nJNIEXPORT void JNICALL Java_cn_onestravel_ndk_ffmpeg_render_VideoPlayer_render\n        (JNIEnv *env, jclass jcls, jstring jstr_input, jobject surface) &#123;\n    const char *cstr_input = (*env)-&gt;GetStringUTFChars(env, jstr_input, NULL);\n    //注册ffmpeg 所有组件\n    av_register_all();\n    //封装格式上下文\n    AVFormatContext *formatContext = avformat_alloc_context();\n    //打开输入视频文件\n    if (avformat_open_input(&amp;formatContext, cstr_input, NULL, NULL) != 0) &#123;\n        LOGE(&quot;无法打开视频文件&quot;);\n        return;\n    &#125;\n    //获取视频文件信息\n    if (avformat_find_stream_info(formatContext, NULL) &lt; 0) &#123;\n        LOGE(&quot;获取视频文件信息失败&quot;);\n        return;\n    &#125;\n    //获取视频流的索引位置\n    //遍历所有类型的流（音频流，视频流、字幕流）\n    int i = 0;\n    int v_stream_index = -1;\n    for (; i &lt; formatContext-&gt;nb_streams; i++) &#123;\n        if (formatContext-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;\n            v_stream_index = i;\n            break;\n        &#125;\n    &#125;\n    if (v_stream_index &lt; 0) &#123;\n        LOGE(&quot;%s&quot;, &quot;找不到视频流\\n&quot;);\n        return;\n    &#125;\n    //获取视频流中的编解码的上下文\n    AVCodecContext *avCodecContext = formatContext-&gt;streams[v_stream_index]-&gt;codec;\n    //根据视频编解码上下文的id得到对应的编解码器\n\n    AVCodec *avCodec = avcodec_find_decoder(avCodecContext-&gt;codec_id);\n    if (avCodec == NULL) &#123;\n        LOGE(&quot;未找到解码器&quot;);\n        return;\n    &#125;\n    //打开解码器\n    if (avcodec_open2(avCodecContext, avCodec, NULL) &lt; 0) &#123;\n        LOGE(&quot;打开解码器失败&quot;);\n        return;\n    &#125;\n    //输出视频信息\n    LOGI(&quot;视频文件格式：%s&quot;, formatContext-&gt;iformat-&gt;name);\n    //formatContext-&gt;duration单位为微妙\n    LOGI(&quot;视频时长：%lld&quot;, (formatContext-&gt;duration) / 1000000);\n    LOGI(&quot;视频的宽度和高度 W：%d ,H：%d&quot;, avCodecContext-&gt;width, avCodecContext-&gt;height);\n    LOGI(&quot;视频解码器名称：%s&quot;, avCodec-&gt;name);\n    //准备读取\n    //AVPacket用于存储一帧一帧的压缩数据（H264）\n    //缓冲区，开辟空间\n    AVPacket *packet = (AVPacket *) av_malloc(sizeof(AVPacket));\n    AVFrame *yuv_frame = av_frame_alloc();\n    AVFrame *yuv_scale_frame = av_frame_alloc();\n    AVFrame *rgba_frame = av_frame_alloc();\n    //Native 绘制\n    ANativeWindow *nativeWindow = ANativeWindow_fromSurface(env, surface);\n    //缓冲区buffer\n    ANativeWindow_Buffer windowBuffer;\n\n    int len, got_frame, frame_count = 0;\n    while (av_read_frame(formatContext, packet) &gt;= 0) &#123;\n        len = avcodec_decode_video2(avCodecContext, yuv_frame, &amp;got_frame, packet);\n        //不为0,正在解码\n        if (got_frame) &#123;\n            int i = frame_count++;\n            LOGI(&quot;解码%d帧&quot;, i);\n            ANativeWindow_setBuffersGeometry(nativeWindow, avCodecContext-&gt;width,\n                                             avCodecContext-&gt;height, WINDOW_FORMAT_RGBA_8888);\n            //LOCK\n            ANativeWindow_lock(nativeWindow, &amp;windowBuffer, NULL);\n\n            avpicture_fill((AVPicture *) rgba_frame, windowBuffer.bits, PIX_FMT_RGBA,\n                           avCodecContext-&gt;width,\n                           avCodecContext-&gt;height);\n\n            //fix buffer\n            I420ToARGB(\n                    yuv_frame-&gt;data[0], yuv_frame-&gt;linesize[0],\n                    yuv_frame-&gt;data[2], yuv_frame-&gt;linesize[2],\n                    yuv_frame-&gt;data[1], yuv_frame-&gt;linesize[1],\n                    rgba_frame-&gt;data[0], rgba_frame-&gt;linesize[0],\n                    avCodecContext-&gt;width, avCodecContext-&gt;height);\n\n            //UNLOCK\n            ANativeWindow_unlockAndPost(nativeWindow);\n//            ANativeWindow_release(nativeWindow);\n            usleep(16 * 1000);\n        &#125;\n        av_free_packet(packet);\n    &#125;\n    ANativeWindow_release(nativeWindow);\n    av_frame_free(yuv_frame);\n    av_frame_free(rgba_frame);\n    avcodec_close(avCodec);\n    avcodec_free_context(avCodecContext);\n    avformat_free_context(formatContext);\n    (*env)-&gt;ReleaseStringUTFChars(env, jstr_input, cstr_input);\n\n&#125;自定义 VideoView 继承自 SurfaceView\npublic class VideoView extends SurfaceView &#123;\n    public VideoView(Context context) &#123;\n        super(context);\n        init();\n    &#125;\n\n    public VideoView(Context context, AttributeSet attrs) &#123;\n        super(context, attrs);\n        init();\n    &#125;\n\n    public VideoView(Context context, AttributeSet attrs, int defStyleAttr) &#123;\n        super(context, attrs, defStyleAttr);\n        init();\n    &#125;\n\n    public void init()&#123;\n        //初始化SurfaceView的像素格式\n        SurfaceHolder holder = getHolder();\n        holder.setFormat(PixelFormat.RGBA_8888);\n    &#125;\n&#125;\n","categories":["NDK"],"tags":["Android","NDK","FFmpeg"]},{"title":"二进制中 1 的个数","url":"https://blog.onestravel.cn/20190401/841b9bdfaa71/","content":"13. 二进制中 1 的个数题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。\n解题思路如果一个整数不为0，那么这个整数至少有一位是1。\n如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。\n举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.\n我们发现减1的结果是把最右边的一个1开始的所有位都取反了。\n这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。\n如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.\n那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。\n代码实现java 代码    /**\n     * 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。\n     * n&amp;(n-1)时将 n 的二进制数字中最右侧的1变为0\n     * @param n\n     * @return\n     */\n    public int numberOf1(int n) {\n        int count = 0;\n        while (n != 0) {\n            count++;\n            n &amp;= n - 1;\n        }\n        return count;\n    }\n\n    public static void main(String[] args){\n        System.out.println(numberOf1(5));\n        System.out.println(numberOf1(-7));\n    }\nKotlin 代码    /**\n     * 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。\n     * n&amp;(n-1)时将 n 的二进制数字中最右侧的1变为0\n     * @param n\n     * @return\n     */\n    fun numberOf1(n: Int): Int {\n        var n = n\n        var count = 0\n        while (n != 0) {\n            count++\n            n = n and n - 1\n        }\n        return count\n    }\n\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        println(numberOf1(5))\n        println(numberOf1(-7))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["二进制"]},{"title":"剪绳子","url":"https://blog.onestravel.cn/20190328/4614e995ffc7/","content":"12. 剪绳子题目描述给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n解题思路题目分析：先举几个例子，可以看出规律来。\n\nn = 4 ： 2*2\nn = 5 ： 2*3\nn = 6 ： 3*3\nn = 7 ： 2*2*3 或者4*3\nn = 8 ： 2*3*3\nn = 9 ： 3*3*3\nn = 10：2*2*3*3 或者4*3*3\nn = 11：2*3*3*3\nn = 12：3*3*3*3\nn = 13：2*2*3*3*3 或者4*3*3*3\n\n下面是分析：首先判断k[0]到k[m]可能有哪些数字，实际上只可能是2或者3。\n\n当然也可能有4，但是4=2*2，我们就简单些不考虑了。\n5&lt;2*3,6&lt;3*3,比6更大的数字我们就更不用考虑了，肯定要继续分。\n其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2*2*2&lt;3*3，那么题目就简单了。\n直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。\n由于题目规定m&gt;1，所以2只能是1*1，3只能是2*1，这两个特殊情况直接返回就行了。\n乘方运算的复杂度为：O(logn)，用动态规划来做会耗时比较多。\n\n代码实现java 代码    /**\n     * 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n     *\n     * @param n\n     * @return\n     */\n    public int cutRope(int n) {\n        if (n == 2) {\n            return 1;\n        } else if (n == 3) {\n            return 2;\n        }\n        int mod = n % 3;\n        if (mod == 2) {\n            //除以3后余2，则截成 n/3 段长度为3的绳子后还余长度为2的绳子；\n            //此时相乘，乘积最大\n            //即  2 * 3^(n / 3)\n            return (int) (2 * Math.pow(3, n / 3));\n        }else  if (mod == 1) {\n            //除以3后余1，则截成 n/3 段长度为3的绳子后还余长度为1的绳子；\n            // 乘以长度为1的没有什么变化，则可以取出一段长度为3的绳子，和当前长度为1的绳子，分成两个长度为2的绳子相乘\n            // 即 2 * 2 * 3^(n / 3 - 1)\n            return (int) (2 * 2 * Math.pow(3, (n / 3)-1));\n        }else {//可以被3整除，则可以截成 n/3 段长度为3的绳子，相乘就是 3 的 n/3次幂\n            return (int) (Math.pow(3, n / 3));\n        }\n    }\n\n\n    public static void main(String[] args){\n        System.out.println(cutRope(8));\n        System.out.println(cutRope(9));\n        System.out.println(cutRope(10));\n    }\nKotlin 代码    /**\n     * 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n     *\n     * @param n\n     * @return\n     */\n    fun cutRope(n: Int): Int {\n        if (n == 2) {\n            return 1\n        }\n        if (n == 3) {\n            return 2;\n        }\n        return when (n % 3) {\n            0 -> {//可以被3整除，则可以截成 n/3 段长度为3的绳子，相乘就是 3 的 n/3次幂\n                3.0.pow(n / 3).toInt()\n            }\n            1 -> {//除以3后余1，则截成 n/3 段长度为3的绳子后还余长度为1的绳子；\n                // 乘以长度为1的没有什么变化，则可以取出一段长度为3的绳子，和当前长度为1的绳子，分成两个长度为2的绳子相乘\n                // 即 2 * 2 * 3^(n / 3 - 1)\n                3.0.pow(n / 3 - 1).toInt() * 2 * 2\n            }\n            else -> {\n                //除以3后余2，则截成 n/3 段长度为3的绳子后还余长度为2的绳子；\n                //此时相乘，乘积最大\n                //即  2 * 3^(n / 3)\n                2 * 3.0.pow(n / 3).toInt()\n            }\n        }\n    }\n\n\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        println(cutRope(8))\n        println(cutRope(9))\n        println(cutRope(10))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["最优解"]},{"title":"机器人的运动范围","url":"https://blog.onestravel.cn/20190326/08afff3c39a2/","content":"11.机器人的运动范围本题知识点：数组\n题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？\n解题思路回溯法核心思路：\n\n从(0,0)开始走，每成功走一步标记当前位置为true,然后从当前位置往四个方向探索，返回1 + 4 个方向的探索值之和。\n探索时，判断当前节点是否可达的标准为：\n1）当前节点在矩阵内；\n2）当前节点未被访问过；\n3）当前节点满足limit限制。\n\n\n\n代码实现java 代码    /**\n     * 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？\n     * @param threshold k值\n     * @param rows 行数m\n     * @param cols 列数n\n     * @return\n     */\n    public int movingCount(int threshold, int rows, int cols) {\n        boolean[][] flag = new boolean[rows][cols];\n        return movingStep(threshold, rows, cols, 0, 0, flag);\n    }\n\n    /**\n     * 检测每一步是否可达，如果已经进入过该格子，标志位记为true，为进入过，记为false\n     * @param threshold k值\n     * @param rows 行数m\n     * @param cols 列数n\n     * @param i 当前格子横（行）坐标\n     * @param j 当前格子竖（列）坐标\n     * @param flag 格子是否已经进入过标志数组\n     * @return\n     */\n    public int movingStep(int threshold, int rows, int cols, int i, int j, boolean[][] flag) {\n        if (i &lt; 0 || j &lt; 0 || i >= rows || j >= cols || flag[i][j]) {\n            return 0;\n        }\n        if (numSumByByte(i) + numSumByByte(j) > threshold) {\n            return 0;\n        }\n        flag[i][j] = true;\n        return 1 + movingStep(threshold, rows, cols, i - 1, j, flag)\n                + movingStep(threshold, rows, cols, i + 1, j, flag)\n                + movingStep(threshold, rows, cols, i, j - 1, flag)\n                + movingStep(threshold, rows, cols, i, j + 1, flag);\n\n    }\n\n    /**\n     * 计算每个数的个位数上的值之和\n     * @param num\n     * @return\n     */\n    private int numSumByByte(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args){\n         System.out.println(movingCount(18,50,50));\n    }\nKotlin 代码     /**\n     * 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？\n     * @param threshold k值\n     * @param rows 行数m\n     * @param cols 列数n\n     * @return\n     */\n    fun movingCount(threshold: Int, rows: Int, cols: Int): Int {\n        val flag =\n            Array(rows) { BooleanArray(cols) }\n        return movingStep(threshold, rows, cols, 0, 0, flag)\n    }\n\n    /**\n     * 检测每一步是否可达，如果已经进入过该格子，标志位记为true，为进入过，记为false\n     * @param threshold k值\n     * @param rows 行数m\n     * @param cols 列数n\n     * @param i 当前格子横（行）坐标\n     * @param j 当前格子竖（列）坐标\n     * @param flag 格子是否已经进入过标志数组\n     * @return\n     */\n    fun movingStep(\n        threshold: Int,\n        rows: Int,\n        cols: Int,\n        i: Int,\n        j: Int,\n        flag: Array&lt;BooleanArray>\n    ): Int {\n        if (i &lt; 0 || j &lt; 0 || i >= rows || j >= cols || flag[i][j]) {\n            return 0\n        }\n        if (numSumByByte(i) + numSumByByte(j) > threshold) {\n            return 0\n        }\n        flag[i][j] = true\n        return (1 + movingStep(threshold, rows, cols, i - 1, j, flag)\n                + movingStep(threshold, rows, cols, i + 1, j, flag)\n                + movingStep(threshold, rows, cols, i, j - 1, flag)\n                + movingStep(threshold, rows, cols, i, j + 1, flag))\n    }\n\n    /**\n     * 计算每个数的个位数上的值之和\n     * @param num\n     * @return\n     */\n    private fun numSumByByte(num: Int): Int {\n        var num = num\n        var sum = 0\n        while (num > 0) {\n            sum += num % 10\n            num /= 10\n        }\n        return sum\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        println(movingCount(18,50,50))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["数组","矩阵"]},{"title":"矩阵中的路径","url":"https://blog.onestravel.cn/20190325/332142e2a50e/","content":"10.矩阵中的路径本题知识点：数组\n题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 \n\\begin{bmatrix} a & b & c &e \\\\ s & f & c & s \\\\ a & d & e& e\\\\ \\end{bmatrix}\n矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。\n\n\n\n    a\n    b\n    c\n    e\n\n\n    s\n    f\n    c\n    s\n\n\n    a\n    d\n    e\n    e\n\n\n\n\n\n\n\n解题思路回溯法基本思想：0.根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次1.根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge2.根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组3.确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通4.若n，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的5.下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。6.走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。\n代码实现java 代码    /**\n     * 回溯法查找路径是否存在\n     * @param matrix 矩阵数组\n     * @param rows 矩阵行数\n     * @param cols 矩阵列数\n     * @param str 查找字符串路径数组\n     * @return\n     */\n    public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {\n        //创建和矩阵相同大小的标志位数组\n        boolean[] flag = new boolean[matrix.length];\n        for (int i = 0; i &lt; rows; i++) {\n            for (int j = 0; j &lt; cols; j++) {\n                //查找字符串路径的起始位，开始向四周搜索路径\n                if(judge(matrix, rows, cols, i, j, str, 0, flag)){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * 回溯法查找路径是否存在\n     * @param matrix 矩阵数组\n     * @param rows 矩阵行数\n     * @param cols 矩阵列数\n     * @param i 当前行数坐标\n     * @param j 当前列数坐标\n     * @param str 查找字符串路径数组\n     * @param n 当前字符串数组中查到当前位数\n     * @param flag 标记路径中是否已经进入的标志\n     * @return\n     */\n    public boolean judge(char[] matrix, int rows, int cols, int i, int j, char[] str, int n, boolean[] flag) {\n        //判断当前坐标是否越界，如果越界，则不在矩阵内，返回false\n        if (i &lt; 0 || j &lt; 0 || i >= rows || j >= cols) {\n            return false;\n        }\n        //根据矩阵坐标转换为数组下标\n        int index = i * cols + j;\n        //判断盖数组下标的格子是否已经进入，如果进入，则不能再次进入，返回false\n        if (flag[index]) {\n            return false;\n        }\n        //判断查找的字符串路径当前字符与数组中当前下标的字符是否相同，如果不相同，则当前格子不存在路径，返回false\n        if (str[n] != matrix[index]) {\n            return false;\n        }\n        //判断已经查找到字符串最后一位，则路径存在，返回true\n        if (n + 1 == str.length) {\n            return true;\n        }\n        //当前位置表示当前格子符合字符串查找路径中当当前位置n，将该格子标记为true，避免下一个格子搜索时进入\n        flag[index] = true;\n        //开始搜索字符串查找路径当前位置的下一个字符路径，分布查找当前格子上，下，左，右的格子是否存在下一个字符的路径\n        if (judge(matrix, rows, cols, i - 1, j, str, n + 1, flag)\n                || judge(matrix, rows, cols, i + 1, j, str, n + 1, flag)\n                || judge(matrix, rows, cols, i, j - 1, str, n + 1, flag)\n                || judge(matrix, rows, cols, i, j + 1, str, n + 1, flag)\n        ) {\n            //下一个字符路径存在，则当前格子路径正确，返回true\n            return true;\n        } else {\n            //下一个字符路径不存在，当前格子路径不正确，则将当前格子标志位置为false(回溯),可以允许其他格子检查时进入\n            flag[index] = false;\n            return false;\n        }\n    }\n\n    public static void main(String[] args){\n         char[] matrix = {'a','b','c','e','s','f','c','s','a','d','e','e'};\n        int rows = 3;\n        int cols = 4;\n        char[] str = \"bccfd\".toCharArray();\n        System.out.println(hasPath(matrix,rows,cols,str));\n    }\nKotlin 代码     /**\n     * 回溯法查找路径是否存在\n     * @param matrix 矩阵数组\n     * @param rows 矩阵行数\n     * @param cols 矩阵列数\n     * @param i 当前行数坐标\n     * @param j 当前列数坐标\n     * @param str 查找字符串路径数组\n     * @param n 当前字符串数组中查到当前位数\n     * @param flag 标记路径中是否已经进入的标志\n     * @return\n     */\n    private fun judge(\n        matrix: CharArray,\n        rows: Int,\n        cols: Int,\n        i: Int,\n        j: Int,\n        str: CharArray,\n        n: Int,\n        flag: BooleanArray\n    ): Boolean {\n        //判断当前坐标是否越界，如果越界，则不在矩阵内，返回false\n        if (i &lt; 0 || j &lt; 0 || i >= rows || j >= cols) {\n            return false\n        }\n        //根据矩阵坐标转换为数组下标\n        val index = i * cols + j\n        //判断盖数组下标的格子是否已经进入，如果进入，则不能再次进入，返回false\n        if (flag[index]) {\n            return false\n        }\n        //判断查找的字符串路径当前字符与数组中当前下标的字符是否相同，如果不相同，则当前格子不存在路径，返回false\n        if (str[n] != matrix[index]) {\n            return false\n        }\n        //判断已经查找到字符串最后一位，则路径存在，返回true\n        if (n + 1 == str.size) {\n            return true\n        }\n        //当前位置表示当前格子符合字符串查找路径中当当前位置n，将该格子标记为true，避免下一个格子搜索时进入\n        flag[index] = true\n        //开始搜索字符串查找路径当前位置的下一个字符路径，分布查找当前格子上，下，左，右的格子是否存在下一个字符的路径\n        return if (judge(matrix, rows, cols, i - 1, j, str, n + 1, flag)\n            || judge(matrix, rows, cols, i + 1, j, str, n + 1, flag)\n            || judge(matrix, rows, cols, i, j - 1, str, n + 1, flag)\n            || judge(matrix, rows, cols, i, j + 1, str, n + 1, flag)\n        ) {\n            //下一个字符路径存在，则当前格子路径正确，返回true\n            true\n        } else {\n            //下一个字符路径不存在，当前格子路径不正确，则将当前格子标志位置为false(回溯),可以允许其他格子检查时进入\n            flag[index] = false\n            false\n        }\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        val matrix =\n            charArrayOf('a', 'b', 'c', 'e', 's', 'f', 'c', 's', 'a', 'd', 'e', 'e')\n        val rows = 3\n        val cols = 4\n        val str = \"bccfd\".toCharArray()\n        println(hasPath(matrix, rows, cols, str))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["矩阵"]},{"title":"【FFmpeg】(一) 音视频相关基础知识以及FFmpeg介绍","url":"https://blog.onestravel.cn/20190325/0bf1498a9d8f/","content":"【FFmpeg】(一) 音视频相关基础知识以及FFmpeg介绍一、音视频相关基础知识1、视频播放器原理视频播放器就是将一个封装的格式数据进行解封装，得到对应的音频压缩数据和视频压缩数据，再进行相应的音视频解码，得到音频采样数据和视频采样数据，最后将音频采样数据和视频采样数据同时播放，达到音视频同步。\n\n封装格式数据通常有FLV、MKV、MP4、AVI、RMVB 等等\n录音、录像的实质就是一个压缩采集到的图像或者音频数据的过程，这个过程又称为编码\n播放视频或者音频文件，实质上是一个解压缩的过程，这个过程又称为解码\n\n\n1.1 解封装将封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起，输出特定编码格式的视频码流和A音频码流。\n1.2 解码1.2.1 音频压缩数据解码一般我们常见的音频压缩编码标准包含AAC，MP3，AC-3，WMA 等等；通过解码将压缩编码的音频数据输出成为非压缩的音频采样数据，例如PCM数据\n\nAAC：数据由大小不固定的ADTS构成\nPCM：单声道的情况下按照顺序存储每个采样点的数据；双声道的情况下按照 “左右、左右”的顺序存储每个采样点两个声道的数据\n\n采样率：也称为采样速度或者采样率，定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹（Hz）来表示。采样频率的倒数是采样周期或者叫作采样时间，它是采样之间的时间间隔。通俗的讲采样频率是指计算机每秒钟采集多少个信号样本。\n1.2.2 视频压缩数据解码一般我们常见的视频的压缩编码标准则包含H.264，MPEG2，VC-1等等；压缩编码的视频数据输出成为视频像素数据（非压缩的颜色数据），例如YUV(YUV420P,YUV422P,YUV444P;最常见为YUV420P)，RGB(RGB24,RGB32)等等。Y：亮度，U：色度，V：浓度\n\nH.264：数据由大学不固定的NALU构成，最常见情况下，1个NALU存储了1帧画面的压缩编码后的数据\n\n1.3 音视频同步根据解封装模块过程中获取到的参数信息，同步解码得到的音频和视频数据，并将音频和视频数据送至系统的声卡和显卡播放出来。\n二、FFmpeg 介绍1、定义FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的。\n2、FFmpeg 命令2.1 视频格式转换命令\n\n\n命令参数\n说明\n\n\n\n-i\n源文件\n\n\n-o\n输出文件\n\n\n```\n\n\n\n//进入到FFmpeg 的 bin 目录下执行以下命令\n\n\n\nffmpeg -i d:\\input.mp4 -o d:\\output.avi\n\n\n\n```\n\n\n\n2.2 视频转 Gif 命令\n\n\n命令参数\n说明\n\n\n\n-i\n源文件\n\n\n-ss\n从多少秒开始\n\n\n-t\n到多少秒介绍\n\n\n-s\n图像的尺寸大小\n\n\n-b:v\n码率\n\n\n//进入到FFmpeg 的 bin 目录下执行以下命令\nffmpeg -ss 5 -t 15 -i d:\\\\input.mp4 -s 300x200 -b:v 1500K D:\\\\video_gif.gif三、使用 visual studio 编译 FFmpeg*注：项目根目录即创建cpp源文件所在目录\n步骤：\n\n在【FFmpeg官网】下载 FFmpeg 在windows 下的开发(dev)版本 ffmpeg-XXX-win64-dev\n在 visual studio上创建一个C++的空项目\n将下载好的 FFmpeg 包解压后，复制 include 和 lib 文件夹到刚刚创建好的项目根路径下\n下载 FFmpeg 在windows 下的 Shared 版本ffmpeg-XXX-win64-shared,解压后赋值 bin 目录下的动态库(.dll)文件到项目根目录下\n修改项目的配置管理器中的活动姐姐方案平台为X64(根据自己操作系统位数更改)\n在 visual studio 中项目右键，点击【属性（ALT+Enter）】,选中【C++目录】，右侧的【包含目录】，点击编辑，增加刚刚复制到根目录下的 include 目录\n\n\n\n点击【属性】中的【链接器】，在右侧选中【附加库目录】，点击编辑，增加刚刚复制到根目录下的 lib 目录\n\n\n\n点击【属性】中的【链接器】下的【输入】，在右侧选中【附加依赖库】，点击编辑，增加刚刚复制到根目录下的 lib 目录下所有的 .lib 文件\n\navcodec.lib\navdevice.lib\navfilter.lib\navformat.lib\navutil.lib\npostproc.lib\nswresample.lib\nswscale.lib\n\n在项目中添加一个.cpp的源文件，如：my_ffmpeg.cpp\n\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\n//C和C++混编，指示编译器按照C语言进行编译\nextern &quot;C&quot;&#123;\n//引入ffmpeg的头文件\n#include &quot;libavcodec/avcodec.h&quot;\n&#125;;\n\nvoid main() &#123;\n    //输出 ffmpeg 的配置\n    printf(&quot;%s\\n&quot;,avcodec_configuration());\n\n    getchar();\n&#125;四、使用 Linux主机 编译 FFmpeg1、编译前准备\n阿里云主机(Ubuntu/centos)\n客户端主机安装XShell，Xftp\n\n2、编译\n使用Xftp将NDK、FFmpeg 上传到阿里云主机\n安装vim 编辑器\n\n$ apt-get update\n$ sudo apt-get install vim-gtk\nNDK 安装，配置环境变量\n\n//给文件授权可执行\n$ chmod 777 -R android-ndk-r10e-linux-x86_64.bin\n//执行文件\n$ ./android-ndk-r10e-linux-x86_64.bin\n//配置环境变量\n$ vim ~/.bashrc\n\n//增加环境变量\nexport NDKROOT=/home/study/ndk/android-ndk-r10e\nexport PATH=$NDKROOT:$PATH\n\n$ source ~/.bashrc\n//查看ndk版本号\n$ ndk-build -v\n解压 FFmpeg \n\n$ tar -xzvf ffmpeg-4.1.2.tar.gz \n编译 FFmpeg ,实现 Shell 脚本文件android_build.sh\n\n#!/bin/bash\nmake clean\nexport NDK=/home/study/ndk/android-ndk-r10e\nexport SYSROOT=$NDK/platforms/android-9/arch-arm/\nexport TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.8/prebuilt/linux-x86_64\nexport CPU=arm\nexport PREFIX=$(pwd)/android/$CPU\nexport ADDI_CFLAGS=&quot;-marm&quot;\n\n./configure --target-os=linux \\\n--prefix=$PREFIX --arch=arm \\\n--disable-doc \\\n--enable-shared \\\n--disable-static \\\n--disable-yasm \\\n--disable-symver \\\n--enable-gpl \\\n--disable-ffmpeg \\\n--disable-ffplay \\\n--disable-ffprobe \\\n--disable-ffserver \\\n--disable-doc \\\n--disable-symver \\\n--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\\n--enable-cross-compile \\\n--sysroot=$SYSROOT \\\n--extra-cflags=&quot;-Os -fpic $ADDI_CFLAGS&quot; \\\n--extra-ldflags=&quot;$ADDI_LDFLAGS&quot; \\\n$ADDITIONAL_CONFIGURE_FLAG\nmake clean\nmake\nmake install\n执行脚本文件\n./android_build.sh五、使用编译后形成的include和lib目录实现Android NDK 解码功能步骤：\n在Android studio上创建一个支持C++的Android项目\n将生成的 include 和 lib 复制到 cpp 目录下，更改CMakeLists.txt文件\n\ncmake_minimum_required(VERSION 3.4.1)\nset(DISTRIBUTION_DIR $&#123;CMAKE_SOURCE_DIR&#125;/../jniLibs/)\n\nadd_library( # Sets the name of the library.\n        ffmpeg-video\n        SHARED\n        ffmpeg_video.c)\n\n\n# 编解码(最重要的库)\nadd_library(\n        avcodec\n        SHARED\n        IMPORTED\n)\n\n#指定编码库的位置\nset_target_properties(\n        avcodec\n        PROPERTIES IMPORTED_LOCATION\n        $&#123;DISTRIBUTION_DIR&#125;/$&#123;ANDROID_ABI&#125;/libavcodec-56.so\n)\n\n#设备信息\nadd_library(\n        avdevice\n        SHARED\n        IMPORTED\n)\n\n#指定设备信息的位置\nset_target_properties(\n        avdevice\n        PROPERTIES IMPORTED_LOCATION\n        $&#123;DISTRIBUTION_DIR&#125;/$&#123;ANDROID_ABI&#125;/libavdevice-56.so\n)\n\n#滤镜特效处理库\nadd_library(\n        avfilter\n        SHARED\n        IMPORTED\n)\n\n#指定滤镜库位置\nset_target_properties(\n        avfilter\n        PROPERTIES IMPORTED_LOCATION\n        $&#123;DISTRIBUTION_DIR&#125;/$&#123;ANDROID_ABI&#125;/libavfilter-5.so\n)\n\n#封装格式处理库\nadd_library(\n        avformat\n        SHARED\n        IMPORTED\n)\n\n#指定格式库路径\nset_target_properties(\n        avformat\n        PROPERTIES IMPORTED_LOCATION\n        $&#123;DISTRIBUTION_DIR&#125;/$&#123;ANDROID_ABI&#125;/libavformat-56.so\n)\n\n#工具库(大部分库都需要这个库的支持)\nadd_library(\n        avutil\n        SHARED\n        IMPORTED\n)\n\n#指定工具库路径\nset_target_properties(\n        avutil\n        PROPERTIES IMPORTED_LOCATION\n        $&#123;DISTRIBUTION_DIR&#125;/$&#123;ANDROID_ABI&#125;/libavutil-54.so\n)\n\n#后期处理\nadd_library(\n        postproc\n        SHARED\n        IMPORTED\n)\n\n#指定后期处理库路径\nset_target_properties(\n        postproc\n        PROPERTIES IMPORTED_LOCATION\n        $&#123;DISTRIBUTION_DIR&#125;/$&#123;ANDROID_ABI&#125;/libpostproc-53.so\n)\n\n#数据格式转换库\nadd_library(\n        swresample\n        SHARED\n        IMPORTED\n)\n\n#指定库位置\nset_target_properties(\n        swresample\n        PROPERTIES IMPORTED_LOCATION\n        $&#123;DISTRIBUTION_DIR&#125;/$&#123;ANDROID_ABI&#125;/libswresample-1.so\n)\n\n#视频像素数据格式转换\nadd_library(\n        swscale\n        SHARED\n        IMPORTED\n)\n#视频像素格式转换库位置\nset_target_properties(\n        swscale\n        PROPERTIES IMPORTED_LOCATION\n        $&#123;DISTRIBUTION_DIR&#125;/$&#123;ANDROID_ABI&#125;/libswscale-3.so\n)\n\n\nfind_library(\n        android-lib\n        android\n)\n\nfind_library(\n        log-lib\n        log\n)\n\nfind_library(\n        jnigraphics-lib\n        jnigraphics\n)\n\n# 将预构建库与本地库相连\ntarget_link_libraries(\n        ffmpeg-video\n        avcodec\n        avdevice\n        avfilter\n        avformat\n        avutil\n        postproc\n        swresample\n        swscale\n        $&#123;android-lib&#125;\n        $&#123;jnigraphics-lib&#125;\n        $&#123;log-lib&#125;\n)\n编写本地 native 方法，编译生成.h头文件\n\npackage cn.onestravel.ndk.ffmpegdecodedemo;\n\n\npublic class VideoUtils &#123;\n    static &#123;\n        System.loadLibrary(&quot;avutil-54&quot;);\n        System.loadLibrary(&quot;avcodec-56&quot;);\n        System.loadLibrary(&quot;avdevice-56&quot;);\n        System.loadLibrary(&quot;avfilter-5&quot;);\n        System.loadLibrary(&quot;avformat-56&quot;);\n        System.loadLibrary(&quot;postproc-53&quot;);\n        System.loadLibrary(&quot;swresample-1&quot;);\n        System.loadLibrary(&quot;swscale-3&quot;);\n        System.loadLibrary(&quot;ffmpeg-video&quot;);\n    &#125;\n    public native static void decode(String input,String output);\n&#125;\n\n对编译生成.h头文件进行实现，创建ffmpeg_video.c\n\n//\n// Created by Administrator on 2019/3/27.\n//\n\n//\n// Created by Administrator on 2019/3/26.\n//\n#include &lt;android/log.h&gt;\n#include &quot;cn_onestravel_ndk_ffmpegdecodedemo_VideoUtils.h&quot;\n//编码\n#include &quot;include/libavcodec/avcodec.h&quot;\n//封装格式处理\n#include &quot;include/libavformat/avformat.h&quot;\n//像素处理\n#include &quot;include/libswscale/swscale.h&quot;\n#include &quot;include/libavutil/avutil.h&quot;\n#include &quot;include/libavutil/frame.h&quot;\n\n#define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,&quot;FFMPEG&quot;,FORMAT,##__VA_ARGS__);\n#define LOGE(FORMAT,...) __android_log_print(ANDROID_LOG_ERROR,&quot;FFMPEG&quot;,FORMAT,##__VA_ARGS__);\n\n\n/*\n * Class:     cn_onestravel_ndk_ffmpegdecode_VoideUtils\n * Method:    decode\n * Signature: (Ljava/lang/String;Ljava/lang/String;)V\n */\nJNIEXPORT void JNICALL Java_cn_onestravel_ndk_ffmpegdecodedemo_VideoUtils_decode\n  (JNIEnv * env, jclass jcls, jstring input_jstr, jstring output_jstr)&#123;\n      //需要转码的视频文件(输入的视频文件)\n      const char* input_cstr = (*env)-&gt;GetStringUTFChars(env,input_jstr,NULL);\n      const char* output_cstr = (*env)-&gt;GetStringUTFChars(env,output_jstr,NULL);\n\n      //1.注册所有组件\n      av_register_all();\n\n      //封装格式上下文，统领全局的结构体，保存了视频文件封装格式的相关信息\n      AVFormatContext *pFormatCtx = avformat_alloc_context();\n\n      //2.打开输入视频文件\n      if (avformat_open_input(&amp;pFormatCtx, input_cstr, NULL, NULL) != 0)\n      &#123;\n          LOGE(&quot;%s&quot;,&quot;无法打开输入视频文件&quot;);\n          return;\n      &#125;\n\n      //3.获取视频文件信息\n      if (avformat_find_stream_info(pFormatCtx,NULL) &lt; 0)\n      &#123;\n          LOGE(&quot;%s&quot;,&quot;无法获取视频文件信息&quot;);\n          return;\n      &#125;\n\n      //获取视频流的索引位置\n      //遍历所有类型的流（音频流、视频流、字幕流），找到视频流\n      int v_stream_idx = -1;\n      int i = 0;\n      //number of streams\n      for (; i &lt; pFormatCtx-&gt;nb_streams; i++)\n      &#123;\n          //流的类型\n          if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)\n          &#123;\n              v_stream_idx = i;\n              break;\n          &#125;\n      &#125;\n\n      if (v_stream_idx == -1)\n      &#123;\n          LOGE(&quot;%s&quot;,&quot;找不到视频流\\n&quot;);\n          return;\n      &#125;\n\n      //只有知道视频的编码方式，才能够根据编码方式去找到解码器\n      //获取视频流中的编解码上下文\n      AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[v_stream_idx]-&gt;codec;\n      //4.根据编解码上下文中的编码id查找对应的解码\n      AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);\n      //（迅雷看看，找不到解码器，临时下载一个解码器）\n      if (pCodec == NULL)\n      &#123;\n          LOGE(&quot;%s&quot;,&quot;找不到解码器\\n&quot;);\n          return;\n      &#125;\n\n      //5.打开解码器\n      if (avcodec_open2(pCodecCtx,pCodec,NULL)&lt;0)\n      &#123;\n          LOGE(&quot;%s&quot;,&quot;解码器无法打开\\n&quot;);\n          return;\n      &#125;\n\n      //输出视频信息\n      LOGI(&quot;视频的文件格式：%s&quot;,pFormatCtx-&gt;iformat-&gt;name);\n      LOGI(&quot;视频时长：%ld&quot;, (pFormatCtx-&gt;duration)/1000000);\n      LOGI(&quot;视频的宽高：%d,%d&quot;,pCodecCtx-&gt;width,pCodecCtx-&gt;height);\n      LOGI(&quot;解码器的名称：%s&quot;,pCodec-&gt;name);\n\n      //准备读取\n      //AVPacket用于存储一帧一帧的压缩数据（H264）\n      //缓冲区，开辟空间\n      AVPacket *packet = (AVPacket*)av_malloc(sizeof(AVPacket));\n\n      //AVFrame用于存储解码后的像素数据(YUV)\n      //内存分配\n      AVFrame *pFrame = av_frame_alloc();\n      //YUV420\n      AVFrame *pFrameYUV = av_frame_alloc();\n      //只有指定了AVFrame的像素格式、画面大小才能真正分配内存\n      //缓冲区分配内存\n      uint8_t *out_buffer = (uint8_t *)av_malloc(avpicture_get_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height));\n      //初始化缓冲区\n      avpicture_fill((AVPicture *)pFrameYUV, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height);\n\n      //用于转码（缩放）的参数，转之前的宽高，转之后的宽高，格式等\n      struct SwsContext *sws_ctx = sws_getContext(pCodecCtx-&gt;width,pCodecCtx-&gt;height,pCodecCtx-&gt;pix_fmt,\n          pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P,\n          SWS_BICUBIC, NULL, NULL, NULL);\n\n\n      int got_picture, ret;\n\n      FILE *fp_yuv = fopen(output_cstr, &quot;wb+&quot;);\n\n      int frame_count = 0;\n\n      //6.一帧一帧的读取压缩数据\n      while (av_read_frame(pFormatCtx, packet) &gt;= 0)\n      &#123;\n          //只要视频压缩数据（根据流的索引位置判断）\n          if (packet-&gt;stream_index == v_stream_idx)\n          &#123;\n              //7.解码一帧视频压缩数据，得到视频像素数据\n              ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet);\n              if (ret &lt; 0)\n              &#123;\n                  LOGE(&quot;%s&quot;,&quot;解码错误&quot;);\n                  return;\n              &#125;\n\n              //为0说明解码完成，非0正在解码\n              if (got_picture)\n              &#123;\n                  //AVFrame转为像素格式YUV420，宽高\n                  //2 6输入、输出数据\n                  //3 7输入、输出画面一行的数据的大小 AVFrame 转换是一行一行转换的\n                  //4 输入数据第一列要转码的位置 从0开始\n                  //5 输入画面的高度\n                  sws_scale(sws_ctx, pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height,\n                      pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);\n\n                  //输出到YUV文件\n                  //AVFrame像素帧写入文件\n                  //data解码后的图像像素数据（音频采样数据）\n                  //Y 亮度 UV 色度（压缩了） 人对亮度更加敏感\n                  //U V 个数是Y的1/4\n                  int y_size = pCodecCtx-&gt;width * pCodecCtx-&gt;height;\n                  fwrite(pFrameYUV-&gt;data[0], 1, y_size, fp_yuv);\n                  fwrite(pFrameYUV-&gt;data[1], 1, y_size / 4, fp_yuv);\n                  fwrite(pFrameYUV-&gt;data[2], 1, y_size / 4, fp_yuv);\n\n                  frame_count++;\n                  LOGI(&quot;解码第%d帧&quot;,frame_count);\n              &#125;\n          &#125;\n\n          //释放资源\n          av_free_packet(packet);\n      &#125;\n\n      fclose(fp_yuv);\n\n      (*env)-&gt;ReleaseStringUTFChars(env,input_jstr,input_cstr);\n      (*env)-&gt;ReleaseStringUTFChars(env,output_jstr,output_cstr);\n\n      av_frame_free(&amp;pFrame);\n\n      avcodec_close(pCodecCtx);\n\n      avformat_free_context(pFormatCtx);\n\n  &#125;\nActivity 实现\n\npublic class MainActivity extends AppCompatActivity &#123;\n\n\n    private boolean permission;\n    private VideoThread videoThread;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) &#123;\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        requestPermission();\n        videoThread = new VideoThread();\n    &#125;\n\n    /**\n     * 获取权限\n     */\n    private void requestPermission() &#123;\n        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;\n            String[] perms = &#123;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&#125;;\n            if (checkSelfPermission(perms[0]) == PackageManager.PERMISSION_DENIED) &#123;\n                permission = false;\n                requestPermissions(perms, 200);\n            &#125; else &#123;\n                permission = true;\n            &#125;\n        &#125;\n    &#125;\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n        if (requestCode == 200) &#123;\n            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;\n                permission = true;\n            &#125;\n        &#125;\n    &#125;\n\n    public void decode(View view) &#123;\n        if (!permission) &#123;\n            Toast.makeText(this, &quot;请允许存储权限&quot;, Toast.LENGTH_SHORT).show();\n            requestPermission();\n            return;\n        &#125;\n        if (videoThread == null) &#123;\n            videoThread = new VideoThread();\n        &#125;\n        try &#123;\n            if(!videoThread.isAlive()) &#123;\n                videoThread.start();\n            &#125;\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n\n    &#125;\n\n\n    @Override\n    protected void onDestroy() &#123;\n        videoThread = null;\n        super.onDestroy();\n    &#125;\n\n    public static class VideoThread extends Thread &#123;\n        @Override\n        public void run() &#123;\n            super.run();\n            String input = Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/input.mp4&quot;;\n            String output = Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/out.yuv&quot;;\n            VideoUtils.decode(input, output);\n            Log.i(&quot;Activity&quot;,&quot;编码完成&quot;);\n        &#125;\n    &#125;\n&#125;\n\n\n运行程序，安装到手机，进行解码成 yuv\n\n","categories":["NDK"],"tags":["Android","NDK","FFmpeg"]},{"title":"旋转数组的最小数字","url":"https://blog.onestravel.cn/20190320/0aa2fc6b4c9c/","content":"9. 旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。\nNOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n解题思路该题目考察的是使用二分法开实现查找，中间位置：mid = start + (end - start)/2\n需要考虑三种情况：\n1.中间位数值大于末尾数值（ array[mid] &gt; array[end]）:出现这种情况的array类似&#123;3,4,5,6,1,2&#125;，现在最小数字一定在mid的右边。则:start = mid + 1\n\n中间位数值等于末尾数值（array[mid] == array[high]):出现这种情况的array类似&#123;1,0,1,1,1&#125; 或者&#123;1,1,1,0,1&#125;，现在最小数值不好确定是在mid左边或者右边，则将右侧末尾位置逐渐缩小，继续检测high = high - 1\n中间位数值小于末尾位数值（array[mid] &lt; array[high]）:出现这种情况可以确定最小数字一定在mid的左边（或者就是mid位置的值），则：high = mid\n\n代码实现java 代码    /**\n     * 查找旋转数组中的最小值\n     * @param array 旋转数组\n     * @return 数组中的最小值\n     */\n    private int minNumberInRotateArray(int[] array) {\n        if (array == null || array.length == 0) {\n            return -1;\n        }\n        if (array.length == 1) {\n            return array[0];\n        }\n        int start = 0;\n        int end = array.length - 1;\n        while (start &lt; end) {\n            int mid = start + (end - start) / 2;\n            if ( array[mid] > array[end]) {\n                start = mid + 1;\n            }else if(array[mid] == array[end]){\n                end--;\n            }else {\n                end = mid;\n            }\n        }\n        return array[start];\n    }\n\n    public static void main(String[] args){\n        int[] arr = {3,4,5,6,1,2};\n        System.out.println(minNumberInRotateArray(arr));\n    }\nKotlin 代码     /**\n     * 查找旋转数组中的最小值\n     * @param array 旋转数组\n     * @return 数组中的最小值\n     */\n    private fun minNumberInRotateArray(array: IntArray?): Int {\n        if (array == null || array.isEmpty()) {\n            return -1\n        }\n        if (array.size == 1) {\n            return array[0]\n        }\n        var start = 0\n        var end = array.size - 1\n        while (start &lt; end) {\n            val mid = start + (end - start) / 2\n            when {\n                array[mid] > array[end] -> {\n                    start = mid + 1\n                }\n                array[mid] == array[end] -> {\n                    end--\n                }\n                else -> {\n                    end = mid\n                }\n            }\n        }\n        return array[start]\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        val arr = intArrayOf(3,4,5,6,1,2)\n        println(minNumberInRotateArray(arr))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["数组"]},{"title":"AndroidStudio下集成Fmod，实现仿QQ变声效果（二）","url":"https://blog.onestravel.cn/20190318/22f45dcc429a/","content":"AndroidStudio下集成Fmod，实现仿QQ变声效果（二）前言前一篇博客，我们简单了解了一下 fmod 音频引擎，实现了使用 fmod 来进行音频播放，今天我们在上一个项目的基础上来实现仿QQ变声的效果\n一、Android 布局及点击事件实现1、页面布局简单的进行页面布局，有两个布局，一个是录音界面，长按按钮录音，显示录音时长；另一个是录音完成之后，对声音进行音效处理的界面，包含原声、萝莉、大叔、搞怪、空灵、惊悚六个按钮，并添加了一个返回重新录音的按钮。界面效果如下：\n\n\n2、长按录音事件在这里，我使用了一个录音的工具类，然后处理录音按钮的触摸事件，判断按下和松开的事件，来进行录音，需要录音和存储权限（注意6.0以上动态检查权限，7.0的文件读取权限）\n在使用录音文件播放的时候，第一次是录音生成amr文件，是压缩后的文件，导致在使用 fmod 处理音效以及播放时失败，不能播放出声音，最后换成mav文件，在可以进行音效处理。\n2.1 权限判断判断是否获取了录音权限和文件存储权限\n    /**\n     * 获取权限\n     */\n    private void requestPermission() &#123;\n        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;\n            String[] perms = &#123;&quot;android.permission.RECORD_AUDIO&quot;, &quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&#125;;\n            if (checkSelfPermission(perms[0]) == PackageManager.PERMISSION_DENIED ||\n                    checkSelfPermission(perms[1]) == PackageManager.PERMISSION_DENIED) &#123;\n                permission = false;\n                requestPermissions(perms, 200);\n            &#125; else &#123;\n                permission = true;\n            &#125;\n        &#125;\n    &#125;\n2.2 处理长按录音效果\n    public class MyHandler extends Handler &#123;\n        @Override\n        public void handleMessage(Message msg) &#123;\n            super.handleMessage(msg);\n            switch (msg.what) &#123;\n                case RECORD_START:\n                    try &#123;\n                        audioRecordUtils.startRecordAndFile();\n                        recording = true;\n                    &#125; catch (Exception e) &#123;\n                        e.printStackTrace();\n                        recording = false;\n                        requestPermission();\n                    &#125;\n                    break;\n                case RECORD_FINISH:\n                    recording = false;\n                    audioRecordUtils.stopRecordAndFile();\n                    break;\n                case RECORD_CANCEL:\n                    audioRecordUtils.stopRecordAndFile();\n                    recording = false;\n                    break;\n            &#125;\n        &#125;\n    &#125;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) &#123;\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        org.fmod.FMOD.init(this);\n        audioRecordUtils = AudioRecordUtils.getInstance();\n        audioRecordUtils.setOnAudioStatusUpdateListener(this);\n        recordBtn = findViewById(R.id.recordBtn);\n        recordLl = findViewById(R.id.recordLl);\n        recordTimeTv = findViewById(R.id.recordTimeTv);\n        recordBtn.setOnTouchListener(this);\n        effectUtils = new EffectUtils();\n        requestPermission();\n    &#125;\n\n    @Override\n    public boolean onTouch(View view, MotionEvent motionEvent) &#123;\n        switch (motionEvent.getAction()) &#123;\n            case MotionEvent.ACTION_DOWN:\n                if (permission) &#123;\n                    handler.sendEmptyMessage(RECORD_START);\n                &#125; else &#123;\n                    Toast.makeText(this, &quot;请先同意录音和存储功能权限后使用&quot;, Toast.LENGTH_SHORT).show();\n                    requestPermission();\n                &#125;\n                break;\n            case MotionEvent.ACTION_UP:\n                if (recording) &#123;\n                    if (mTime &lt; 1000) &#123;\n                        handler.sendEmptyMessage(RECORD_CANCEL);\n                    &#125;\n\n                    handler.sendEmptyMessage(RECORD_FINISH);\n                &#125; else &#123;\n                    super.onTouchEvent(motionEvent);\n                &#125;\n                break;\n        &#125;\n        return true;\n    &#125;\n\n    /**\n     * 录音中\n     */\n     @Override\n    public void onUpdate(double db, AudioRecordUtils.RecordTimes times) &#123;\n        this.mTime = times.getTime();\n        recordTimeTv.setText(&quot;... &quot; + times.getFormatTime(&quot;mm:ss&quot;) + &quot; ...&quot;);\n    &#125;\n\n\n\n    /**\n     * 录音完成\n     */\n    @Override\n    public void onFinish(float seconds, String filePath) &#123;\n        recordFilePath = filePath;\n        recordLl.setVisibility(View.GONE);\n    &#125;\n二、NDK实现音效1、native 方法声明创建 org.fmod.core.EffectUtils.java 文件，声明音效变换的 native 方法，并且定义音效类型常量\n    public static final int MODE_NORMAL = 0;\n    public static final int MODE_LUOLI = 1;\n    public static final int MODE_DASHU = 2;\n    public static final int MODE_GAOGUAI = 3;\n    public static final int MODE_KONGLING = 4;\n    public static final int MODE_JINGSONG = 5;\n     /**\n     * 音效处理 native 方法\n     * @param path 音频源文件路径\n     * @param mode 特效模式\n     */\n    public native void effect(String path,int mode);2、生成头文件,处理Android页面的点击事件进入app/src/main/java目录下使用javah命令将创建好的org.fmod.core.EffectUtils.java 编译生成.h 头文件;并将该头文件移动到 cpp 目录下\njavah -encoding utf-8 org.fmod.core.EffectUtilsAndroid 页面点击事件\n    /**\n     * 按钮点击事件\n     * @param view\n     */\n    public void onClick(View view) &#123;\n        switch (view.getId()) &#123;\n            case R.id.reRecordTv:\n                recordTimeTv.setText(&quot;长按开始录音&quot;);\n                recordLl.setVisibility(View.VISIBLE);\n                break;\n            case R.id.normalLL:\n            effectUtils.effect(recordFilePath,EffectUtils.MODE_NORMAL);\n                break;\n            case R.id.luoliLL:\n                effectUtils.effect(recordFilePath,EffectUtils.MODE_LUOLI);\n                break;\n            case R.id.dashuLL:\n                effectUtils.effect(recordFilePath,EffectUtils.MODE_DASHU);\n                break;\n            case R.id.gaoguaiLL:\n                effectUtils.effect(recordFilePath,EffectUtils.MODE_GAOGUAI);\n                break;\n            case R.id.konglingLL:\n                effectUtils.effect(recordFilePath,EffectUtils.MODE_KONGLING);\n                break;\n            case R.id.jingsongLL:\n                effectUtils.effect(recordFilePath,EffectUtils.MODE_JINGSONG);\n                break;\n        &#125;\n    &#125;3、native 实现在 cpp 目录下创建 effect.cpp 文件，来实现 native 方法，并将 CMakeLists.txt 中的配置稍作修改\nCMakeLists.txt\ncmake_minimum_required(VERSION 3.4.1)\n\nset(distribution_DIR $&#123;PROJECT_SOURCE_DIR&#125;../../jniLibs)\ninclude_directories(src/main/cpp/inc)\n\nadd_library( effect\n        SHARED\n        effect.cpp)\n\nadd_library( fmod\n        SHARED\n        IMPORTED )\nset_target_properties( fmod\n        PROPERTIES IMPORTED_LOCATION\n        $&#123;distribution_DIR&#125;/$&#123;ANDROID_ABI&#125;/libfmod.so)\n\nadd_library( fmodL\n        SHARED\n        IMPORTED )\nset_target_properties( fmodL\n        PROPERTIES IMPORTED_LOCATION\n        $&#123;distribution_DIR&#125;/$&#123;ANDROID_ABI&#125;/libfmodL.so )\n\nfind_library( \n        log-lib\n        log)\n\ntarget_link_libraries( effect\n        fmod\n        fmodL\n        $&#123;log-lib&#125; )\neffect.cpp \n\n#include &quot;org_fmod_core_EffectUtils.h&quot;\n#include &quot;inc/fmod.h&quot;\n#include &quot;inc/fmod.hpp&quot;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;android/log.h&gt;\n\n#define LOGI(FORMAT, ...) __android_log_print(ANDROID_LOG_INFO,&quot;FILE_PATCH&quot;,FORMAT,__VA_ARGS__);\n#define LOGE(FORMAT, ...) __android_log_print(ANDROID_LOG_ERROR,&quot;FILE_PATCH&quot;,FORMAT,__VA_ARGS__);\n\nJNIEXPORT void JNICALL Java_org_fmod_core_EffectUtils_effect\n        (JNIEnv *env, jobject jobj, jstring j_file_path, jint j_mode) &#123;\n    //路径转换\n    const char *file_path = env-&gt;GetStringUTFChars(j_file_path, NULL);\n    bool playing = true;\n    //加载音频文件\n    FMOD::System *system;\n    FMOD::Sound *sound;\n    FMOD::Channel *channel;\n    FMOD::DSP *dsp;\n    float frequency;\n    try &#123;\n        //初始化\n        System_Create(&amp;system);\n        system-&gt;init(32, FMOD_INIT_NORMAL, NULL);\n        LOGI(&quot;%s&quot;, file_path);\n        //加载录音文件到 sound\n        system-&gt;createSound(file_path, FMOD_DEFAULT,NULL, &amp;sound);\n        //播放音频文件\n        system-&gt;playSound(sound, 0, false, &amp;channel);\n        //播放过程中实现不同的音效配置\n        //在fmod中，处理音效就是更改channel（音轨）\n        switch (j_mode) &#123;\n            case org_fmod_core_EffectUtils_MODE_NORMAL:\n                //无需处理\n                LOGI(&quot;%s&quot;, &quot;正常播放&quot;);\n\n                break;\n            case org_fmod_core_EffectUtils_MODE_LUOLI:\n                //女声为高声，需要将声音提高\n                //DSP 中定义了一些对声音处理的特效，\n                system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);\n                dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, 2.5);\n                channel-&gt;addDSP(0, dsp);\n                LOGI(&quot;%s&quot;, &quot;萝莉&quot;)\n                break;\n            case org_fmod_core_EffectUtils_MODE_DASHU:\n                //大神为高声，需要将声音音效降低\n                //DSP 中定义了一些对声音处理的特效，\n                system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);\n                dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, 0.6);\n                channel-&gt;addDSP(0, dsp);\n                LOGI(&quot;%s&quot;, &quot;大叔&quot;)\n                break;\n            case org_fmod_core_EffectUtils_MODE_GAOGUAI:\n                //搞怪\n                //提高说话的速度\n                channel-&gt;getFrequency(&amp;frequency);\n                frequency = frequency * 1.6;\n                channel-&gt;setFrequency(frequency);\n                LOGI(&quot;%s&quot;, &quot;搞怪&quot;)\n                break;\n            case org_fmod_core_EffectUtils_MODE_KONGLING:\n                //空灵就是产生回声，外加一点低音\n                system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);\n                dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, 0.9);\n                channel-&gt;addDSP(0, dsp);\n                system-&gt;createDSPByType(FMOD_DSP_TYPE_ECHO, &amp;dsp);\n                dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_DELAY, 350);\n                dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_FEEDBACK, 15);\n                channel-&gt;addDSP(1, dsp);\n                LOGI(&quot;%s&quot;, &quot;空灵&quot;)\n                break;\n            case org_fmod_core_EffectUtils_MODE_JINGSONG:\n                //惊悚\n                system-&gt;createDSPByType(FMOD_DSP_TYPE_TREMOLO, &amp;dsp);\n                dsp-&gt;setParameterFloat(FMOD_DSP_TREMOLO_DEPTH, 0.5);\n                channel-&gt;addDSP(0,dsp);\n                LOGI(&quot;%s&quot;, &quot;惊悚&quot;)\n                break;\n            default:\n                break;\n\n        &#125;\n\n    &#125; catch (...) &#123;\n        LOGE(&quot;%s&quot;, &quot;effect error&quot;);\n        goto end;\n    &#125;\n    //更新状态\n    system-&gt;update();\n    //判断是否在播放\n    while (playing) &#123;\n        LOGI(&quot;%s,%d&quot;, &quot;playing&quot;,playing)\n        channel-&gt;isPlaying(&amp;playing);\n        usleep(1 * 1000 * 1000);\n        LOGI(&quot;%s,%d&quot;, &quot;playing&quot;,playing)\n    &#125;\n\n    goto end;\n    //结束，释放资源\n    end:\n    env-&gt;ReleaseStringUTFChars(j_file_path, file_path);\n    sound-&gt;release();\n    system-&gt;close();\n    system-&gt;release();\n&#125;4、附表4.1 DSP_TYPE 类型说明在创建DSP时，system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);  需要传递FMOD_DSP_TYPE,下面介绍一下DSP_TYPE 类型类型名称 | 说明— | —FMOD_DSP_TYPE_UNKNOWN | 此单元是通过非FMOD插件创建的，因此具有未知目的。FMOD_DSP_TYPE_MIXER | 此单元除了接收输入并将它们混合在一起然后将结果提供给声卡单元之外什么都不做。FMOD_DSP_TYPE_OSCILLATOR | 此单元生成正弦/方波/锯/三角形或噪声音。FMOD_DSP_TYPE_LOWPASS | 此单元使用高质量的谐振低通滤波器算法过滤声音，但消耗更多的CPU时间。已弃用，将在以后的版本中删除（有关替代版本，请参阅FMOD_DSP_LOWPASS备注）。FMOD_DSP_TYPE_ITLOWPASS | 此单元使用脉冲跟踪器中使用的谐振低通滤波器算法过滤声音，但截止范围有限（0到8060hz）。FMOD_DSP_TYPE_HIGHPASS | 此单元使用谐振高通滤波器算法过滤声音。已弃用，将在以后的版本中删除（有关替代版本，请参阅FMOD_DSP_HIGHPASS备注）。FMOD_DSP_TYPE_ECHO | 此单元在声音上产生回声并以所需速率淡出。FMOD_DSP_TYPE_FADER | 此单位平移和缩放单位的音量。FMOD_DSP_TYPE_FLANGE | 此单元对声音产生法兰效果。FMOD_DSP_TYPE_DISTORTION | 此单位扭曲声音。FMOD_DSP_TYPE_NORMALIZE | 此单元将声音标准化或放大到一定水平。FMOD_DSP_TYPE_LIMITER | 此单位将声音限制在一定水平。FMOD_DSP_TYPE_PARAMEQ | 此单元衰减或放大选定的频率范围。已弃用，将在以后的版本中删除（有关替代版本，请参阅FMOD_DSP_PARAMEQ备注）。FMOD_DSP_TYPE_PITCHSHIFT | 此单位在不改变播放速度的情况下弯曲声音的音高。FMOD_DSP_TYPE_CHORUS | 此单位对声音产生合唱效果。FMOD_DSP_TYPE_VSTPLUGIN | 此单元允许使用Steinberg VST插件FMOD_DSP_TYPE_WINAMPPLUGIN | 此单元允许使用Nullsoft Winamp插件FMOD_DSP_TYPE_ITECHO | 此单元在声音上产生回声，并以Impulse Tracker中使用的所需速率淡出。FMOD_DSP_TYPE_COMPRESSOR | 此单元实现动态压缩（链接/非链接多声道，宽带）FMOD_DSP_TYPE_SFXREVERB | 此单元实现SFX混响FMOD_DSP_TYPE_LOWPASS_SIMPLE | 此单元使用简单的低通滤波器进行声音滤波，无谐振，但具有灵活的截止频率且速度快。已弃用，将在以后的版本中删除（有关替代版本，请参阅FMOD_DSP_LOWPASS_SIMPLE备注）。FMOD_DSP_TYPE_DELAY | 此单元在声音的各个声道上产生不同的延迟。FMOD_DSP_TYPE_TREMOLO | 此单元对声音产生颤音/斩波效果。FMOD_DSP_TYPE_LADSPAPLUGIN | 不支持/不推荐使用。FMOD_DSP_TYPE_SEND | 该单元将信号的副本发送到DSP树中任何位置的返回DSP。 * /FMOD_DSP_TYPE_RETURN | 本机接收来自多个发送DSP的信号。FMOD_DSP_TYPE_HIGHPASS_SIMPLE | 此单元使用简单的高通滤波器无声共振，但具有灵活的截止频率且速度快。已弃用，将在以后的版本中删除（有关替代版本，请参阅FMOD_DSP_HIGHPASS_SIMPLE备注）。FMOD_DSP_TYPE_PAN | 此单元平移信号，也可能是上混或下混。FMOD_DSP_TYPE_THREE_EQ | 此单元是三频段均衡器。FMOD_DSP_TYPE_FFT | 该单元简单地分析信号并通过getParameter提供频谱信息。 * /FMOD_DSP_TYPE_LOUDNESS_METER | 此单元分析信号的响度和真峰值。FMOD_DSP_TYPE_ENVELOPEFOLLOWER | 此单元跟踪输入/侧链信号的包络。已弃用，将在以后的版本中删除。FMOD_DSP_TYPE_CONVOLUTIONREVERB | 此单元实现卷积混响。FMOD_DSP_TYPE_CHANNELMIX | 此单元提供每信号通道增益和输出通道映射，以允许由多组信号组成的1个多通道信号映射到单个输出信号。FMOD_DSP_TYPE_TRANSCEIVER | 此单元从最多32个不同的插槽中选择“发送”和“接收”。它就像发送/返回，但它使用全局槽而不是返回作为目标。它还有其他功能。多个收发器可以从单个通道接收，或者多个收发器可以发送到单个通道，或两者的组合。FMOD_DSP_TYPE_OBJECTPAN | 此单元将信号发送到3d对象编码器，如Dolby Atmos。支持FMOD_D的子集\n4.2 DSP 的参数类型在设置 DSP 的参数类型时，可在 fmod_dsp_effects.h 头文件中查询对应的 DSP类型，即可看到对应的参数类型\n如：FMOD_DSP_TREMOLO,在头文件中查到如下内容\ntypedef enum\n&#123;\n    FMOD_DSP_TREMOLO_FREQUENCY,     /* (Type:float) - LFO frequency in Hz.  0.1 to 20.  Default = 5. */\n    FMOD_DSP_TREMOLO_DEPTH,         /* (Type:float) - Tremolo depth.  0 to 1.  Default = 1. */\n    FMOD_DSP_TREMOLO_SHAPE,         /* (Type:float) - LFO shape morph between triangle and sine.  0 to 1.  Default = 0. */\n    FMOD_DSP_TREMOLO_SKEW,          /* (Type:float) - Time-skewing of LFO cycle.  -1 to 1.  Default = 0. */\n    FMOD_DSP_TREMOLO_DUTY,          /* (Type:float) - LFO on-time.  0 to 1.  Default = 0.5. */\n    FMOD_DSP_TREMOLO_SQUARE,        /* (Type:float) - Flatness of the LFO shape.  0 to 1.  Default = 0. */\n    FMOD_DSP_TREMOLO_PHASE,         /* (Type:float) - Instantaneous LFO phase.  0 to 1.  Default = 0. */\n    FMOD_DSP_TREMOLO_SPREAD         /* (Type:float) - Rotation / auto-pan effect.  -1 to 1.  Default = 0. */\n&#125; FMOD_DSP_TREMOLO;\n\n\n\nDSP 参数类型\n说明\n\n\n\nFMOD_DSP_TREMOLO_FREQUENCY\n（类型：浮点） - 以Hz为单位的LFO频率。 0.1至20.默认= 5.\n\n\nFMOD_DSP_TREMOLO_DEPTH\n（类型：浮点） - 颤音深度。 0到1.默认= 1. * /\n\n\nFMOD_DSP_TREMOLO_SHAPE\n（类型：浮点） - 三角形和正弦之间的LFO形状变形。 0到1.默认= 0.\n\n\nFMOD_DSP_TREMOLO_SKEW\n（类型：浮点） - LFO周期的时间偏移。 -1到1.默认值= 0.\n\n\nFMOD_DSP_TREMOLO_DUTY\n（类型：浮点） - LFO开启时间。 0到1.默认值= 0.5。\n\n\nFMOD_DSP_TREMOLO_SQUARE\n（类型：浮点） - LFO形状的平坦度。 0到1.默认= 0.\n\n\nFMOD_DSP_TREMOLO_PHASE\n（类型：浮点） - 瞬时LFO相位。 0到1.默认= 0. * / FMOD_DSP_TREMOLO_SPREAD\n\n\n项目源码QQVoiceChange源码\n到此，我们以及实现集成 fmod 的模拟QQ变声项目，效果不是完全一样，但也有7分相似，；自己可研究其他效果，来实现模拟更多的声音特效。\n","categories":["NDK"],"tags":["Android","NDK","Fmod"]},{"title":"矩形覆盖","url":"https://blog.onestravel.cn/20190318/0f5782b0adb3/","content":"8.3 矩形覆盖题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？\n比如n=3时，2*3的矩形块有3种覆盖方法：\n\n解题思路2*n的大矩形，和n个2*1的小矩形\n其中 n*2为大矩阵的大小\n有以下几种情形：\n\nn &lt;= 0 大矩形为  &lt;= 2*0,直接return 0；\nn = 1大矩形为2*1，只有一种摆放方法，return1；\nn = 2 大矩形为2*2，有两种摆放方法，return2；\nn &gt;2 分为两步考虑：\n第一次摆放一块2*1的小矩阵，则摆放方法总共为f(n - 1)\n再一次摆放一块2*1的小矩阵，则摆放方法总共为f(n-2)；因为，摆放了一块1*2的小矩阵，对应下方的1*2（用××表示）摆放方法就确定了，所以为f(n-2)\n\n\n可以看出 f(n) = f(n-1) + f(n-2),就是一个斐波那契数列\n\n代码实现java 代码    /**\n     * 矩形覆盖\n     * f(n) = f(n-1) + f(n-2)\n     */\n    public int rectCover(int n) {\n        if (n &lt;= 0) {\n            return 0;\n        } else if (n &lt;= 2) {\n            return n;\n        } else {\n            int a = 1, b = 2, c = 0;\n            for (int i = 3; i &lt;= n; i++) {\n                c = a + b;\n                a = b;\n                b = c;\n            }\n            return c;\n        }\n    }\n\n    public static void main(String[] args){\n        System.out.println(rectCover(9));\n    }\nKotlin 代码    /**\n     * 矩形覆盖\n     * f(n) = f(n-1) + f(n-2)\n     */\n    private fun rectCover(n: Int): Int {\n        return when {\n            n &lt;= 0 -> {\n                0\n            }\n            n &lt;= 2 -> {\n                n\n            }\n            else -> {\n                var a = 1\n                var b = 2\n                var c = 0\n                for (i in 3..n) {\n                    c = a + b\n                    a = b\n                    b = c\n                }\n                c\n            }\n        }\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        pringln(rectCover(6))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["斐波那契数列"]},{"title":"变态跳台阶","url":"https://blog.onestravel.cn/20190317/67c55543cddb/","content":"8.2 变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n解题思路对于本题,有 一次 1阶或者2阶的跳法,也有一次n阶的跳法。\nf(1) = 1\n\nf(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。\n\nf(3) = f(3-1) + f(3-2) + f(3-3) \n\n...\nf(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) \nn = 1时，只有1种跳法，f(1) = 1\n\nn = 2时，会有一次1阶或者2阶两种跳的方式，，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2)\n\nn = 3时，会有1阶、2阶、3阶，三种跳的方式；那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3)则:  f(3) = f(3-1) + f(3-2) + f(3-3)\n\nn = n时，会有，1阶、2阶…n阶；总共n中跳的方式，则：f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + ... f(n-2)+ f(n-1)\n\n上面4的表达式可以看到f(n) = f(0)+f(1)+...+f(n-2)+f(n-1),   f(n-1) = f(0)+f(1)+...+f(n-2);则f(n) = f(n-1)+f(n-1)简化后可以写成：f(n) = 2 * f(n-1)\nf(n) = 2*f(n-1)=2^2 * f(n-2)= ... = 2^{n-1} * f(1)  = 2^{n-1}\n代码实现java 代码 /**\n  * 递归变态跳台阶，可以跳1阶，2阶...n阶\n  * 时间复杂度 O(n)\n  * @param n 总阶数\n  * @return\n  */\n public int jumpFloorII(int n) {\n     if (n == 1) {\n         return 1;\n     } else {\n         return 2 * jumpFloorII(n - 1);\n     }\n }\n\n /**\n  * 数学公式发变态跳台阶，可以跳1阶，2阶...n阶\n  * ∵ f(n) = f(0)+f(1)+...+f(n-2)+f(n-1)\n  * f(n-1) = f(0)+f(1)+...+f(n-2)\n  * ∴ f(n) = f(n-1)+f(n-1)\n  * f(n) = 2 * f(n-1)=2^2 * f(n-2)= ... = 2^{n-1} * f(1)  = 2^{n-1}\n  * 时间复杂度 O(1)\n  * @param n 总阶数\n  * @return\n  */\n public int jumpFloorIIMath(int n) {\n     return (int) Math.pow(2, n - 1);\n }\n\n /**\n  * 迭代发变态跳台阶，可以跳1阶，2阶...n阶\n  * 时间复杂度 O(n)\n  * @param n 总阶数\n  * @return\n  */\n public int jumpFloorIIFor(int n) {\n     if (n == 1) {\n         return 1;\n     } else {\n         int c = 1;\n         for (int i = 2; i &lt;= n; i++) {\n             c *= 2;\n         }\n         return c;\n     }\n }\n\n public static void main(String[] args){\n      System.out.println(jumpFloorII(9));\n     System.out.println(jumpFloorIIMath(9));\n     System.out.println(jumpFloorIIFor(9));\n }\n\n\nKotlin 代码    /**\n     * 递归变态跳台阶，可以跳1阶，2阶...n阶\n     * 时间复杂度 O(n)\n     * @param n 总阶数\n     * @return\n     */\n    private fun jumpFloorII(n: Int): Int {\n        return if (n == 1) {\n            1\n        } else {\n            2 * jumpFloorII(n - 1)\n        }\n    }\n\n    /**\n     * 数学公式发变态跳台阶，可以跳1阶，2阶...n阶\n     * ∵ f(n) = f(0)+f(1)+...+f(n-2)+f(n-1)\n     * f(n-1) = f(0)+f(1)+...+f(n-2)\n     * ∴ f(n) = f(n-1)+f(n-1)\n     * f(n) = 2 * f(n-1)=2^2 * f(n-2)= ... = 2^{n-1} * f(1)  = 2^{n-1}\n     * 时间复杂度 O(1)\n     * @param n 总阶数\n     * @return\n     */\n   private fun jumpFloorIIMath(n: Int): Int {\n        return 2.0.pow(n - 1.toDouble()).toInt()\n    }\n\n    /**\n     * 迭代发变态跳台阶，可以跳1阶，2阶...n阶\n     * 时间复杂度 O(n)\n     * @param n 总阶数\n     * @return\n     */\n    private fun jumpFloorIIFor(n: Int): Int {\n        return if (n == 1) {\n            1\n        } else {\n            var c = 1\n            for (i in 2..n) {\n                c *= 2\n            }\n            c\n        }\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        println(jumpFloorII(9))\n        println(jumpFloorIIMath(9))\n        println(jumpFloorIIFor(9))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["斐波那契数列"]},{"title":"跳台阶","url":"https://blog.onestravel.cn/20190317/d3a08f18535a/","content":"8.1 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。\n解题思路对于本题,前提只有 一次 1阶或者2阶的跳法。\n\n如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);\n假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)\n由a\\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2) \n然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2\n可以发现最终得出的是一个斐波那契数列：     | 1     (n==1)\nf(n) =  | 2     (n==2)\n     | f(n-1)+f(n-2)     (n&gt;=3)\n\n代码实现java 代码    /**\n     * 递归实现\n     * @param n\n     * @return\n     */\n    public int jumpFloor(int n) {\n        if(n==1){\n            return 1;\n        }else if(n==2){\n            return 2;\n        }else {\n            return jumpFloor(n-1)+jumpFloor(n-2);\n        }\n    }\n\n    /**\n     * 迭代实现\n     * @param n\n     * @return\n     */\n    public int jumpFloorFor(int n) {\n        if(n==1){\n            return 1;\n        }else if(n==2){\n            return 2;\n        }else {\n            int a = 1,b=2,c=0;\n            for(int i=3;i&lt;=n;i++){\n                c = a+b;\n                a = b;\n                b = c;\n            }\n            return c;\n        }\n    }\n\n    public static void main(String[] args){\n        System.out.println(jumpFloor(8));\n        System.out.println(jumpFloorFor(8));\n    }\nKotlin 代码     /**\n     * 递归实现\n     * @param n\n     * @return\n     */\n    fun jumpFloor(n: Int): Int {\n        return when (n) {\n            1 -> {\n                1\n            }\n            2 -> {\n                2\n            }\n            else -> {\n                jumpFloor(n - 1) + jumpFloor(n - 2)\n            }\n        }\n    }\n\n    /**\n     * 迭代实现\n     * @param n\n     * @return\n     */\n    fun jumpFloorFor(n: Int): Int {\n        return when (n) {\n            1 -> {\n                1\n            }\n            2 -> {\n                2\n            }\n            else -> {\n                var a = 1\n                var b = 2\n                var c = 0\n                for (i in 3..n) {\n                    c = a + b\n                    a = b\n                    b = c\n                }\n                c\n            }\n        }\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        println(jumpFloor(8))\n        println(jumpFloorFor(8))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["斐波那契数列"]},{"title":"斐波那契数列","url":"https://blog.onestravel.cn/20190316/2183b419e70e/","content":"8.斐波那契数列题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39\n本题知识点： 递归\n斐波那契斐波那契数列来源于兔子繁殖问题，所以也叫兔子序列。指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）\n递归实现解题思路递归实现就是套用 公式F(1)=1，F(2)=1,当n&gt;=3时：F(n)=F(n - 1)+F(n - 2) 来实现的。递归n次，时间复杂度O(2^n)\n代码实现java 代码    /**\n     * 递归求斐波那契数列\n     *\n     * @param n \n     * @return\n     */\n    public int fibonacci(int n) {\n        if (n == 0) {\n            return 0;\n        } else if (n == 1 || n == 2) {\n            return 1;\n        }\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n\n\n\n    public static void main(String[] args){\n        System.out.println(fibonacci(6));\n    }\nKotlin 代码    /**\n     * 递归求斐波那契数列\n     *\n     * @param n\n     * @return\n     */\n    fun fibonacci(n: Int): Int {\n        if (n == 0) {\n            return 0\n        } else if (n == 1 || n == 2) {\n            return 1\n        }\n        return fibonacci(n - 1) + fibonacci(n - 2)\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n         println(fibonacci(6))\n    }\n\n动态规划（迭代）实现解题思路因为斐波那契数列可以从左到右顺序的求出每一项的值，因此只需要顺序计算到n项即可，时间复杂度为O(n)的\n代码实现java 代码    /**\n     * 循环求斐波那契数列\n     *\n     * @param n\n     * @return\n     */\n    public int fibonacci(int n) {\n        int a = 1, b = 1, c = 0;\n        if (n == 0) {\n            return 0;\n        } else if (n == 1 || n == 2) {\n            return 1;\n        } else {\n            for (int i = 3; i &lt;= n; i++) {\n                c = a + b;\n                a = b;\n                b = c;\n            }\n        }\n        return c;\n    }\n\n    public static void main(String[] args){\n        System.out.println(fibonacci(6));\n    }\nKotlin 代码    /**\n     * 循环求斐波那契数列\n     *\n     * @param n\n     * @return\n     */\n    fun fibonacci(n: Int): Int {\n        var a = 1\n        var b = 1\n        var c = 0\n        if (n == 0) {\n            return 0\n        } else if (n == 1 || n == 2) {\n            return 1\n        } else {\n            for (i in 3..n) {\n                c = a + b\n                a = b\n                b = c\n            }\n        }\n        return c\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        println(fibonacci(6))\n    }\n\n状态矩阵相乘求法矩阵乘法一个 m * p 的矩阵和一个 p * n的矩阵相乘得到一个 m * n的矩阵\n\\begin{bmatrix}\na&b \\\\  \nc&d \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\ne&f \\\\  \ng&h \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nae+bg&af+bh \\\\  \nce+dg&cf+dh \\\\\n\\end{bmatrix}\n解题思路这是一个时间复杂度为O(log n)的算法。因为斐波那契数列在n大于等于三的时候严格遵守递推数列f(n) = f(n-1) + f(n-2)，而对于一个二阶的递推数列来说，我们可以用矩阵乘法来表示，且状态矩阵是2阶的方阵：\n实现的推导原理如下：数列的递推公式为：f(0)=0,f(1)=1，f(2)=2，用矩阵表示为：\n\\begin{bmatrix}\nf(n) \\\\  \nf(n-1) \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1&1 \\\\  \n1&0 \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nf(n-1) \\\\  \nf(n-2) \\\\\n\\end{bmatrix}\n进一步，可以得出直接推导公式：\n\\begin{bmatrix}\nf(n+1) \\\\  \nf(n) \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1&1 \\\\  \n1&0 \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nf(n) \\\\  \nf(n-1) \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1&1 \\\\  \n1&0 \\\\\n\\end{bmatrix}^2\n\\begin{bmatrix}\nf(n-1) \\\\  \nf(n-2) \\\\\n\\end{bmatrix}\n=\n...\n=\n\\begin{bmatrix}\n1&1 \\\\  \n1&0 \\\\\n\\end{bmatrix}^{n-1}\n\\begin{bmatrix}\nf(2) \\\\  \nf(1) \\\\\n\\end{bmatrix}\n\n\n=\n\\begin{bmatrix}\n1&1 \\\\  \n1&0 \\\\\n\\end{bmatrix}^n\n\\begin{bmatrix}\nf(1) \\\\  \nf(0) \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1&1 \\\\  \n1&0 \\\\\n\\end{bmatrix}^n\n\\begin{bmatrix}\n1 \\\\  \n0 \\\\\n\\end{bmatrix}\n也可以推导为：\n\\begin{bmatrix}\nf(n+1)&f(n)\\\\\nf(n)&f(n-1)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1&1 \\\\  \n1&0 \\\\\n\\end{bmatrix}^n\n=\n\\begin{bmatrix}\n1&1 \\\\  \n1&0 \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n1&1 \\\\  \n1&0 \\\\\n\\end{bmatrix}\n...\n\\begin{bmatrix}\n1&1 \\\\  \n1&0 \\\\\n\\end{bmatrix}\n\n（不是很懂）\n代码实现java 代码    /**\n     * 采用矩阵的解法\n     * 时间复杂度为O(logN)\n     *\n     * @param n\n     * @return\n     */\n    public int fibonacci(int n) {\n        if (n == 0) {\n            return 0;\n        }\n        int[][] fbnq = fbnq(n);\n        return fbnq[1][0];\n    }\n\n    /**\n     * 单元矩阵\n     */\n    private static final int[][] UNIT = {{1, 1}, {1, 0}};\n\n    /**\n     * 矩阵求斐波那契\n     *\n     * @param n\n     * @return\n     */\n    private int[][] fbnq(int n) {\n        if (n == 1) {\n            return UNIT;\n        }\n        if (n % 2 == 0) {\n            int[][] matrix = fbnq(n / 2);\n            //相当于矩阵的n次幂(A^n/2  * A^n/2 = A^(n/2+n/2) = A^n\n            return matrixMultiply(matrix, matrix);\n        } else {\n            int[][] matrix = fbnq((n - 1) / 2);\n            //相当于矩阵的n次幂(A^(n-1)/2  * A^(n-1)/2 = A^((n-1)/2+(n-1)/2+1) = A^n\n            return matrixMultiply(UNIT, matrixMultiply(matrix, matrix));\n        }\n    }\n\n    /**\n     * 矩阵乘法\n     *\n     * @param a 相乘的矩阵a\n     * @param b 相乘的矩阵b\n     * @return 矩阵相乘的结果\n     */\n    private static int[][] matrixMultiply(int[][] a, int[][] b) {\n        int rows = a.length;\n        int cols = b[0].length;\n        int[][] matrix = new int[rows][cols];\n        for (int i = 0; i &lt; a.length; i++) {\n            for (int j = 0; j &lt; b[0].length; j++) {\n                for (int k = 0; k &lt; a[i].length; k++) {\n                    matrix[i][j] += a[i][k] * b[k][j];\n                }\n            }\n        }\n        return matrix;\n    }\n\n    public static void main(String[] args){\n        System.out.println(fibonacci(6));\n    }\nKotlin 代码    /**\n     * 采用矩阵的解法\n     * 时间复杂度为O(logN)\n     *\n     * @param n\n     * @return\n     */\n    private fun fibonacci(n: Int): Int {\n        if (n &lt;= 2) {\n            return 1\n        }\n        val arr = fbnq(n);\n        return arr[0][1]\n    }\n\n    /**\n     * 单元矩阵\n     */\n    private val UNIT = arrayOf(intArrayOf(1, 1), intArrayOf(1, 0))\n    /**\n     * 矩阵求斐波那契\n     *\n     * @param n\n     * @return\n     */\n    private fun fbnq(n: Int): Array&lt;IntArray> {\n        if (n == 1) {\n            return UNIT\n        }\n        if (n % 2 == 0) {\n            val matrix = fbnq(n / 2)\n            return matrixMultiply(matrix, matrix)\n        } else {\n            val matrix = fbnq((n-1) / 2)\n            return matrixMultiply(UNIT,matrixMultiply(matrix, matrix))\n        }\n    }\n\n    /**\n     * 矩阵乘法\n     *\n     * @param a 相乘的矩阵a\n     * @param b 相乘的矩阵b\n     * @return 矩阵相乘的结果\n     */\n    private fun matrixMultiply(a: Array&lt;IntArray>, b: Array&lt;IntArray>): Array&lt;IntArray> {\n        val row = a.size\n        val col = b[0].size\n        val matrix = Array&lt;IntArray>(row) { IntArray(col) }\n        for (i in 0 until row) {\n            for (j in 0 until col) {\n                for (k in a[i].indices) {\n                    matrix[i][j] += a[i][k]*b[k][j]\n                }\n            }\n        }\n        return matrix\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        println(fibonacci(6))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["斐波那契数列"]},{"title":"用两个栈实现一个队列","url":"https://blog.onestravel.cn/20190315/e27bfa90c1b0/","content":"7. 用两个栈实现一个队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\n解题思路栈的特征是『先进后出』，队列的特征是『先进先出』，要用两个栈A和B实现队列，则可以使用两个栈的『先进后出』特性来实现队列push时，将数据压入栈A；pop时，如果栈B没有数据，则将栈A数据全部压入栈B,在由栈B取出数据，进行返回，即可实现「先进先出」的队列\n代码实现java 代码     /**\n     * 简易队列\n     */\n    public class Queue {\n        Stack&lt;Integer> stack1 = new Stack&lt;Integer>();\n        Stack&lt;Integer> stack2 = new Stack&lt;Integer>();\n\n        /**\n         * 将数据放入队列\n         *\n         * @param node\n         */\n        public void push(int node) {\n            stack1.push(node);\n        }\n\n        /**\n         * 从队列中取出数据\n         *\n         * @return\n         */\n        public int pop() {\n            //当栈2为空时，将栈1所有数据出栈，压入栈2\n            //原则：当调用pop()方法且栈2数据为空的时候要一次性将栈1中的数据取出，并且在栈2数据不为空时，不能将栈1数据放入栈2,否则会出现后进先出的现象\n            if (stack2.isEmpty()) {\n                while (!stack1.isEmpty()) {\n                    stack2.push(stack1.pop());\n                }\n            }\n            if (stack2.isEmpty()) {\n                throw new NoSuchElementException(\"current not find element\");\n            }\n            return stack2.pop();\n        }\n\n        /**\n         * 判断队列数据是否为空\n         * @return\n         */\n        public boolean isEmpty() {\n            return stack1.isEmpty() &amp;&amp; stack2.isEmpty();\n        }\n    }\n\n    public static void main(String[] args){\n        Queue queue = new Queue();\n        queue.push(1);\n        queue.push(2);\n        queue.push(3);\n        queue.push(4);\n        System.out.println(queue.pop());\n        queue.push(5);\n        while (!queue.isEmpty()) {\n            System.out.println(queue.pop());\n        }\n    }\n输出结果：\n1\n2\n3\n4\n5Kotlin 代码    /**\n     * 简易队列\n     */\n    class Queue {\n        private var stack1 = Stack&lt;Int>()\n        private var stack2 = Stack&lt;Int>()\n\n        /**\n         * 将数据放入队列\n         *\n         * @param node\n         */\n        fun push(node: Int) {\n            stack1.push(node)\n        }\n\n        /**\n         * 从队列中取出数据\n         *\n         * @return\n         */\n        fun pop(): Int {\n            //当栈2为空时，将栈1所有数据出栈，压入栈2\n            //原则：当调用pop()方法且栈2数据为空的时候要一次性将栈1中的数据取出，并且在栈2数据不为空时，不能将栈1数据放入栈2,否则会出现后进先出的现象\n            if (stack2.isEmpty()) {\n                while (!stack1.isEmpty()) {\n                    stack2.push(stack1.pop())\n                }\n            }\n            if (stack2.isEmpty()) {\n                throw NoSuchElementException(\"current not find element\")\n            }\n            return stack2.pop()\n        }\n\n        /**\n         * 判断队列数据是否为空\n         * @return\n         */\n        val isEmpty: Boolean\n            get() = stack1.isEmpty() &amp;&amp; stack2.isEmpty()\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        val queue = Queue()\n        queue.push(1)\n        queue.push(2)\n        queue.push(3)\n        queue.push(4)\n        println(queue.pop())\n        queue.push(5)\n        while (!queue.isEmpty) {\n            println(queue.pop())\n        }\n    }\n\n输出结果：\n1\n2\n3\n4\n5引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["栈","队列"]},{"title":"二叉树的下一个节点","url":"https://blog.onestravel.cn/20190310/83465f93f3f4/","content":"6. 二叉树的下一个节点题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。\n解题思路二叉树中序遍历顺序为 左中右\n把传入的当前结点看做中结点，则：下一个节点为有两种况\n\n当前结点的右结点为空，则下一个结点是当前节的父结点/祖先结点；\n当父结点的左结点等于当前结点时，当前结点的一个结点为父结点；\n当父结点的左结点不等于当前结点时，继续找父点的父结点；\n\n\n当前结点的右结点不为空，则当前节点有右子树则下一个结点为右子树的最左结点\n\n代码实现java 代码    /**\n     * 二叉树结点\n     */\n    public class TreeLinkNode {\n        int val; //当前结点值\n        TreeLinkNode left = null;//当前结点的左结点\n        TreeLinkNode right = null;//当前结点的右结点\n        TreeLinkNode next = null;//当前结点的父结点\n\n        TreeLinkNode(int val) {\n            this.val = val;\n        }\n    }\n\n    /**\n     * 给定一个二叉树和其中的一个结点，找出中序遍历顺序的下一个结点并且返回\n     * 二叉树中序遍历顺序为 左中右\n     * 把传入的当前结点看做中，则：下一个节点为有两种情况\n     * 1. 当前结点的右结点为空，则下一个结点是当前节点的父结点/祖先结点；\n     *  - 当父结点的左结点等于当前结点时，当前结点的下一个结点为父结点；\n     *  - 当父结点的左结点不等于当前结点时，继续找父结点的父结点；\n     * 2. 当前结点的右结点不为空，则当前节点有右子树，则下一个结点为右子树的最左结点\n     *\n     * @param pNode\n     * @return\n     */\n    public TreeLinkNode getNext(TreeLinkNode pNode) {\n        if (pNode.right == null) {\n            while (pNode.next != null) {\n                if (pNode == pNode.next.left) {\n                    return pNode.next;\n                }\n                pNode = pNode.next;\n            }\n            return null;\n        } else {\n            TreeLinkNode node = pNode.right;\n            while (node.left != null) {\n                node = node.left;\n            }\n            return node;\n        }\n    }\n\n    public static void main(String[] args){\n        TreeLinkNode root = new TreeLinkNode(1);\n        TreeLinkNode node2 = new TreeLinkNode(2);\n        TreeLinkNode node3 = new TreeLinkNode(3);\n        TreeLinkNode node4 = new TreeLinkNode(4);\n        TreeLinkNode node5 = new TreeLinkNode(5);\n        TreeLinkNode node6 = new TreeLinkNode(6);\n        TreeLinkNode node7 = new TreeLinkNode(7);\n        TreeLinkNode node8 = new TreeLinkNode(8);\n        node4.right = node7;\n        node2.left = node4;\n        root.left = node2;\n        node6.left = node8;\n        node3.left = node5;\n        node3.right = node6;\n        root.right = node3;\n        System.out.println(getNext(node4).val);\n    }\nKotlin 代码    /**\n     * 二叉树结点\n     */\n    class TreeLinkNode(val value: Int) {\n        var left: TreeLinkNode? = null //当前结点的左结点\n        var right: TreeLinkNode? = null //当前结点的右结点\n        var next: TreeLinkNode? = null //当前结点的父结点\n    }\n\n    /**\n     * 给定一个二叉树和其中的一个结点，找出中序遍历顺序的下一个结点并且返回\n     * 二叉树中序遍历顺序为 左中右\n     * 把传入的当前结点看做中，则：下一个节点为有两种情况\n     * 1. 当前结点的右结点为空，则下一个结点是当前节点的父结点/祖先结点；\n     * - 当父结点的左结点等于当前结点时，当前结点的下一个结点为父结点；\n     * - 当父结点的左结点不等于当前结点时，继续找父结点的父结点；\n     * 2. 当前结点的右结点不为空，则当前节点有右子树，则下一个结点为右子树的最左结点\n     *\n     * @param pNode\n     * @return\n     */\n    private fun getNext(pNode: TreeLinkNode?): TreeLinkNode? {\n        var pNode = pNode\n        return if (pNode!!.right == null) {\n            while (pNode!!.next != null) {\n                if (pNode === pNode.next!!.left) {\n                    return pNode.next\n                }\n                pNode = pNode.next\n            }\n            null\n        } else {\n            var node = pNode.right\n            while (node!!.left != null) {\n                node = node.left\n            }\n            node\n        }\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        val root = TreeLinkNode(1)\n        val node2 = TreeLinkNode(2)\n        val node3 = TreeLinkNode(3)\n        val node4 = TreeLinkNode(4)\n        val node5 = TreeLinkNode(5)\n        val node6 = TreeLinkNode(6)\n        val node7 = TreeLinkNode(7)\n        val node8 = TreeLinkNode(8)\n        node4.right = node7\n        node2.left = node4\n        root.left = node2\n        node6.left = node8\n        node3.left = node5\n        node3.right = node6\n        root.right = node3\n        println(getNext(node4)?.value)\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["二叉树"]},{"title":"AndroidStudio下集成Fmod，实现仿QQ变声效果（一）","url":"https://blog.onestravel.cn/20190310/9fcf14b14bdc/","content":"AndroidStudio下集成Fmod，实现仿QQ变声效果前言在使用QQ的时候，我们会发现有一个炫酷的功能，那就是变声，效果图如下;其实QQ变声效果就是使用了Fmod声音引擎，通过NDK的开发，来实现对声音的变换。今天我们先进行一下QQ变声效果的前期实现，先引入Fmod库，实现音频文件的播放\n一、前期准备\n【Fmod下载】：点击该连接后，进行注册，登录以后再下载,选择版本\n【Android Studio】：Android Studio实现NDK支持\n\n二、实现使用fmod播放assets下的音频1、创建一个支持C++的Android项目\n\n\n创建好之后会在app/src/main 下面看到cpp文件夹，这就是进行NDK开发的C/C++层的文件夹\n2、配置Android项目\n在 app/src/main 下创建 jniLibs 文件夹\n将下载好的fmod包打开，进入到 api/lowlevel/ 下，可以看到 examples 、inc 、lib 三个文件夹\n将 inc 文件夹整体复制到 src/main/cpp 目录下\n将 lib 文件夹下的 fmod.jar 复制到 libs 目录下，并且右键该jar包，Add As Library \n将 lib 文件夹下的 so 动态库的不同平台的文件夹复制到 刚刚创建好的 jniLibs 目录下\n将 examples 目录下的common.h,common.cpp,common_platform.h,common_platform.cpp,play_sound.cpp 文件复制到src/main/cpp 目录下\n修改common.h中 #include “fmod.h” 为 #include “inc/fmod.h”\n修改common.cpp中 #include “fmod_errors.h” 为 #include “inc/fmod_errors.h”\n修改play_sound.cpp中 #include “fmod.hpp” 为 #include “inc/fmod.hpp”\n将 examples/java 下的org文件夹整个赋值到 src/main/java 目录下，并修改 AndroidManifest.xml 中的启动类为  org.fmod.example.MainActivity\n在app下的build.gradle 中的 defaultConfig 木块中新增 NDK 配置\n\n    ndk &#123;\n            abiFilters &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;x86&quot;, &quot;x86_64&quot;\n        &#125;\n将引入的so动态库和play_sound.cpp等加入到 CMakeLists.txt 文件中，具体配置如下：\n\ncmake_minimum_required(VERSION 3.4.1)\n\nset(distribution_DIR $&#123;PROJECT_SOURCE_DIR&#125;../../jniLibs)\ninclude_directories(src/main/cpp/inc)\nadd_library( sound\n        SHARED\n        play_sound.cpp\n        common.cpp\n        common_platform.cpp)\nadd_library( fmod\n        SHARED\n        IMPORTED )\nset_target_properties( fmod\n        PROPERTIES IMPORTED_LOCATION\n        $&#123;distribution_DIR&#125;/$&#123;ANDROID_ABI&#125;/libfmod.so)\nadd_library( fmodL\n        SHARED\n        IMPORTED )\nset_target_properties( fmodL\n        PROPERTIES IMPORTED_LOCATION\n        $&#123;distribution_DIR&#125;/$&#123;ANDROID_ABI&#125;/libfmodL.so )\nfind_library( # Sets the name of the path variable.\n        log-lib\n        log)\ntarget_link_libraries( sound\n        fmod\n        fmodL\n        $&#123;log-lib&#125; )\n\n修改 org.fmod.example.MainActivity 中的static 方法,删除一些未引入的library，更改刚刚在 CMakeLists.txt 文件中定义的library 如下：\n\n static &#123;\n        try &#123;\n            System.loadLibrary(&quot;fmodL&quot;);\n        &#125; catch (UnsatisfiedLinkError e) &#123;\n        &#125;\n        try &#123;\n            System.loadLibrary(&quot;fmod&quot;);\n        &#125; catch (UnsatisfiedLinkError e) &#123;\n        &#125;\n        System.loadLibrary(&quot;sound&quot;);\n    &#125;\n将 examples/media 文件夹下的音频资源文件复制到项目的 assets 目录下，具体文件引入可查看 play_sound.cpp 文件42~52行；这里将所有后缀为 .wav 和 .mp3 的文件都复制到 assets 目录下。\n\n    result = system-&gt;createSound(Common_MediaPath(&quot;drumloop.wav&quot;), FMOD_DEFAULT, 0, &amp;sound1);\n    ERRCHECK(result);\n\n    result = sound1-&gt;setMode(FMOD_LOOP_OFF);    /* drumloop.wav has embedded loop points which automatically makes looping turn on, */\n    ERRCHECK(result);                           /* so turn it off here.  We could have also just put FMOD_LOOP_OFF in the above CreateSound call. */\n\n    result = system-&gt;createSound(Common_MediaPath(&quot;jaguar.wav&quot;), FMOD_DEFAULT, 0, &amp;sound2);\n    ERRCHECK(result);\n\n    result = system-&gt;createSound(Common_MediaPath(&quot;swish.wav&quot;), FMOD_DEFAULT, 0, &amp;sound3);\n    ERRCHECK(result);\n到这里，我们所有的步骤都已经完成了，可以成功运行项目了，项目运行起来后，我们可以看到界面上加载了三首音频文件，分别对应 A , B , C 三个按钮，我们点击这三个按钮，就可以播放对应的音频文件\n\n三、项目改造第二部的操作是完全使用了 fmod 的示例来完成 assets 目录下的音频文件的播放，我们可以看到这个是使用的 org.fmod.example.MainActivity 进行播放的，我们接下来将播放的 native 方法抽取成一个 utils 类，然后再自己的MainActivity中调用（使用org.fmod.example.MainActivity的布局）；然后再添加点击 D 和 E 按钮时播放音频文件的功能\n1、抽取 FmodUtils.java 工具类，使用自己包路径下的 MainActivity 实现播放1.1 FmodUtils.java 类如下，在原有main()方法加了参数，传入Activity实例：package org.fmod.core;\n\nimport android.app.Activity;\n\n/**\n * @author onestravel\n * @version 1.0.0\n * @name org.fmod.example.FmodUtils\n * @description //TODO\n */\npublic class FmodUtils &#123;\n    private static FmodUtils mInstance;\n\n    private FmodUtils() &#123;\n\n    &#125;\n\n    public static FmodUtils getInstance() &#123;\n        synchronized (FmodUtils.class) &#123;\n            if (mInstance == null) &#123;\n                mInstance = new FmodUtils();\n            &#125;\n        &#125;\n        return mInstance;\n    &#125;\n\n\n    public native String getButtonLabel(int index);\n    public native void buttonDown(int index);\n    public native void buttonUp(int index);\n    public native void setStateCreate();\n    public native void setStateStart();\n    public native void setStateStop();\n    public native void setStateDestroy();\n    public native void main(Activity context);\n\n    static\n    &#123;\n        try &#123; \n            System.loadLibrary(&quot;fmodL&quot;);\n        &#125;\n        catch (UnsatisfiedLinkError e) &#123; &#125;\n        try &#123; \n            System.loadLibrary(&quot;fmod&quot;);\n        &#125;\n        catch (UnsatisfiedLinkError e) &#123; &#125;\n\n        System.loadLibrary(&quot;sound&quot;);\n    &#125;\n&#125;\n1.2 更改cpp 文件中的 native 函数更改 common_platform.cpp 文件中对应的 native 函数名称(154~200行)\n#include &quot;common.h&quot;\n#include &lt;string.h&gt;\n#include &lt;jni.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nJNIEnv *gJNIEnv;\njobject gMainActivityObject;\nint gDownButtons;\nint gLastDownButtons;\nint gPressedButtons;\nbool gSuspendState;\nbool gQuitState;\nstd::string gUIString;\nstd::vector&lt;char *&gt; gPathList;\n\nint FMOD_Main(); // Defined in example\n\nvoid Common_Init(void **extraDriverData)\n&#123;\n    gDownButtons = 0;\n    gLastDownButtons = 0;\n    gPressedButtons = 0;\n    gSuspendState = false;\n    gQuitState = false;\n&#125;\n\nvoid Common_Close()\n&#123;\n    for (std::vector&lt;char *&gt;::iterator item = gPathList.begin(); item != gPathList.end(); ++item)\n    &#123;\n        free(*item);\n    &#125;\n\n    gPathList.clear();\n&#125;\n\nvoid Common_Update()\n&#123;\n    jstring text = gJNIEnv-&gt;NewStringUTF(gUIString.c_str());\n    jclass mainActivityClass = gJNIEnv-&gt;GetObjectClass(gMainActivityObject);\n    jmethodID updateScreenMethodID = gJNIEnv-&gt;GetMethodID(mainActivityClass, &quot;updateScreen&quot;, &quot;(Ljava/lang/String;)V&quot;);\n\n    gJNIEnv-&gt;CallVoidMethod(gMainActivityObject, updateScreenMethodID, text);\n\n    gJNIEnv-&gt;DeleteLocalRef(text);\n    gJNIEnv-&gt;DeleteLocalRef(mainActivityClass);\n\n    gUIString.clear();\n\n    gPressedButtons = (gLastDownButtons ^ gDownButtons) &amp; gDownButtons;\n    gLastDownButtons = gDownButtons;\n\n    if (gQuitState)\n    &#123;\n        gPressedButtons |= (1 &lt;&lt; BTN_QUIT);\n    &#125;\n&#125;\n\nvoid Common_Sleep(unsigned int ms)\n&#123;\n    usleep(ms * 1000);\n&#125;\n\nvoid Common_Exit(int returnCode)\n&#123;\n    exit(returnCode);\n&#125;\n\nvoid Common_DrawText(const char *text)\n&#123;\n    char s[256];\n    snprintf(s, sizeof(s), &quot;%s\\n&quot;, text);\n\n    gUIString.append(s);\n&#125;\n\nvoid Common_LoadFileMemory(const char *name, void **buff, int *length)\n&#123;\n    FILE *file = fopen(name, &quot;rb&quot;);\n\n    fseek(file, 0, SEEK_END);\n    long len = ftell(file);\n    fseek(file, 0, SEEK_SET);\n\n    void *mem = malloc(len);\n    fread(mem, 1, len, file);\n\n    fclose(file);\n\n    *buff = mem;\n    *length = len;\n&#125;\n\nvoid Common_UnloadFileMemory(void *buff)\n&#123;\n    free(buff);\n&#125;\n\nbool Common_BtnPress(Common_Button btn)\n&#123;\n    return ((gPressedButtons &amp; (1 &lt;&lt; btn)) != 0);\n&#125;\n\nbool Common_BtnDown(Common_Button btn)\n&#123;\n    return ((gDownButtons &amp; (1 &lt;&lt; btn)) != 0);\n&#125;\n\nconst char *Common_BtnStr(Common_Button btn)\n&#123;\n    switch (btn)\n    &#123;\n        case BTN_ACTION1: return &quot;A&quot;;\n        case BTN_ACTION2: return &quot;B&quot;;\n        case BTN_ACTION3: return &quot;C&quot;;\n        case BTN_ACTION4: return &quot;D&quot;;\n        case BTN_UP:      return &quot;Up&quot;;\n        case BTN_DOWN:    return &quot;Down&quot;;\n        case BTN_LEFT:    return &quot;Left&quot;;\n        case BTN_RIGHT:   return &quot;Right&quot;;\n        case BTN_MORE:    return &quot;E&quot;;\n        case BTN_QUIT:    return &quot;Back&quot;;\n        default:          return &quot;Unknown&quot;;\n    &#125;\n&#125;\n\nconst char *Common_MediaPath(const char *fileName)\n&#123;\n    char *filePath = (char *)calloc(256, sizeof(char));\n\n    strcat(filePath, &quot;file:///android_asset/&quot;);\n    strcat(filePath, fileName);\n    gPathList.push_back(filePath);\n\n    return filePath;\n&#125;\n\nconst char *Common_WritePath(const char *fileName)\n&#123;\n    return Common_MediaPath(fileName);\n&#125;\n\nbool Common_SuspendState()\n&#123;\n    return gSuspendState;\n&#125;\n\nextern &quot;C&quot;\n&#123;\n\njstring Java_org_fmod_core_FmodUtils_getButtonLabel(JNIEnv *env, jobject thiz, jint index)\n&#123;\n    return env-&gt;NewStringUTF(Common_BtnStr((Common_Button)index));\n&#125;\n\nvoid Java_org_fmod_core_FmodUtils_buttonDown(JNIEnv *env, jobject thiz, jint index)\n&#123;\n    gDownButtons |= (1 &lt;&lt; index);\n&#125;\n\nvoid Java_org_fmod_core_FmodUtils_buttonUp(JNIEnv *env, jobject thiz, jint index)\n&#123;\n    gDownButtons &amp;= ~(1 &lt;&lt; index);\n&#125;\n\nvoid Java_org_fmod_core_FmodUtils_setStateCreate(JNIEnv *env, jobject thiz)\n&#123;\n\n&#125;\n\nvoid Java_org_fmod_core_FmodUtils_setStateStart(JNIEnv *env, jobject thiz)\n&#123;\n    gSuspendState = false;\n&#125;\n\nvoid Java_org_fmod_core_FmodUtils_setStateStop(JNIEnv *env, jobject thiz)\n&#123;\n    gSuspendState = true;\n&#125;\n\nvoid Java_org_fmod_core_FmodUtils_setStateDestroy(JNIEnv *env, jobject thiz)\n&#123;\n    gQuitState = true;\n&#125;\n\nvoid Java_org_fmod_core_FmodUtils_main(JNIEnv *env, jobject thiz,jobject act)\n&#123;\n    gJNIEnv = env;\n    gMainActivityObject = act;\n\n    FMOD_Main();\n&#125;\n\n&#125; /* extern &quot;C&quot; */\n1.3 替换MainActivity将 org.fmod.example.MainActivity 复制到自己的包路径下 ， 删除文件中 native 方法和 static 方法，新增 mFmodUtils 成员变量，并实例化，将调用 native 方法的地方都改成 mFmodUtils 实例下的方法，注意 main() 方法需要传当前 Activity 进去\npublic class MainActivity extends Activity implements OnTouchListener, Runnable &#123;\n    private TextView mTxtScreen;\n    private Thread mThread;\n    private FmodUtils mFmodUtils;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) &#123;\n        super.onCreate(savedInstanceState);\n        mFmodUtils = FmodUtils.getInstance();\n        // Create the text area\n        mTxtScreen = new TextView(this);\n        mTxtScreen.setTextSize(TypedValue.COMPLEX_UNIT_SP, 10.0f);\n        mTxtScreen.setTypeface(Typeface.MONOSPACE);\n\n        // Create the buttons\n        Button[] buttons = new Button[9];\n        for (int i = 0; i &lt; buttons.length; i++) &#123;\n            buttons[i] = new Button(this);\n            buttons[i].setText(mFmodUtils.getButtonLabel(i));\n            buttons[i].setOnTouchListener(this);\n            buttons[i].setId(i);\n        &#125;\n\n        // Create the button row layouts\n        LinearLayout llTopRowButtons = new LinearLayout(this);\n        llTopRowButtons.setOrientation(LinearLayout.HORIZONTAL);\n        LinearLayout llMiddleRowButtons = new LinearLayout(this);\n        llMiddleRowButtons.setOrientation(LinearLayout.HORIZONTAL);\n        LinearLayout llBottomRowButtons = new LinearLayout(this);\n        llBottomRowButtons.setOrientation(LinearLayout.HORIZONTAL);\n\n        // Create the main view layout\n        LinearLayout llView = new LinearLayout(this);\n        llView.setOrientation(LinearLayout.VERTICAL);\n\n        // Create layout parameters\n        LayoutParams lpLayout = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, 1.0f);\n\n        // Set up the view hierarchy\n        llTopRowButtons.addView(buttons[0], lpLayout);\n        llTopRowButtons.addView(buttons[6], lpLayout);\n        llTopRowButtons.addView(buttons[1], lpLayout);\n        llMiddleRowButtons.addView(buttons[4], lpLayout);\n        llMiddleRowButtons.addView(buttons[8], lpLayout);\n        llMiddleRowButtons.addView(buttons[5], lpLayout);\n        llBottomRowButtons.addView(buttons[2], lpLayout);\n        llBottomRowButtons.addView(buttons[7], lpLayout);\n        llBottomRowButtons.addView(buttons[3], lpLayout);\n        llView.addView(mTxtScreen, lpLayout);\n        llView.addView(llTopRowButtons);\n        llView.addView(llMiddleRowButtons);\n        llView.addView(llBottomRowButtons);\n\n        setContentView(llView);\n\n        // Request necessary permissions\n        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;\n            String[] perms = &#123;&quot;android.permission.RECORD_AUDIO&quot;, &quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&#125;;\n            if (checkSelfPermission(perms[0]) == PackageManager.PERMISSION_DENIED ||\n                    checkSelfPermission(perms[1]) == PackageManager.PERMISSION_DENIED) &#123;\n                requestPermissions(perms, 200);\n            &#125;\n        &#125;\n\n        org.fmod.FMOD.init(this);\n\n        mThread = new Thread(this, &quot;Example Main&quot;);\n        mThread.start();\n\n        mFmodUtils.setStateCreate();\n    &#125;\n\n    @Override\n    protected void onStart() &#123;\n        super.onStart();\n        mFmodUtils.setStateStart();\n    &#125;\n\n    @Override\n    protected void onStop() &#123;\n        mFmodUtils.setStateStop();\n        super.onStop();\n    &#125;\n\n    @Override\n    protected void onDestroy() &#123;\n        mFmodUtils.setStateDestroy();\n\n        try &#123;\n            mThread.join();\n        &#125; catch (InterruptedException e) &#123;\n        &#125;\n\n        org.fmod.FMOD.close();\n\n        super.onDestroy();\n    &#125;\n\n    @Override\n    public boolean onTouch(View view, MotionEvent motionEvent) &#123;\n        if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) &#123;\n            mFmodUtils.buttonDown(view.getId());\n        &#125; else if (motionEvent.getAction() == MotionEvent.ACTION_UP) &#123;\n            mFmodUtils.buttonUp(view.getId());\n        &#125;\n\n        return true;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        mFmodUtils.main(this);\n    &#125;\n\n    public void updateScreen(final String text) &#123;\n        runOnUiThread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                mTxtScreen.setText(text);\n            &#125;\n        &#125;);\n    &#125;\n\n\n&#125;\n1.4 更改AndroidManifest更改 AndroidManifest.xml 文件中的启动页的 Activity 为自己包路径下的 MainActivity ，删除fmod 示例的 MainActivity ,就可以运行成功了\n2、实现按钮 D 和 E 播放音频我们使用 singing.wav 和 wave.mp3 来实现 D 和 E 按钮播放音频的功能\n2.1 加载音频文件在play_sound.cpp 中的 FMOD_Main() 函数中的do…while前，定义 sound4 和 sound5 变量，然后使用这两个变量加载对应的音频文件\n    FMOD::System     *system;\n    // 新增属性 sound4 和 sound5\n    FMOD::Sound      *sound1, *sound2, *sound3, *sound4, *sound5;\n    FMOD::Channel    *channel = 0;\n    FMOD_RESULT       result;\n    unsigned int      version;\n    void             *extradriverdata = 0;\n\n    Common_Init(&amp;extradriverdata);\n\n    /*\n        Create a System object and initialize\n    */\n    result = FMOD::System_Create(&amp;system);\n    ERRCHECK(result);\n\n    result = system-&gt;getVersion(&amp;version);\n    ERRCHECK(result);\n\n    if (version &lt; FMOD_VERSION)\n    &#123;\n        Common_Fatal(&quot;FMOD lib version %08x doesn&#39;t match header version %08x&quot;, version, FMOD_VERSION);\n    &#125;\n\n    result = system-&gt;init(32, FMOD_INIT_NORMAL, extradriverdata);\n    ERRCHECK(result);\n\n    result = system-&gt;createSound(Common_MediaPath(&quot;drumloop.wav&quot;), FMOD_DEFAULT, 0, &amp;sound1);\n    ERRCHECK(result);\n\n    result = sound1-&gt;setMode(FMOD_LOOP_OFF);    /* drumloop.wav has embedded loop points which automatically makes looping turn on, */\n    ERRCHECK(result);                           /* so turn it off here.  We could have also just put FMOD_LOOP_OFF in the above CreateSound call. */\n\n    result = system-&gt;createSound(Common_MediaPath(&quot;jaguar.wav&quot;), FMOD_DEFAULT, 0, &amp;sound2);\n    ERRCHECK(result);\n\n    result = system-&gt;createSound(Common_MediaPath(&quot;swish.wav&quot;), FMOD_DEFAULT, 0, &amp;sound3);\n    ERRCHECK(result);\n\n    //为sound4 加载音频文件singing.wav\n    result = system-&gt;createSound(Common_MediaPath(&quot;singing.wav&quot;), FMOD_DEFAULT, 0, &amp;sound4);\n    ERRCHECK(result);\n\n    //为sound5 加载音频文件wave.mp3\n    result = system-&gt;createSound(Common_MediaPath(&quot;wave.mp3&quot;), FMOD_DEFAULT, 0, &amp;sound5);\n    ERRCHECK(result);2.2 将音频播放与按钮事件关联在play_sound.cpp 中的 FMOD_Main() 函数中的do…while的{}中，处理 D 和 E 按钮的事件，播放sound4 和 sound 5 , 按钮的事件类型可在 common_platform.cpp 中的 Common_BtnStr 函数中查看\nCommon_BtnStr 函数\nconst char *Common_BtnStr(Common_Button btn)\n&#123;\n    switch (btn)\n    &#123;\n        case BTN_ACTION1: return &quot;A&quot;;\n        case BTN_ACTION2: return &quot;B&quot;;\n        case BTN_ACTION3: return &quot;C&quot;;\n        case BTN_ACTION4: return &quot;D&quot;;\n        case BTN_UP:      return &quot;Up&quot;;\n        case BTN_DOWN:    return &quot;Down&quot;;\n        case BTN_LEFT:    return &quot;Left&quot;;\n        case BTN_RIGHT:   return &quot;Right&quot;;\n        case BTN_MORE:    return &quot;E&quot;;\n        case BTN_QUIT:    return &quot;Back&quot;;\n        default:          return &quot;Unknown&quot;;\n    &#125;\n&#125;\n处理 D 和 E 按钮的事件，播放音频\n        //处理按钮 D 的事件，播放 sound4\n        if (Common_BtnPress(BTN_ACTION4))\n        &#123;\n            result = system-&gt;playSound(sound4, 0, false, &amp;channel);\n            ERRCHECK(result);\n        &#125;\n\n        //处理按钮 E 的事件，播放 sound5\n        if (Common_BtnPress(BTN_MORE))\n        &#123;\n            result = system-&gt;playSound(sound5, 0, false, &amp;channel);\n            ERRCHECK(result);\n        &#125;2.3 释放 sound4 和 sound5在do…while 执行之后，释放加载了对应音频文件的属性\n/*\n        Shut down\n    */\n    result = sound1-&gt;release();\n    ERRCHECK(result);\n    result = sound2-&gt;release();\n    ERRCHECK(result);\n    result = sound3-&gt;release();\n    ERRCHECK(result);\n\n    //释放sound4\n    result = sound4-&gt;release();\n    ERRCHECK(result);\n    //释放sound5\n    result = sound5-&gt;release();\n    ERRCHECK(result);\n\n    result = system-&gt;close();\n    ERRCHECK(result);\n    result = system-&gt;release();\n    ERRCHECK(result);\n\n    Common_Close();2.4 play_sound.cpp 完整代码更改完成之后，按钮D 和 E 播放音频的功能实现了，点击运行就可以了，下面贴上play_sound.cpp的完整代码\n/*==============================================================================\nPlay Sound Example\nCopyright (c), Firelight Technologies Pty, Ltd 2004-2019.\n\nThis example shows how to simply load and play multiple sounds, the simplest \nusage of FMOD. By default FMOD will decode the entire file into memory when it\nloads. If the sounds are big and possibly take up a lot of RAM it would be\nbetter to use the FMOD_CREATESTREAM flag, this will stream the file in realtime\nas it plays.\n==============================================================================*/\n#include &quot;inc/fmod.hpp&quot;\n#include &quot;common.h&quot;\n\nint FMOD_Main()\n&#123;\n    FMOD::System     *system;\n    // 新增属性 sound4 和 sound5\n    FMOD::Sound      *sound1, *sound2, *sound3, *sound4, *sound5;\n    FMOD::Channel    *channel = 0;\n    FMOD_RESULT       result;\n    unsigned int      version;\n    void             *extradriverdata = 0;\n\n    Common_Init(&amp;extradriverdata);\n\n    /*\n        Create a System object and initialize\n    */\n    result = FMOD::System_Create(&amp;system);\n    ERRCHECK(result);\n\n    result = system-&gt;getVersion(&amp;version);\n    ERRCHECK(result);\n\n    if (version &lt; FMOD_VERSION)\n    &#123;\n        Common_Fatal(&quot;FMOD lib version %08x doesn&#39;t match header version %08x&quot;, version, FMOD_VERSION);\n    &#125;\n\n    result = system-&gt;init(32, FMOD_INIT_NORMAL, extradriverdata);\n    ERRCHECK(result);\n\n    result = system-&gt;createSound(Common_MediaPath(&quot;drumloop.wav&quot;), FMOD_DEFAULT, 0, &amp;sound1);\n    ERRCHECK(result);\n\n    result = sound1-&gt;setMode(FMOD_LOOP_OFF);    /* drumloop.wav has embedded loop points which automatically makes looping turn on, */\n    ERRCHECK(result);                           /* so turn it off here.  We could have also just put FMOD_LOOP_OFF in the above CreateSound call. */\n\n    result = system-&gt;createSound(Common_MediaPath(&quot;jaguar.wav&quot;), FMOD_DEFAULT, 0, &amp;sound2);\n    ERRCHECK(result);\n\n    result = system-&gt;createSound(Common_MediaPath(&quot;swish.wav&quot;), FMOD_DEFAULT, 0, &amp;sound3);\n    ERRCHECK(result);\n\n    //为sound4 加载音频文件singing.wav\n    result = system-&gt;createSound(Common_MediaPath(&quot;singing.wav&quot;), FMOD_DEFAULT, 0, &amp;sound4);\n    ERRCHECK(result);\n\n    //为sound5 加载音频文件wave.mp3\n    result = system-&gt;createSound(Common_MediaPath(&quot;wave.mp3&quot;), FMOD_DEFAULT, 0, &amp;sound5);\n    ERRCHECK(result);\n\n    /*\n        Main loop\n    */\n    do\n    &#123;\n        Common_Update();\n\n        if (Common_BtnPress(BTN_ACTION1))\n        &#123;\n            result = system-&gt;playSound(sound1, 0, false, &amp;channel);\n            ERRCHECK(result);\n        &#125;\n\n        if (Common_BtnPress(BTN_ACTION2))\n        &#123;\n            result = system-&gt;playSound(sound2, 0, false, &amp;channel);\n            ERRCHECK(result);\n        &#125;\n\n        if (Common_BtnPress(BTN_ACTION3))\n        &#123;\n            result = system-&gt;playSound(sound3, 0, false, &amp;channel);\n            ERRCHECK(result);\n        &#125;\n\n        //处理按钮 D 的事件，播放 sound4\n        if (Common_BtnPress(BTN_ACTION4))\n        &#123;\n            result = system-&gt;playSound(sound4, 0, false, &amp;channel);\n            ERRCHECK(result);\n        &#125;\n\n        //处理按钮 E 的事件，播放 sound5\n        if (Common_BtnPress(BTN_MORE))\n        &#123;\n            result = system-&gt;playSound(sound5, 0, false, &amp;channel);\n            ERRCHECK(result);\n        &#125;\n\n        result = system-&gt;update();\n        ERRCHECK(result);\n\n        &#123;\n            unsigned int ms = 0;\n            unsigned int lenms = 0;\n            bool         playing = 0;\n            bool         paused = 0;\n            int          channelsplaying = 0;\n\n            if (channel)\n            &#123;\n                FMOD::Sound *currentsound = 0;\n\n                result = channel-&gt;isPlaying(&amp;playing);\n                if ((result != FMOD_OK) &amp;&amp; (result != FMOD_ERR_INVALID_HANDLE) &amp;&amp; (result != FMOD_ERR_CHANNEL_STOLEN))\n                &#123;\n                    ERRCHECK(result);\n                &#125;\n\n                result = channel-&gt;getPaused(&amp;paused);\n                if ((result != FMOD_OK) &amp;&amp; (result != FMOD_ERR_INVALID_HANDLE) &amp;&amp; (result != FMOD_ERR_CHANNEL_STOLEN))\n                &#123;\n                    ERRCHECK(result);\n                &#125;\n\n                result = channel-&gt;getPosition(&amp;ms, FMOD_TIMEUNIT_MS);\n                if ((result != FMOD_OK) &amp;&amp; (result != FMOD_ERR_INVALID_HANDLE) &amp;&amp; (result != FMOD_ERR_CHANNEL_STOLEN))\n                &#123;\n                    ERRCHECK(result);\n                &#125;\n\n                channel-&gt;getCurrentSound(&amp;currentsound);\n                if (currentsound)\n                &#123;\n                    result = currentsound-&gt;getLength(&amp;lenms, FMOD_TIMEUNIT_MS);\n                    if ((result != FMOD_OK) &amp;&amp; (result != FMOD_ERR_INVALID_HANDLE) &amp;&amp; (result != FMOD_ERR_CHANNEL_STOLEN))\n                    &#123;\n                        ERRCHECK(result);\n                    &#125;\n                &#125;\n            &#125;\n\n            system-&gt;getChannelsPlaying(&amp;channelsplaying, NULL);\n\n            Common_Draw(&quot;==================================================&quot;);\n            Common_Draw(&quot;Play Sound Example.&quot;);\n            Common_Draw(&quot;Copyright (c) Firelight Technologies 2004-2019.&quot;);\n            Common_Draw(&quot;==================================================&quot;);\n            Common_Draw(&quot;&quot;);\n            Common_Draw(&quot;Press %s to play a mono sound (drumloop)&quot;, Common_BtnStr(BTN_ACTION1));\n            Common_Draw(&quot;Press %s to play a mono sound (jaguar)&quot;, Common_BtnStr(BTN_ACTION2));\n            Common_Draw(&quot;Press %s to play a stereo sound (swish)&quot;, Common_BtnStr(BTN_ACTION3));\n            Common_Draw(&quot;Press %s to quit&quot;, Common_BtnStr(BTN_QUIT));\n            Common_Draw(&quot;&quot;);\n            Common_Draw(&quot;Time %02d:%02d:%02d/%02d:%02d:%02d : %s&quot;, ms / 1000 / 60, ms / 1000 % 60, ms / 10 % 100, lenms / 1000 / 60, lenms / 1000 % 60, lenms / 10 % 100, paused ? &quot;Paused &quot; : playing ? &quot;Playing&quot; : &quot;Stopped&quot;);\n            Common_Draw(&quot;Channels Playing %d&quot;, channelsplaying);\n        &#125;\n\n        Common_Sleep(50);\n    &#125; while (!Common_BtnPress(BTN_QUIT));\n\n    /*\n        Shut down\n    */\n    result = sound1-&gt;release();\n    ERRCHECK(result);\n    result = sound2-&gt;release();\n    ERRCHECK(result);\n    result = sound3-&gt;release();\n    ERRCHECK(result);\n\n    //释放sound4\n    result = sound4-&gt;release();\n    ERRCHECK(result);\n    //释放sound5\n    result = sound5-&gt;release();\n    ERRCHECK(result);\n\n    result = system-&gt;close();\n    ERRCHECK(result);\n    result = system-&gt;release();\n    ERRCHECK(result);\n\n    Common_Close();\n\n    return 0;\n&#125;\n项目源码PlaySound源码\n到此，我们实现集成 fmod 的音频播放功能已经实现，也实现了其他按钮播放音频文件的功能，这是实现模拟QQ变声项目的前期准备，后面我们会继续实现QQ变声功能。\n","categories":["NDK"],"tags":["Android","NDK","Fmod"]},{"title":"重建二叉树","url":"https://blog.onestravel.cn/20190309/3e9f753d010c/","content":"5.重建二叉树题目描述根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\npreorder:    1,2,4,7,3,5,6,8\ninorder:     4,7,2,1,5,3,8,6\n解题思路前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。\n代码实现java 代码    /**\n     * 二叉树节点\n     */\n    class TreeNode {\n        int value;\n        TreeNode left;\n        TreeNode right;\n\n        public TreeNode(int value) {\n            this.value = value;\n        }\n\n        @NonNull\n        @Override\n        public String toString() {\n            return \"TreeNode(value=\" + value + \",left=\" + left + \",right=\" + right + \")\";\n        }\n    }\n\n    /**\n     * 根据前序遍历和中序变量重建二叉树\n     *\n     * @param pre    前序遍历\n     * @param middle 中序遍历\n     */\n    private TreeNode reConstructBinaryTree(int[] pre, int[] middle) {\n        return reConstructBinaryTree(pre, 0, pre.length - 1, middle, 0, middle.length - 1);\n    }\n\n    /**\n     * 根据前序遍历和中序变量重建二叉树\n     *\n     * @param pre         前序遍历\n     * @param preStart    前序遍历开始位置\n     * @param preEnd      前序遍历结束位置\n     * @param middle      中序遍历\n     * @param middleStart 中序遍历开始位置\n     * @param middleEnd   中序遍历结束位置\n     */\n    private TreeNode reConstructBinaryTree(int[] pre, int preStart, int preEnd, int[] middle, int middleStart, int middleEnd) {\n        if (preStart > preEnd || middleStart > middleEnd) {\n            return null;\n        }\n        TreeNode node = new TreeNode(pre[preStart]);\n        for (int i = middleStart; i &lt;= middleEnd; i++) {\n            if (pre[preStart] == middle[i]) {\n                int leftCount = i - middleStart;\n                node.left = reConstructBinaryTree(pre, preStart + 1,preStart+leftCount,middle,middleStart,i-1);\n                node.right = reConstructBinaryTree(pre,preStart+leftCount+1,preEnd,middle,i+1,middleEnd);\n            }\n        }\n        return node;\n    }\n\n    public static void main(String[] args){\n\n    }\nKotlin 代码    /**\n     * 二叉树节点\n     */\n    data class TreeNode(val value: Int,var left: TreeNode? = null,var right: TreeNode? = null) \n\n\n    /**\n     * 根据前序遍历和中序变量重建二叉树\n     * @param pre 前序遍历\n     * @param middle 中序遍历\n     */\n    private fun reConstructBinaryTree(pre: IntArray, middle: IntArray): TreeNode? {\n        return reConstructBinaryTree(pre, 0, pre.size - 1, middle, 0, middle.size - 1)\n    }\n\n    /**\n     * 根据前序遍历和中序变量重建二叉树\n     * @param pre 前序遍历\n     * @param preStart 前序遍历开始位置\n     * @param preEnd 前序遍历结束位置\n     * @param middle 中序遍历\n     * @param middleStart 中序遍历开始位置\n     * @param middleEnd 中序遍历结束位置\n     */\n    private fun reConstructBinaryTree(\n        pre: IntArray,\n        preStart: Int,\n        preEnd: Int,\n        middle: IntArray,\n        middleStart: Int,\n        middleEnd: Int\n    ): TreeNode? {\n        if(preStart>preEnd||middleStart>preEnd){\n            return null\n        }\n        //前序遍历起始值作为当前节点的值\n        val node = TreeNode(pre[preStart])\n        for (i in middleStart..middleEnd) {\n            //找到中序遍历中与前序遍历当前节点值相同的位置i，\n            // 则中序遍历中该位置i前的都是左子树，该位置i后的都是右子树\n            if (pre[preStart] == middle[i]) {\n                //左子树递归\n                val leftCount = i - middleStart\n                node.left = reConstructBinaryTree(\n                    pre,\n                    preStart + 1,\n                    preStart + leftCount,\n                    middle,\n                    middleStart,\n                    i - 1\n                )\n                //右子树递归\n                node.right = reConstructBinaryTree(\n                    pre,\n                    preStart + 1 + leftCount,\n                    preEnd,\n                    middle,\n                    i + 1,\n                    middleEnd\n                )\n            }\n        }\n        return node\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        val pre = intArrayOf(1,2,4,7,3,5,6,8)\n        val middle = intArrayOf(4,7,2,1,5,3,8,6)\n        println(reConstructBinaryTree(pre,middle))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["二叉树"]},{"title":"从尾到头打印链表","url":"https://blog.onestravel.cn/20190306/e374861c3445/","content":"4.从尾到头打印链表题目描述从尾到头反过来打印出每个结点的值。\n如：input:\ngraph LR\n1--&gt;2\n2--&gt;3output:\n3,2,1解题思路1. 递归实现要实现逆序打印链表 1-&gt;2-&gt;3;可以使用使用递归，先将链表看做当前节点和右侧节点两部分；如：1-&gt;(2-&gt;3),先打印右侧节点,再打印当前节点：右侧节点也可以看做两部分如：(2)-&gt;(3),也是先打印当前节点的右侧节点，在打印当前节点；如此递归，可实现逆序打印。\n代码实现java 代码    /**\n     * 单向链表节点\n     * @param &lt;T>\n     */\n    class LinkedNode&lt;T extends Object>{\n        private T value;\n        private LinkedNode&lt;T> next;\n\n        public T getValue() {\n            return value;\n        }\n\n        public void setValue(T value) {\n            this.value = value;\n        }\n\n        public LinkedNode&lt;T> getNext() {\n            return next;\n        }\n\n        public void setNext(LinkedNode&lt;T> next) {\n            this.next = next;\n        }\n    }\n    /**\n     * 反向打印链表\n     * @param node 链表首节点\n     * @return\n     */\n    private ArrayList&lt;Integer> printReverseLink( LinkedNode&lt;Integer> node) {\n        ArrayList&lt;Integer>  list = new ArrayList();\n        if (node!=null){\n            list.addAll(printReverseLink(node.next));\n            list.add(node.value);\n        }\n        return list;\n    }\n\n    public static void main(String[] args){\n        LinkedNode&lt;Integer> first = new LinkedNode&lt;>();\n        first.setValue(1);\n        LinkedNode&lt;Integer> two = new LinkedNode&lt;>();\n        two.setValue(2);\n        LinkedNode&lt;Integer> three = new LinkedNode&lt;>();\n        three.setValue(3);\n        two.setNext(three);\n        first.setNext(two);\n        System.out.println(printReverseLink(first));\n    }\nKotlin 代码    /**\n     * 单向链表节点\n     */\n    data class LinkedNode&lt;T : Any?>(var value: T) {\n        var next: LinkedNode&lt;T>? = null\n    }\n\n    /**\n     * 反向打印链表\n     * @param node 链表首节点\n     * @return\n     */\n    private fun printReverseLink(node: LinkedNode&lt;Int>?):ArrayList&lt;Int> {\n        val list = ArrayList&lt;Int>()\n        if (node!=null){\n            list.addAll(printReverseLink(node.next))\n            list.add(node.value)\n        }\n        return list\n    }\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        val first = LinkedNode(1)\n        first.next = LinkedNode(2)\n        first.next?.next = LinkedNode(3)\n        print(printReverseLink(first))\n    }\n\n2. 使用头插法头插法顾名思义是将节点插入到头部：在遍历原始链表时，将当前节点插入新链表的头部，使其成为第一个节点。\n链表的操作需要维护后继关系，例如在某个节点 node1 之后插入一个节点 node2，我们可以通过修改后继关系来实现：\nnode3 = node1.next;\nnode2.next = node3;\nnode1.next = node2;为了能将一个节点插入头部，我们引入了一个叫头结点的辅助节点，该节点不存储值，只是为了方便进行插入操作。不要将头结点与第一个节点混起来，第一个节点是链表中第一个真正存储值的节点。\ngraph LR\n1--&gt;2\n2--&gt;3引入head节点\ngraph LR\nhead循环遍历链接，插入头结点后\nnode=1\ngraph LR\nhead--&gt;1node=2\ngraph LR\nhead--&gt;2\n2--&gt;1node=3\ngraph LR\nhead--&gt;3\n3--&gt;2\n2--&gt;1代码实现java 代码    /**\n     * 头插法实现反向打印链表\n     * \n     * @param node 链表首节点\n     * @return\n     */\n    private ArrayList&lt;Integer> printReverseLinkToHead(LinkedNode&lt;Integer> node) {\n        LinkedNode&lt;Integer> head = new LinkedNode&lt;>();\n        head.setValue(-1);\n        while (node != null) {\n            LinkedNode&lt;Integer> next = node.getNext();\n            node.setNext(head.getNext());\n            head.setNext(node);\n            node = next;\n        }\n        ArrayList&lt;Integer> list = new ArrayList();\n        head = head.getNext();\n        while (head != null) {\n            list.add(head.getValue());\n            head = head.getNext();\n        }\n        return list;\n    }\n\n    public static void main(String[] args){\n        LinkedNode&lt;Integer> first = new LinkedNode&lt;>();\n        first.setValue(1);\n        LinkedNode&lt;Integer> two = new LinkedNode&lt;>();\n        two.setValue(2);\n        LinkedNode&lt;Integer> three = new LinkedNode&lt;>();\n        three.setValue(3);\n        two.setNext(three);\n        first.setNext(two);\n\n        System.out.println(printReverseLinkToHead(first));\n    }\nKotlin 代码    /**\n     * 使用头插法反向打印链表\n     * @param node 链表首节点\n     * @return\n     */\n    private fun printReverseLinkToHead(node: LinkedNode&lt;Int>?):ArrayList&lt;Int> {\n        var currentNode = node\n        var head:LinkedNode&lt;Int>? = LinkedNode(-1)\n        while (currentNode!=null){\n            val next = currentNode.next\n            currentNode?.next = head!!.next\n            head!!.next = currentNode\n            currentNode = next\n        }\n        val list = ArrayList&lt;Int>()\n        head = head!!.next\n        while (head!=null){\n            list.add(head.value)\n            head = head.next\n        }\n        return list\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        val first = ListNode(1)\n        first.next = ListNode(2)\n        first.next?.next = ListNode(3)\n        print(printReverseLinkToHead(first))\n    }\n\n3. 使用栈来实现栈的规则时后进先出，则可以将链表遍历存放到栈中，然后在出栈则出栈顺序就是反向打印链表\n代码实现java 代码    /**\n     * 使用栈实现反向打印链表\n     *\n     * @param node 链表首节点\n     * @return\n     */\n    private ArrayList&lt;Integer> printReverseLinkToHeadWithStack(LinkedNode&lt;Integer> node){\n        Stack&lt;Integer> stack = new Stack&lt;>();\n        while (node != null) {\n            stack.add(node.getValue());\n            node = node.next;\n        }\n        ArrayList&lt;Integer> list = new ArrayList();\n        while (!stack.isEmpty()) {\n            list.add(stack.pop());\n        }\n        return list;\n    }\n\n    public static void main(String[] args){\n        LinkedNode&lt;Integer> first = new LinkedNode&lt;>();\n        first.setValue(1);\n        LinkedNode&lt;Integer> two = new LinkedNode&lt;>();\n        two.setValue(2);\n        LinkedNode&lt;Integer> three = new LinkedNode&lt;>();\n        three.setValue(3);\n        two.setNext(three);\n        first.setNext(two);\n\n        System.out.println(printReverseLinkToHeadWithStack(first));\n    }\nKotlin 代码    /**\n     * 使用栈反向打印链表\n     * @param node 链表首节点\n     * @return\n     */\n    private fun printReverseLinkToHeadWithStack(node: LinkedNode&lt;Int>?): ArrayList&lt;Int> {\n        val stack = Stack&lt;Int>()\n        var current = node\n        while (current != null) {\n            stack.push(current.value)\n            current = current.next\n        }\n        val list = ArrayList&lt;Int>()\n        while (!stack.empty()) {\n            list.add(stack.pop())\n        }\n        return list\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        val first = ListNode(1)\n        first.next = ListNode(2)\n        first.next?.next = ListNode(3)\n        print(printReverseLinkToHeadWithStack(first))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["链表"]},{"title":"替换空格","url":"https://blog.onestravel.cn/20190305/e19bc6160629/","content":"3.替换空格题目描述将一个字符串中的空格替换成 “%20”。\n解题思路\n在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。\n\n令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。\n\n当 P2 遇到 P1 时（P2 &lt;= P1），或者遍历结束（P1 &lt; 0），退出。\n\n\n代码实现java 代码    /**\n     * 替换空格\n     * @param str 需要替换空格的字符串\n     * @return\n     */\n    private String replaceSpace(String str) {\n        StringBuffer sb = new StringBuffer(str);\n        int P1 = sb.length() - 1;\n        for (int i = 0; i &lt;= P1; i++)\n            if (sb.charAt(i) == ' ')\n                sb.append(\"  \");\n\n        int P2 = sb.length() - 1;\n        while (P1 >= 0 &amp;&amp; P2 > P1) {\n            char c = sb.charAt(P1--);\n            if (c == ' ') {\n                sb.setCharAt(P2--, '0');\n                sb.setCharAt(P2--, '2');\n                sb.setCharAt(P2--, '%');\n            } else {\n                sb.setCharAt(P2--, c);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * 入口函数\n     */\n    public static void main(String[] args){\n        String string = \"A B\";\n        System.out.println(replaceSpace(string));\n    }\nKotlin 代码    private fun replaceSpace(string: String): String {\n        val sb = StringBuffer(string)\n        var p1 = sb.length - 1\n        sb.apply {\n            for (c in sb.indices) {\n                if (sb[c] == ' ') {\n                    append(\"  \")\n                }\n            }\n            var p2 = sb.length - 1\n            while (p1 in 0 until p2) {\n                val char = get(p1--)\n                if (char == ' ') {\n                    setCharAt(p2--, '0')\n                    setCharAt(p2--, '2')\n                    setCharAt(p2--, '%')\n                } else {\n                    setCharAt(p2--, char)\n                }\n            }\n        }\n        return sb.toString()\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        val input = \"A B\"\n        println(replaceSpace(input))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["字符串"]},{"title":"AndroidStudio下NDK开发流程","url":"https://blog.onestravel.cn/20190301/bbaecd69193b/","content":"AndroidStudio下NDK开发流程前言使用Android Studio进行NDK开发时，可在创建Android Studio项目时选择创建C++项目，创建好之后，默认会在src/main/下创建一个cpp的文件夹，C/C++相关的文件就存放在这个文件夹中；在app下面的build.gradle中有NDK的相关配置\n一、NDK开发进行文件加密解密1、实现Java层native方法\n创建Android项目\n写一个含有加密和解密按钮的view\n\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;Button\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;加密&quot;\n        android:onClick=&quot;mCrypt&quot;/&gt;\n\n    &lt;Button\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;解密&quot;\n        android:onClick=&quot;mDecrypt&quot;/&gt;\n\n&lt;/LinearLayout&gt;\n编写一个实现对文件加密解密的java类: Crpytor.java\n\npackage com.example.ndk.filecrypt;\n\n\npublic class Cryptor &#123;\n\n    static &#123;\n        System.loadLibrary(&quot;cryptor&quot;);\n    &#125;\n\n    /**\n     * 对文件进行加密\n     * @param path 需要加密的文件路径\n     * @return 加密后的文件路径\n     */\n    public native static void crypt(String path,String cryptPath);\n\n    /**\n     * 对文件进行解密\n     * @param cryptPath 加密文件的路径\n     * @return 解密后的文件路径\n     */\n    public native static void decrypt(String cryptPath,String decryptPath);\n&#125;\n\n在View对应的java类中实现相应的点击事件\n\npublic class MainActivity extends AppCompatActivity &#123;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) &#123;\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    &#125;\n\n    /**\n     * 加密的点击事件\n     *\n     * @param view\n     */\n    public void mCrypt(View view) &#123;\n        File sdDir = Environment.getExternalStorageDirectory();\n        String sdpath = sdDir.getAbsolutePath();\n\n        String path = sdpath + &quot;/ndk.jpg&quot;;\n        String cryptPath = sdpath + &quot;/ndk_crypt.jpg&quot;;\n        Cryptor.crypt(path, cryptPath);\n        Toast.makeText(this, &quot;加密完成&quot;, Toast.LENGTH_SHORT).show();\n    &#125;\n\n    /**\n     * 解密的点击事件\n     *\n     * @param view\n     */\n    public void mDecrypt(View view) &#123;\n        File sdDir = Environment.getExternalStorageDirectory();\n        String sdpath = sdDir.getAbsolutePath();\n\n        String cryptPath = sdpath + &quot;/ndk_crypt.jpg&quot;;\n        String decryptPath = sdpath + &quot;/ndk_decrypt.jpg&quot;;\n        Cryptor.decrypt(cryptPath, decryptPath);\n        Toast.makeText(this, &quot;解密完成&quot;, Toast.LENGTH_SHORT).show();\n    &#125;\n&#125;\n2、使用 javah 命令生成头文件\n执行javah命令，因为AndroidStudio使用的是UTF-8的编码，所以在执行javah命令时需要指定编码为UTF-8(默认为GBK);\n\njavah -encoding UTF-8 com.example.ndk.filecrypt.Cryptor\n生成 com_example_ndk_filecrypt_Cryptor.h 文件\n\n3、创建JNI/CPP目录，添加NDK本地支持\n在src/main目录下创建jni/cpp目录，将刚刚生成的.h文件复制到该目录下\n在项目配置中设置 Android NDK location 目录，需要提前下载 NDK 相关支持 (在Android SDK 下载中选择 SDK Tools 中的 LLDB 、CMake 、NDK 三项进行下载)\n在jni 目录下创建 CMakeLists.txt 文件\n\n# cmake 版本\ncmake_minimum_required(VERSION 3.4.1)\n\n# 添加支持\nadd_library( # 为library设置名称\n             cryptor\n\n             # 设置该library为共享的\n             SHARED\n\n             # 提供C/C++相关文件的相对路径\n             cryptor.c )\n\n\nfind_library( # Sets the name of the path variable.\n              log-lib\n\n              # Specifies the name of the NDK library that\n              # you want CMake to locate.\n              log )\n\ntarget_link_libraries( # Specifies the target library.与上面add_library的名称相同\n                       cryptor\n\n                       # Links the target library to the log library\n                       # included in the NDK.\n                       $&#123;log-lib&#125; )\n在 app目录下的build.gradle 文件中配置jni 目录，以及NDK支持\n\nandroid &#123;\n\n    defaultConfig &#123;\n        // NDK的配置\n        ndk&#123;\n             moduleName &quot;cryptor&quot;\n            abiFilters  &quot;armeabi-v7a&quot;, &quot;x86&quot;\n        &#125;\n    &#125;\n\n    sourceSets &#123;\n        //配置jni目录\n        main &#123;\n            jni.srcDirs = []\n        &#125;\n    &#125;\n\n    externalNativeBuild &#123;\n        //配置cmake文件路径\n        cmake &#123;\n            path file(&#39;src/main/jni/CMakeLists.txt&#39;)\n        &#125;\n    &#125;\n\n&#125;4、实现头文件中定义的函数#include &quot;com_example_ndk_filecrypt_Cryptor.h&quot;\n#include &lt;string.h&gt;\n\nchar password[] = &quot;qazwsxedc&quot;;\n//加密\nchar *crypt(char normal_path[], char crypt_path[]) &#123;\n    //打开文件\n    FILE *normal_fp = fopen(normal_path, &quot;rb&quot;);\n    FILE *crypt_fp = fopen(crypt_path, &quot;wb&quot;);\n    //一次读取一个字符\n    int ch;\n    int i = 0;\n    int pwd_len = strlen(password);\n    while ((ch = fgetc(normal_fp)) != EOF) &#123;//End of FILE\n        //加密\n        fputc(ch ^ password[i % pwd_len], crypt_fp);\n        i++;\n    &#125;\n    fclose(normal_fp);\n    fclose(crypt_fp);\n&#125;\n\n//解密\nchar *decrypt(char crypt_path[], char decrypt_path[]) &#123;\n    //打开文件\n    FILE *crypt_fp = fopen(crypt_path, &quot;rb&quot;);\n    FILE *decrypt_fp = fopen(decrypt_path, &quot;wb&quot;);\n    //一次读取一个字符\n    int ch;\n    int i = 0;\n    int pwd_len = strlen(password);\n    while ((ch = fgetc(crypt_fp)) != EOF) &#123;//End of FILE\n        //加密\n        fputc(ch ^ password[i % pwd_len], decrypt_fp);\n        i++;\n    &#125;\n    fclose(crypt_fp);\n    fclose(decrypt_fp);\n&#125;\n\n\n\n/**\n * 加密\n * @param env\n * @param cls\n * @param jstr\n * @return\n */\nJNIEXPORT void JNICALL Java_com_example_ndk_filecrypt_Cryptor_crypt\n        (JNIEnv *env, jclass cls, jstring normal_path_str, jstring crypt_path_str) &#123;\n    char *path = (*env)-&gt;GetStringUTFChars(env, normal_path_str, NULL);\n    char *crypt_path = (*env)-&gt;GetStringUTFChars(env, crypt_path_str, NULL);\n    crypt(path, crypt_path);\n    //对变量的内存进行释放\n    (*env)-&gt;ReleaseStringChars(env, normal_path_str, path);\n    (*env)-&gt;ReleaseStringChars(env, crypt_path_str, crypt_path);\n&#125;\n\n\n/**\n * 解密\n * @param env\n * @param cls\n * @param jstr\n * @return\n */\nJNIEXPORT void JNICALL Java_com_example_ndk_filecrypt_Cryptor_decrypt\n        (JNIEnv *env, jclass cls, jstring crypt_path_str, jstring decrypt_path_str) &#123;\n    char *crypt_path = (*env)-&gt;GetStringUTFChars(env, crypt_path_str, NULL);\n    char *decrypt_path = (*env)-&gt;GetStringUTFChars(env, decrypt_path_str, NULL);\n    decrypt(crypt_path, decrypt_path);\n    //对变量的内存进行释放\n    (*env)-&gt;ReleaseStringChars(env, crypt_path_str, crypt_path);\n    (*env)-&gt;ReleaseStringChars(env, decrypt_path_str, decrypt_path);\n&#125;\n\n\n5、编译生成.so动态库\n点击Build -&gt; Make Module app \n可以在app -&gt; build -&gt; intermediates -&gt; cmake -&gt; debug -&gt; obj 下看到对应的armeabi-v7a 和 x86 的so库\n\n6、加载.so动态库，运行程序\n在src/main 目录下创建 jniLibs 文件夹\n将上面生成的 armeabi-v7a 和 x86 的so库 复制到该 jniLibs 文件夹内\n运行程序\n\n二、NDK开发进行文件拆分与合并1、实现Java层native方法\n创建Android项目\n写一个含有加密和解密按钮的view\n\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:orientation=&quot;vertical&quot;&gt;\n\n    &lt;Button\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;拆分&quot;\n        android:onClick=&quot;mDiff&quot;/&gt;\n\n    &lt;Button\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;合并&quot;\n        android:onClick=&quot;mPatch&quot;/&gt;\n\n&lt;/LinearLayout&gt;\n编写一个实现对文件拆分合并的java类: FilePatchUtils.java\n\npackage com.example.ndk.filepatch\npublic class FilePatchUtils &#123;\n    static &#123;\n        System.loadLibrary(&quot;filepatch-lib&quot;);\n    &#125;\n\n    /**\n     * 对文件进行拆分\n     * @param path  文件路径\n     * @param count 拆分成多少个\n     */\n    public native static void diff(String path,String pathPattern,int count);\n\n    /**\n     * 对文件进行合并\n     * @param pathPattern 需合并文件路径（%d）\n     * @param count 将多少个文件合并\n     * @param patchPath 合并后文件路径\n     */\n    public native static void patch(String pathPattern,int count,String patchPath);\n&#125;\n\n在View对应的java类中实现相应的点击事件\npublic class FilePatchActivity extends AppCompatActivity &#123;\n\n  private String sdpath;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) &#123;\n      super.onCreate(savedInstanceState);\n      setContentView(R.layout.activity_file_patch);\n      File sdDir = Environment.getExternalStorageDirectory();\n      sdpath = sdDir.getAbsolutePath();\n  &#125;\n\n   /**\n   * 文件拆分\n   *\n   * @param view\n   */\n  public void mDiff(View view) &#123;\n      String path = sdpath + File.separatorChar + &quot;ndk.jpg&quot;;\n      String pathPattern = sdpath + File.separatorChar + &quot;ndk_%d.jpg&quot;;\n      FilePatchUtils.diff(path, pathPattern, 3);\n      Toast.makeText(this, &quot;拆分完成&quot;, Toast.LENGTH_SHORT).show();\n  &#125;\n\n  /**\n   * 文件合并\n   *\n   * @param view\n   */\n  public void mPatch(View view) &#123;\n      String patchPath = sdpath + File.separatorChar + &quot;ndk_patch.jpg&quot;;\n      String pathPattern = sdpath + File.separatorChar + &quot;ndk_%d.jpg&quot;;\n      FilePatchUtils.patch(pathPattern, 3, patchPath);\n      Toast.makeText(this, &quot;合并完成&quot;, Toast.LENGTH_SHORT).show();\n  &#125;\n&#125;\n\n\n### 2、使用 javah 命令生成头文件\n- 执行javah命令，因为AndroidStudio使用的是UTF-8的编码，所以在执行javah命令时需要指定编码为UTF-8(默认为GBK);\njavah -encoding UTF-8 com.example.ndk.filepatch.FilePatchUtils\n- 生成 com_example_ndk_filepatch_FilePatchUtils.h 文件\n\n### 3、创建JNI目录，添加NDK本地支持\n- 在src/main目录下创建jni目录，将刚刚生成的.h文件复制到该目录下\n- 在项目配置中设置 Android NDK location 目录，需要提前下载 NDK 相关支持 (在Android SDK 下载中选择 SDK Tools 中的 LLDB 、CMake 、NDK 三项进行下载)\n- 在jni 目录下创建 CMakeLists.txt 文件;同上；\n- 在 app目录下的build.gradle 文件中配置jni 目录，以及NDK支持；同上；\n\n### 4、实现头文件中定义的函数\n#include “com_example_ndk_filepatch_FilePatchUtils.h”\n#include &lt;android/log.h&gt;\n#define LOGI(FORMAT, …) android_log_print(ANDROID_LOG_INFO,”FILE_PATCH”,FORMAT,VA_ARGS__);\n#define LOGE(FORMAT, …) android_log_print(ANDROID_LOG_ERROR,”FILE_PATCH”,##FORMAT,VA_ARGS__);\n/**\n\n获取文件大小\n@param path 文件路径\n@return 文件大小\n/long get_file_size(char *path) {  FILE *fp = fopen(path, “r”);  if (fp == NULL) {  return 0;  }  fseek(fp, 0, SEEK_END);  return ftell(fp);}\n\n/*\n\nClass:     com_example_ndk_filepatch_FilePatchUtils\n\nMethod:    diff\n\nSignature: (Ljava/lang/String;Ljava/lang/String;I)V\n\n/JNIEXPORT void JNICALL Java_com_example_ndk_filepatch_FilePatchUtils_diff\n  (JNIEnv *env, jclass cls, jstring file_path_str, jstring pattern_str, jint file_count) &#123;  const char path = (env)-&gt;GetStringUTFChars(env, file_path_str, NULL);  const char pattern = (env)-&gt;GetStringUTFChars(env, pattern_str, NULL);\n  //得到分割之后的文件的路径列表  char **filePaths = malloc(sizeof(char *) * file_count);  //读取path对应路径，循环写入子文件  int i = 0;  for (; i &lt; file_count; i++) {\n  //给元素开辟空间\n  filePaths[i] = malloc(sizeof(char) * 100);\n  //给元素赋值\n  sprintf(filePaths[i], pattern, (i + 1));\n  LOGI(&quot;patch path:%s&quot;, filePaths[i]);  }  //分割文件  FILE *fp = fopen(path, “rb”);  int fileSize = get_file_size(path);  if (fileSize % file_count == 0) {\n  //能整除\n  int part = fileSize / file_count;\n  //逐一写入分割子文件中\n  int i = 0;\n  for (; i &lt; file_count; i++) &#123;\n      FILE *fwp = fopen(filePaths[i], &quot;wb&quot;);\n      int j = 0;\n      for (; j &lt; part; j++) &#123;\n          fputc(fgetc(fp), fwp);\n      &#125;\n      fclose(fwp);\n  &#125;\n  fclose(fp);  } else {\n  //不能整除\n  int part = fileSize / (file_count - 1);\n  //逐一写入分割子文件中\n  int i = 0;\n  for (; i &lt; file_count - 1; i++) &#123;\n      FILE *fwp = fopen(filePaths[i], &quot;wb&quot;);\n      int j = 0;\n      for (; j &lt; part; j++) &#123;\n          fputc(fgetc(fp), fwp);\n      &#125;\n      fclose(fwp);\n  &#125;\n  part = fileSize % (file_count - 1);\n  if (part &gt; 0) &#123;\n      FILE *fwp = fopen(filePaths[file_count - 1], &quot;wb&quot;);\n      int j = 0;\n      for (; j &lt; part; j++) &#123;\n          fputc(fgetc(fp), fwp);\n      &#125;\n      fclose(fwp);\n  &#125;\n  fclose(fp);  }  //释放  i = 0;  for (; i &lt; file_count; i++) {\n  free(filePaths[i]);  }  free(filePaths);  //对变量的内存进行释放  (env)-&gt;ReleaseStringChars(env, file_path_str, path);  (env)-&gt;ReleaseStringChars(env, pattern_str, pattern);}\n\n\n/*\n\nClass:     com_example_ndk_filepatch_FilePatchUtils\nMethod:    patch\nSignature: (Ljava/lang/String;Ljava/lang/String;I)V\n/JNIEXPORT void JNICALL Java_com_example_ndk_filepatch_FilePatchUtils_patch  (JNIEnv *env, jclass cls, jstring pattern_str, jint count, jstring patch_path_str) &#123;  char pattern = (env)-&gt;GetStringUTFChars(env, pattern_str, NULL);  char patch_path = (env)-&gt;GetStringUTFChars(env, patch_path_str, NULL);  FILE *fwp = fopen(patch_path, “wb”);  int i = 0;  for (; i &lt; count; i++) {  //单个文件逐一写入fwp\n  char *path = malloc(sizeof(char) * 100);\n  sprintf(path, pattern, (i + 1));\n  LOGI(&quot;patch path:%s&quot;, path);\n  FILE *frp = fopen(path, &quot;rb&quot;);\n  //判断文件是否为NULL\n  if (frp != NULL) &#123;\n      //获取单个文件大小\n      int file_size = get_file_size(path);\n      int j = 0;\n      for (; j &lt; file_size; ++j) &#123;\n          fputc(fgetc(frp), fwp);\n      &#125;\n      fclose(frp);\n  &#125;\n  //释放分配的内存空间\n  free(path);  }  fclose(fwp);  //对变量的内存进行释放  (env)-&gt;ReleaseStringChars(env, pattern_str, pattern);  (env)-&gt;ReleaseStringChars(env, patch_path_str, patch_path);}\n\n\n### 5、编译生成.so动态库\n- 点击Build -&gt; Make Module app \n- 可以在app -&gt; build -&gt; intermediates -&gt; cmake -&gt; debug -&gt; obj 下看到对应的armeabi-v7a 和 x86 的so库\n\n### 6、加载.so动态库，运行程序\n- 在src/main 目录下创建 jniLibs 文件夹\n- 将上面生成的 armeabi-v7a 和 x86 的so库 复制到该 jniLibs 文件夹内\n- 运行程序\n\n","categories":["NDK"],"tags":["Android","NDK"]},{"title":"二维数组中的查找","url":"https://blog.onestravel.cn/20190227/c888a4fca78d/","content":"2. 二维数组中的查找题目描述给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。\nConsider the following matrix:\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n\nGiven target = 5, return true.\nGiven target = 20, return false.解题思路要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。\n该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。\n代码实现java 代码    /**\n     * 判断给定的Value值是否在二维数组中\n     * @param arr 给定的二维数组\n     * @param value 给定用来判断的值\n     * @return \n     */\n    private boolean isInArr(int[][] arr, int value) {\n        if (arr == null || arr.length == 0 || arr[0].length == 0) {\n            return false;\n        }\n        //从左下角开始，如果value比当前位置的元素小，则向上一行（r--）;如果value比当前位置元素大，则向右一列（c++）\n        int r = arr.length - 1, c = 0;\n        while (r >= 0 &amp;&amp; c &lt; arr[r].length) {\n            if (arr[r][c] > value) {\n                r--;\n                continue;\n            }\n            if (arr[r][c] &lt; value) {\n                c++;\n                continue;\n            }\n            if (arr[r][c] == value) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args){\n        int[][] array = {\n                {1, 4, 7, 11, 15},\n                {2, 5, 8, 12, 19},\n                {3, 6, 9, 16, 22},\n                {10, 13, 14, 17, 24},\n                {18, 21, 23, 26, 30}\n        };\n        System.out.println(isInArr(array, 5));\n        System.out.println(isInArr(array, 20));\n    }\nKotlin 代码    /**\n     * 判断给定的Value值是否在二维数组中\n     * @param array 给定的二维数组\n     * @param value 给定用来判断的值\n     * @return\n     */\n    private fun isInArr(array: Array&lt;Array&lt;Int>>, value: Int): Boolean {\n        if (array.isEmpty() || array[0].isEmpty()) {\n            return false\n        }\n        var r = array.size - 1\n        var c = 0;\n        while (r >= 0 &amp;&amp; c &lt; array[r].size) {\n            if (array[r][c] &lt; value) {\n                c++\n                continue\n            }\n            if (array[r][c] > value) {\n                r--\n            }\n            return true\n        }\n        return false\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n       val array = arrayOf(\n        arrayOf(1, 4, 7, 11, 15),\n        arrayOf(2, 5, 8, 12, 19),\n        arrayOf(3, 6, 9, 16, 22),\n        arrayOf(10, 13, 14, 17, 24),\n        arrayOf(18, 21, 23, 26, 30)\n        )\n        println(isInArr(array, 5))\n        println(isInArr(array, 20))\n    }\n\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["数组"]},{"title":"数组中重复的数字","url":"https://blog.onestravel.cn/20190226/8c06e4b8984c/","content":"1. 数组中重复的数字题目描述在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。\n解题思路要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。\n对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。本题要求找出重复的数字，因此在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。\n代码实现java 代码    /**\n     * 寻找数组中的重复数字并返回，如果没有找到，返回-1\n     */\n    private int duplicate(int[] arr){\n        if(arr==null){\n            return -1;\n        }\n        for(int i=0;i&lt;arr.length;i++){\n            while (i!=arr[i]){//判断当前位置上的元素是否和当前位置数值相同，如果不相同，则寻找和当前位置数字相同的值\n                if(arr[i]==arr[arr[i]]){//判断如果当前位置的元素和以该元素为下标的元素相同时，则寻找到重复数字，返回盖重复数字；如果不相同，则进行元素交换\n                    return arr[i];\n                }\n                swap(arr,i,arr[i]);\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 对数组中的元素进行交换\n     * @param arr 需要交换元素的数组\n     * @param i 需要交换的元素下标\n     * @param j 需要交换的元素下标\n     */\n    private void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    public static void main(String[] args){\n        int[] arr = {1,4,3,1,2,5,0,0};\n        System.out.println(duplicate(arr));\n    }\nKotlin 代码    /**\n     * 寻找数组中的重复数字并返回，如果没有找到，返回-1\n     */\n    private fun duplicate(array: Array&lt;Int>):Int{\n        for (i in array.indices) {\n            while (i!=array[i]){//判断当前位置上的元素是否和当前位置数值相同，如果不相同，则寻找和当前位置数字相同的值\n                if(array[i]==array[array[i]]){//判断如果当前位置的元素和以该元素为下标的元素相同时，则寻找到重复数字，返回盖重复数字；如果不相同，则进行元素交换\n                    return array[i]\n                }\n                swap(array,i,array[i])//元素交换\n            }\n        }\n        return -1\n    }\n    /**\n     * 对数组中的元素进行交换\n     * @param arr 需要交换元素的数组\n     * @param i 需要交换的元素下标\n     * @param j 需要交换的元素下标\n     */\n    private fun swap(array: Array&lt;Int>,i: Int, j: Int) {\n        val tmp = array[i]\n        array[i] = array[j]\n        array[j] = tmp\n    }\n\n    /**\n     * 入口函数\n     */\n    fun main(args: Array&lt;String>) {\n        val array:Array&lt;Int> = arrayOf(1,4,3,1,2,5,0,0)\n        println(duplicate(array))\n    }\n\n引用声明该题目引用自牛客网\n","categories":["算法"],"tags":["数组"]},{"title":"BottomNavigationBar 导航菜单","url":"https://blog.onestravel.cn/20190130/05823223eb19/","content":"BottomNavigationBar 使用说明简介：BottomNavigationBar 是自定义的一个实现App应用底部导航栏功能的View,可以实现底部 2-5 个导航菜单（一般不会有更多），可以实现某一个菜单凸起的效果，如，有5个菜单，可以选择让第三个菜单凸起（floating），这是很多App都有的功能; 可以根据编写的颜色变化的资源文件来更改图标和文字选中时和未选中时的颜色，可以自由控制是否需要选中（checkable）,选择开启时，可变换为选中颜色，选择关闭时，不能更改为选择颜色;可以控制默认选中哪一项；可以设置某一个导航菜单的未读消息数（数字或者小红点）。先看一组效果图五个菜单，没有凸起的，都是可选中的\n图1\n#### 中间有凸起，并且中间的不能选中，但点击事件可以响应\n\n\n图2\n## 引入方法\n\nTAG:     \ngradle\n在项目中的根目录下的 build.gradle (与model同级的) 中增加如下配置\n\n\n    allprojects &#123;\n        repositories &#123;\n            ...\n            maven &#123; url &#39;https://jitpack.io&#39; &#125;\n        &#125;\n    &#125;\n\n在model 中的build.gradle 中增加依赖\n\ndependencies &#123;\nimplementation &#39;com.github.onestravel:BottomNavigationBar:TAG&#39;\n&#125;\nmaven\n在pom.xml文件中加入下面配置\n\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;jitpack.io&lt;/id&gt;\n            &lt;url&gt;https://jitpack.io&lt;/url&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n添加maven依赖\n\n    &lt;dependency>\n        &lt;groupId>com.github.onestravel&lt;/groupId>\n        &lt;artifactId>BottomNavigationBar&lt;/artifactId>\n        &lt;version>TAG&lt;/version>\n    &lt;/dependency>\n\n属性说明BottomNavigationBar 属性说明\n\n\n属性\n参考值\n说明\n\n\n\napp:itemIconTint\n@drawable/tab_selecter\n整体的tab菜单的图片选中和未选中的颜色变化，传入一个资源drawable文件\n\n\napp:itemTextColor\n@drawable/tab_selecter\n@drawable/tab_selecter@drawable/tab_selecter整体的tab菜单的图片选中和未选中的颜色变化，传入一个资源drawable文件\n\n\napp:floatingEnable\ntrue/false\n是否开启浮动，默认为false，设置为true是，可以实现中间凸起\n\n\napp:floatingUp\n20dp\n设置Tab的上浮尺寸，比如：上浮20dp，上浮尺寸不可超过整个菜单高度的1/2\n\n\napp:menu\n@menu/botom_menu\nBottomNavigationBar导航栏的关键，设置导航栏的tab菜单\n\n\napp:itemTextSize\n15sp\n设置导航栏文字的大小\n\n\napp:itemIconWidth\n30dp\n设置导航栏Icon的宽度\n\n\napp:temIconHeight\n30dp\n设置导航栏Icon的高度\n\n\napp:itemTextTopMargin\n5dp\n置导航栏文字和Icon的间隔高度\n\n\n示例1:不需要浮动（凸起）的菜单，图1效果\n    &lt;cn.onestravel.navigation.view.BottomNavigationBar\n        android:id=\"@+id/BottomLayout\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"50dp\"\n        android:layout_alignParentBottom=\"true\"\n        android:background=\"@android:color/white\"\n        android:paddingTop=\"5dp\"\n        android:paddingBottom=\"5dp\"\n        app:menu=\"@menu/navigation_menu\">\n\n    &lt;/cn.onestravel.navigation.view.BottomNavigationBar>\n\n示例2:需要浮动（凸起）的菜单，图2效果 &lt;cn.onestravel.navigation.view.BottomNavigationBar\n        android:id=\"@+id/BottomLayout\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"50dp\"\n        android:layout_alignParentBottom=\"true\"\n        android:background=\"@android:color/white\"\n        android:paddingTop=\"5dp\"\n        android:paddingBottom=\"5dp\"\n        app:floatingEnable=\"true\"\n        app:floatingUp=\"25dp\"\n        app:menu=\"@menu/navigation_menu\">\n\n    &lt;/cn.onestravel.navigation.view.BottomNavigationBar>\nmenu 菜单属性值说明\n\n\n属性\n参考值\n说明\n\n\n\nandroid:id\n@+id/tab1\n导航菜单 Item 的ID；\n\n\nandroid:icon\n@drawable/bar_news\n导航菜单 Item 的图标，可以是图标选择器（selector），也可以是默认图标，根据BottomNavigationBar的属性 app:itemIconTint 更改选中与不选中的颜色变化，默认为蓝色和灰色；\n\n\nandroid:title\n首页\n导航菜单 Item 的文字，可以默认为空字符串，表示不设置；\n\n\nandroid:checkable\ntrue/false\n设置导航菜单 Item 是否可以选择，值影响选择与不选中效果，不影响点击事件；\n\n\nandroid:checked\ntrue/false\n设置导航菜单 Item 是否默认选中,默认为第一个选中，请不要在多个Item上设置改；\n\n\napp:floating\ntrue/false\n设置该导航菜单 Item 是否浮动，与BottomNavigationBar 的app:floatingEnable和 app:floatingUp属性配合使用，默认为false，即不浮动（不凸起）；\n\n\n示例1:不需要浮动（凸起）的菜单，图1效果&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    &lt;item\n        android:id=\"@+id/tab1\"\n        android:icon=\"@drawable/bar_news\"\n        android:title=\"首页\">&lt;/item>\n    &lt;item\n        android:id=\"@+id/tab2\"\n        android:icon=\"@drawable/bar_constact\"\n        android:title=\"联系人\">&lt;/item>\n    &lt;item\n        android:id=\"@+id/tab5\"\n        android:icon=\"@drawable/tab_manage_selected\"\n        android:title=\"拍照\">&lt;/item>\n    &lt;item\n        android:id=\"@+id/tab3\"\n        android:icon=\"@drawable/bar_invite\"\n        android:title=\"发现\">&lt;/item>\n    &lt;item\n        android:id=\"@+id/tab4\"\n        android:icon=\"@drawable/bar_my\"\n        android:title=\"我的\">&lt;/item>\n&lt;/menu>\n示例2:需要浮动（凸起）的菜单，图2效果&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    &lt;item\n        android:id=\"@+id/tab1\"\n        android:icon=\"@drawable/bar_news\"\n        android:title=\"首页\">&lt;/item>\n    &lt;item\n        android:id=\"@+id/tab2\"\n        android:icon=\"@drawable/bar_constact\"\n        android:title=\"联系人\">&lt;/item>\n    &lt;item\n        android:id=\"@+id/tab5\"\n        android:icon=\"@drawable/tab_manage_selected\"\n        android:title=\"拍照\"\n        app:floating=\"true\"\n        android:checkable=\"false\">&lt;/item>\n    &lt;item\n        android:id=\"@+id/tab3\"\n        android:icon=\"@drawable/bar_invite\"\n        android:title=\"发现\">&lt;/item>\n    &lt;item\n        android:id=\"@+id/tab4\"\n        android:icon=\"@drawable/bar_my\"\n        android:title=\"我的\">&lt;/item>\n&lt;/menu>\n设置点击切换监听在NavigationBar的Tab进行切换时，会回调改方法，可进行相应处理，如：未读消息数设置\n        bottomView.setOnItemSelectedListener(new BottomNavigationBar.OnItemSelectedListener() {\n                    @Override\n                    public void onItemSelected(BottomNavigationBar.Item item, int position) {\n                        if(position==2){\n                            bottomView.setFloatingEnable(true);\n                        }else {\n                            bottomView.setFloatingEnable(false);\n                        }\n                    }\n                });\n添加Fragment进行管理，点击自动切换需要先设置FragmentManager管理器和加载Fragment的ViewGroup,一般为FrameLayout ,需要设置id;之后调用addFragment，为对应的Tab添加Fragment,\n        bottomView.setFragmentManager(getFragmentManager(),mainFragment);\n        bottomView.addFragment(R.id.tab1,new FirstFragment());\n        bottomView.addFragment(R.id.tab2,new SecondFragment());\n        bottomView.addFragment(R.id.tab3,new ThirdFragment());\n        bottomView.addFragment(R.id.tab4,new FourFragment());\n        bottomView.addFragment(R.id.tab5,new FiveFragment());\n版本更新说明1.0.2\n初版实现自定义底部导航栏\n\n1.0.3\n在原基础上对封装进行优化，支持代码实现导航栏\n\n1.0.4\n优化选中突出效果，支持选中放大，支持导航栏背景圆角\n\n1.0.5\n可以自定义导航栏文字大小\n可以自定义图标的宽度和高度\n自定义图标和文字间隔高度\n\n1.0.6\n可以Java Api 设置导航栏文字大小\n可以Java Api 设置图标的宽度和高度\nJava Api 设置图标和文字间隔高度\n支持管理Fragment ,实现Fragment点击自动切换\n\n温馨提示：在使用过程中，如遇到任何问题，可发送邮件至server@onestravel.cn说明相关问题，我在看到邮件第一时间，会针对相应问题进行沟通解决，谢谢支持！\n","categories":["Android"],"tags":["Android","BottomNavigationBar"]},{"title":"Kotlin语言基于Mvp+Retrofit+RxJava封装的Android项目的基础依赖库","url":"https://blog.onestravel.cn/20181225/df7c09351200/","content":"Kotlin语言基于Mvp+Retrofit+RxJava封装的Android项目的基础依赖库前言该Library是基于Kotlin语言封装的一个库，主要是用来创建一个kotlin项目时，作为项目的简单封装，使用该Library作为依赖引入，即可进行项目开发，省去一些前期准备工作。\n该Library主要进行了一下封装：\n\n采用普通MVC架构的方式，对Activity，Fragment,Adapter和一些工具类的封装以及自定义View的实现；\n采用Retrofit+RxJava 对http请求进行相应的封装，可设置公共参数，并对RX生命周期进行处理；\n采用MVP架构，对上面封装的Activity，Fragment 进行二次封装；\n该项目使用了org.jetbrains.anko ，可实现对布局文件的自动依赖注入，kotlin文件中的View名称就是对应布局文件中View的 id;\n\n项目GitHub地址\n一、采用普通方式封装的基础文件介绍1、BaseActivitypackage:cn.onestravel.library.kotlin.base.activity\n所有Activity的基类，定义一些子类必须实现的和可实现的方法：\n /**\n     * 获取布局ID,子类必须实现\n     */\n    protected abstract fun getLayoutId(): Int\n\n\n    /**\n     * 初始化 View 的相关操作，若有需要可在子类实现\n     */\n    protected open fun initView() {}\n\n    /**\n     * 初始化 Listener 事件的相关操作，若有需要可在子类实现\n     */\n    protected open fun initListener() {}\n\n\n    /**\n     * 初始化 Data 数据的相关操作，若有需要可在子类实现\n     */\n    protected open fun initData() {}\n\n\n    /**\n     * 在主线程弹出Toast 提示\n     * @param msg 需要弹出的提示信息\n     */\n    protected open fun showToast(msg:String){\n        runOnUiThread {\n            toast(msg)\n        }\n    }\n\n    /**\n     * 在主线程弹出Toast 提示\n     * @param stringRes 需要弹出的提示信息的string资源ID\n     */\n    protected open fun showToast(stringRes:Int){\n        runOnUiThread {\n            toast(getString(stringRes))\n        }\n    }\n\n    /**\n     * 跳转到另一个Activity，并且finish 掉当前Activity\n     * 需要跳转的Activity必须继承于BaseActivity 或者\n     * @param params 可变参数，需要通过intent传递的参数 eg:\"key\" to \"value\"\n     */\n    inline fun &lt;reified T: BaseActivity> startActivityAndFinish(vararg params: Pair&lt;String, Any?>) {\n        startActivity&lt;T>(*params)\n        finish()\n    }\n2、BaseListActivitypackage:cn.onestravel.library.kotlin.base.activity\n继承自BaseActivity，实现针对RecyclerView实现列表数据的一些配置，简化实现只有一个列表布局的Activity，并且实现上拉加载，下拉刷新操作。\n主要方法如下：\n protected fun getRecyclerView():LoadMoreRecyclerView{\n        return mRecyclerView\n    }\n\n    /**\n     * 获取recyclerView的布局管理器，子类可重写该方法，来更改布局管理器\n     */\n    protected open fun getLayoutManager(): RecyclerView.LayoutManager {\n        val layoutManager: LinearLayoutManager = LinearLayoutManager(this)\n        //设置为垂直布局，这也是默认的\n        layoutManager.orientation = OrientationHelper.VERTICAL\n        return layoutManager\n    }\n\n\n    /**\n     * 设置RecyclerView 的Adapter适配器\n     * @param adapter 设置的Adapter，必须是BaseRecyclerAdapter的子类\n     */\n    protected fun &lt;T> setAdapter(adapter: BaseRecyclerAdapter&lt;T>) {\n        mRecyclerView.adapter = adapter\n    }\n\n    /**\n     * 设置刷新控件的颜色\n     */\n    protected fun setRefreshColorSchemeColors(@ColorInt vararg colors: Int) {\n        mRefreshLayout.setColorSchemeColors(*colors)\n    }\n    /**\n     * 设置刷新控件的颜色\n     */\n    protected fun setColorSchemeResources(@ColorRes vararg colorIds: Int) {\n        mRefreshLayout.setColorSchemeResources(*colorIds)\n    }\n\n    /**\n     * 设置刷新控件是否显示\n     */\n    protected fun isRefresh(isRefresh: Boolean) {\n        mRefreshLayout.isRefreshing = false\n    }\n\n    /**\n     * 刷新完成\n     */\n    protected fun refreshComplete() {\n        mRefreshLayout.isRefreshing = false\n    }\n\n    /**\n     * 刷新数据，子类实现该方法，进行数据请求\n     */\n    protected open fun refreshDatas() {\n\n    }\n\n    /**\n     * 加载更多完成\n     */\n    protected fun loadMoreComplete() {\n        mRecyclerView.loadMoreComplete(true)\n    }\n\n    /**\n     * 设置是否可以加载更多\n     */\n    protected fun canLoadMore(canLoadMore: Boolean) {\n        mRecyclerView.loadMoreEnable = canLoadMore\n    }\n\n    /**\n     * 设置是否还有更多的数据\n     */\n    protected fun hasLoadMore(hasLoadMore: Boolean) {\n        mRecyclerView.hasMore = hasLoadMore\n    }\n\n    /**\n     * 加载新数据，子类实现该方法，进行数据请求\n     */\n    protected open fun loadMoreDatas() {\n\n    }\n3、BaseRecyclerAdapterpackage:cn.onestravel.library.kotlin.base.adapter\n针对RecyclerView使用的RecyclerView.Adapter进行封装，实现一些基础的布局（不常变化的）设置的方法，定义一些方法，简化子类的实现，更加有利于缩短开发时间；实现adapter中提示Toast的方法，以及添加、设置数据，或者基础View的设置相关内容的方法；对Item点击和长按的监听事件。\n主要方法如下：\n\nabstract class BaseRecyclerAdapter&lt;T> : RecyclerView.Adapter&lt;VH>(), View.OnClickListener, View.OnLongClickListener {\n    private val mDatas: MutableList&lt;T> = ArrayList&lt;T>()\n    private lateinit var context: Context\n    private var clickListener: OnItemClickListener&lt;T>? = null\n    private var longClickListener: OnItemLongClickListener&lt;T>? = null\n\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {\n        context = parent.context\n        val convertView = LayoutInflater.from(parent.context).inflate(getLayoutId(viewType), parent, false)\n        convertView.setOnClickListener(this)\n        convertView.setOnLongClickListener(this)\n        return VH(convertView)\n    }\n\n    /**\n     * 设置Item 的点击事件\n     */\n    fun setOnItemClick(listener: OnItemClickListener&lt;T>) {\n        clickListener = listener\n    }\n\n    /**\n     * 设置Item 的点击事件\n     */\n    fun setOnItemClick(onClick: (view:View,position:Int,data:T) -> Unit) {\n        clickListener = object :  OnItemClickListener&lt;T> {\n            override fun onItemClick(view: View, position: Int, data: T) {\n                onClick(view,position,data)\n            }\n        }\n    }\n\n    /**\n     * 设置Item 的长按事件\n     */\n    fun setOnItemLongClick(listener:OnItemLongClickListener&lt;T>) {\n        longClickListener = listener\n    }\n\n    /**\n     * 设置Item 的长按事件\n     */\n    fun setOnItemLongClick(onLongClick: (view:View,position:Int,data:T) -> Boolean) {\n        longClickListener = object : OnItemLongClickListener&lt;T> {\n            override fun onItemLongClick(view: View, position: Int, data: T):Boolean {\n                return onLongClick(view,position,data)\n            }\n        }\n    }\n\n    override fun onClick(p0: View?) {\n        val position:Int = p0?.getTag(R.id.itemViewPosition) as Int\n        val data:T = mDatas.get(position)\n        clickListener?.onItemClick(p0,position,data)\n    }\n\n    override fun onLongClick(p0: View?): Boolean {\n        val position:Int = p0?.getTag(R.id.itemViewPosition) as Int\n        val data:T = mDatas.get(position)\n        return longClickListener?.onItemLongClick(p0,position,data) ?: true\n    }\n\n    /**\n     * 设置数据,并且会清空原数据列表\n     * @param datas 新的数据列表\n     */\n    open fun setDatas(datas: List&lt;T>) {\n        mDatas.clear()\n        mDatas.addAll(datas)\n        notifyDataSetChanged()\n    }\n\n    /**\n     * 添加新的数据列表到原数据列表末尾\n     * @param datas 新的数据列表\n     */\n    open fun addDatas(datas: List&lt;T>) {\n        mDatas.addAll(datas)\n        notifyDataSetChanged()\n    }\n\n    /**\n     * 添加新的数据列表到原数据列表的指定位置\n     * @param position 需要添加的指定位置\n     * @param datas 新的数据列表\n     */\n    open fun addDatas(position: Int, datas: List&lt;T>) {\n        val pos = if (position > mDatas.size) {\n            mDatas.size\n        } else position\n        mDatas.addAll(pos, datas)\n        notifyDataSetChanged()\n    }\n\n    /**\n     * 更新数据列表指定位置上的数据\n     * @param position 需要更新数据的位置\n     * @param data 更新后的数据\n     */\n    open fun updateData(position: Int, data: T) {\n        if (position &lt; mDatas.size) {\n            mDatas.removeAt(position)\n            mDatas.add(position, data)\n            notifyItemChanged(position)\n        }\n    }\n\n    /**\n     * 添加新的数据到原数据列表末尾\n     * @param datas 新的数据\n     */\n    open fun addData(data: T) {\n        mDatas.add(data)\n        notifyItemInserted(mDatas.size - 1)\n    }\n\n    /**\n     * 添加新的数据到原数据列表的指定位置\n     * @param position 需要添加的指定位置\n     * @param data 新的数据\n     */\n    open fun addData(position: Int, data: T) {\n        val pos = if (position > mDatas.size) {\n            mDatas.size\n        } else position\n        mDatas.add(pos, data)\n        notifyItemInserted(pos)\n    }\n\n    /**\n     * 移除指定位置上的数据\n     * @param position 需要添加的指定位置\n     */\n    open fun removeDataAt(position: Int) {\n        if (position &lt; mDatas.size) {\n            mDatas.removeAt(position)\n            notifyItemRemoved(position)\n        }\n    }\n\n    protected open fun showToast(msg: String) {\n        context.runOnUiThread {\n            context.toast(msg)\n        }\n    }\n\n    /**\n     * 移除指定的数据\n     * @param data 需要移除的数据实体\n     */\n    open fun removeData(data: T) {\n        if (mDatas.contains(data)) {\n            val position = mDatas.indexOf(data)\n            mDatas.removeAt(position)\n            notifyItemRemoved(position)\n        }\n    }\n\n    /**\n     * 根据View的类型获取对应的Item布局的ID\n     */\n    @LayoutRes\n    abstract fun getLayoutId(viewType: Int): Int\n\n\n    /**\n     * 绑定ViewHolder 时执行的方法，在此方法里处理对Item的view的操作\n     */\n    abstract fun onBindVH(holder: VH, position: Int, datas: T)\n\n    /**\n     * 返回数据的数量\n     */\n    override fun getItemCount(): Int {\n        return mDatas.size\n    }\n\n    override fun onBindViewHolder(holder: VH, position: Int) {\n        holder.itemView.setTag(R.id.itemViewPosition, position)\n        onBindVH(holder, position, mDatas.get(position))\n    }\n\n\n}\n\n/**\n *Item 的点击事件\n */\ninterface OnItemClickListener&lt;T> {\n    fun onItemClick(view: View, position: Int, data: T)\n}\n\n/**\n *Item 的长按事件\n */\ninterface OnItemLongClickListener&lt;T> {\n    fun onItemLongClick(view: View, position: Int, data: T):Boolean\n}\n\n/**\n * 所有的Adapter 使用的ViewHolder\n */\nclass VH(itemView: View) : RecyclerView.ViewHolder(itemView) {\n\n\n    /**\n     * 根据View的id获取对应的View\n     */\n    inline fun &lt;reified E : View> getView(@IdRes viewId: Int): E {\n        return itemView.find&lt;E>(viewId)\n    }\n\n    /**\n     * 对TextView及其子类设置文本内容\n     * @param viewId 对应的View 的id\n     * @param value 需要设置的文本内容\n     */\n    inline fun setText(@IdRes viewId: Int, value: String) {\n        val view: View = this.getView(viewId)\n        if (view is TextView) {\n            val tv: TextView = view\n            tv.text = value\n        }\n    }\n\n    /**\n     * 对TextView及其子类设置文本内容\n     * @param viewId 对应的View 的id\n     * @param value 需要设置的文本内容\n     */\n    inline fun setText(@IdRes viewId: Int, value: Spannable) {\n        val view: View = this.getView(viewId)\n        if (view is TextView) {\n            val tv: TextView = view\n            tv.text = value\n        }\n    }\n\n    /**\n     * 对TextView及其子类设置文本内容\n     * @param viewId 对应的View 的id\n     * @param stringRes 需要设置的文本资源的id\n     */\n    inline fun setText(@IdRes viewId: Int, @StringRes stringRes: Int) {\n        val view: View = this.getView(viewId)\n        if (view is TextView) {\n            val tv: TextView = view\n            tv.setText(stringRes)\n        }\n    }\n\n    /**\n     * 对ImageView及其子类设置图片\n     * @param viewId 对应的View 的id\n     * @param resId 需要设置的图片资源的id\n     */\n    inline fun setImageResource(@IdRes viewId: Int, @DrawableRes resId: Int) {\n        val view: View = getView(viewId)\n        if (view is ImageView) {\n            val iv: ImageView = view\n            iv.imageResource = resId\n        }\n    }\n\n    /**\n     * 对ImageView及其子类设置图片\n     * @param viewId 对应的View 的id\n     * @param imgUrl 需要设置的网络图片的地址\n     */\n    inline fun setImageUrl(@IdRes viewId: Int, imgUrl: String) {\n        val view: View = getView(viewId)\n        if (view is ImageView) {\n            val iv: ImageView = view\n            iv.loadImage(imgUrl)\n        }\n    }\n\n    /**\n     * 对View及其子类设置背景图片\n     * @param viewId 对应的View 的id\n     * @param resId 需要设置的背景图片的资源地址\n     */\n    inline fun setBackgroundResource(@IdRes viewId: Int, @DrawableRes resId: Int) {\n        val view: View = getView(viewId)\n        view.setBackgroundResource(resId)\n    }\n\n    /**\n     * 对View及其子类设置背景颜色\n     * @param viewId 对应的View 的id\n     * @param color 需要设置的背景颜色\n     */\n    inline fun setBackgroundColor(@IdRes viewId: Int, @ColorInt color: Int) {\n        val view: View = getView(viewId)\n        view.setBackgroundColor(color)\n    }\n\n\n    /**\n     * 对View及其子类设置点击事件\n     * @param viewId 对应的View 的id\n     * @param color 需要设置的背景颜色\n     */\n    inline fun setOnClick(@IdRes viewId: Int, crossinline onClick: (View) -> Unit) {\n        val view: View = getView(viewId)\n        view.setOnClickListener {\n            onClick.invoke(it)\n        }\n    }\n\n}\n4、ImageViewExtendpackage: cn.onestravel.library.kotlin.base.extend\n改文件是ImageView的扩展方法的文件，主要针对ImageView加载网络图片而新增的一些扩展方法\n具体方法如下：\ninline fun ImageView.loadImage(imgUrl: String): ImageView {\n    ImageUtils.loadImageUrl(this.context, imgUrl, this)\n    return this\n}\n\ninline fun ImageView.loadBitmap(imgUrl: String): ImageView {\n    ImageUtils.loadImageBitmap(this.context, imgUrl, this)\n    return this\n}\n\ninline fun ImageView.loadGif(imgUrl: String): ImageView {\n    ImageUtils.loadImageGif(this.context, imgUrl, this)\n    return this\n}\n\ninline fun ImageView.loadImgCallBack(imgUrl: String, requestListener: RequestListener&lt;Bitmap>): ImageView {\n    ImageUtils.loadImageCallBack(this.context, imgUrl, this, requestListener)\n    return this\n}\n\n5、BaseFragmentpackage: cn.onestravel.library.kotlin.base.fragment\n所有Fragment的基类，定义一些子类必须实现的和可实现的方法，具体方法与BaseActivity方法类似。\n6、BaseListFragmentpackage: cn.onestravel.library.kotlin.base.fragment\n继承自BaseFragment，实现针对RecyclerView实现列表数据的一些配置，简化实现只有一个列表布局的Fragment，并且实现上拉加载，下拉刷新操作；具体方法与BaseListActivity相同。\n7、DensityUtilpackage: cn.onestravel.library.kotlin.base.utils\n尺寸转换工具类，可以将dip转为px，将px转为dip；获取屏幕宽度和高度。\n    /**\n     * dip转换为px\n     */\n    fun dip2px(dp: Int): Int {\n        return (dp * density).toInt()\n    }\n\n\n    /**\n     * px转换为dip\n     */\n    fun px2dip(px:  Float): Int {\n        return (px / density).toInt()\n    }\n\n    /**\n     * 获取屏幕宽度\n     */\n    fun appWidth(): Int {\n        return Resources.getSystem().getDisplayMetrics().widthPixels\n    }\n\n    /**\n     * 获取屏幕高度\n     */\n    fun appHeight(): Int {\n        return Resources.getSystem().getDisplayMetrics().heightPixels\n    }\n8、CircleTextViewpackage：cn.onestravel.library.kotlin.base.view\n自定义圆形TextView，一满足不同需求\n9、EmptyViewpackage：cn.onestravel.library.kotlin.base.view\n自定义 数据为空的页面视图，主要有三个功能类型，分别为：数据为空显示页面（TYPE_EMPTY）；加载进度提示页面（TYPE_LOADING）；加载失败可点击重试页面（TYPE_RELOAD）\n重新定义的一下方法如下：\n/**\n     * 设置页面显示类型\n     *\n     * @param type\n     */\n    fun setEmptyType(type: Int) {\n        _setEmptyType(type, true)\n    }\n\n    /**\n     * 设置页面显示类型\n     *\n     * @param type\n     */\n    private fun _setEmptyType(type: Int, isShow: Boolean) {\n        this.emptyType = type\n        when (type) {\n            TYPE_EMPTY -> {\n                layoutLoading!!.visibility = View.GONE\n                layoutReload!!.visibility = View.GONE\n                layoutEmpty!!.visibility = View.VISIBLE\n                btnReload!!.visibility = View.GONE\n                ivEmptyImg!!.visibility = View.VISIBLE\n            }\n            TYPE_LOADING -> {\n                layoutLoading!!.visibility = View.VISIBLE\n                layoutEmpty!!.visibility = View.GONE\n                layoutReload!!.visibility = View.GONE\n                if (tvLoadingMsg != null) {\n                    tvLoadingMsg!!.text = \"正在加载...\"\n                }\n            }\n            TYPE_RELOAD -> {\n                layoutLoading!!.visibility = View.GONE\n                layoutEmpty!!.visibility = View.GONE\n                layoutReload!!.visibility = View.VISIBLE\n                btnReload!!.visibility = View.VISIBLE\n                ivEmptyImg!!.visibility = View.VISIBLE\n            }\n        }\n        if (isShow) {\n            show()\n        }\n    }\n\n    /**\n     * 设置空数据界面的背景色\n     *\n     * @param color 背景色\n     */\n    fun setEmptyBackgroundColor(color: Int) {\n        layoutEmpty!!.setBackgroundColor(color)\n    }\n\n    /**\n     * 设置错误描述\n     *\n     * @param resId\n     */\n    fun setEmptyText(@StringRes resId: Int) {\n        if (tvEmptyMsg != null) {\n            tvEmptyMsg!!.text = mContext!!.getString(resId)\n        }\n    }\n\n    /**\n     * 设置错误描述\n     *\n     * @param text\n     */\n    fun setEmptyText(text: CharSequence?) {\n        var text = text\n        if (text == null) {\n            text = \"\"\n        }\n        if (tvEmptyMsg != null) {\n            tvEmptyMsg!!.text = text\n        }\n    }\n\n\n    /**\n     * 设置错误描述字体大小\n     *\n     * @param size\n     */\n    fun setEmptyTextSize(size: Float) {\n        if (tvEmptyMsg != null) {\n            tvEmptyMsg!!.setTextSize(TypedValue.COMPLEX_UNIT_PX, size)\n        }\n    }\n\n    /**\n     * 设置错误描述颜色\n     *\n     * @param color\n     */\n    fun setEmptyTextColor(color: Int) {\n        if (tvEmptyMsg != null) {\n            tvEmptyMsg!!.setTextColor(color)\n        }\n    }\n\n    /**\n     * 设置错误描述颜色\n     *\n     * @param colors\n     */\n    fun setEmptyTextColor(colors: ColorStateList) {\n        if (tvEmptyMsg != null) {\n            tvEmptyMsg!!.setTextColor(colors)\n        }\n    }\n\n    /**\n     * 设置页面图片\n     *\n     * @param resId\n     */\n    fun setEmptyImgResource(@DrawableRes resId: Int) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            this.noDataImg = mContext!!.getDrawable(resId)\n        } else {\n            this.noDataImg = mContext!!.resources.getDrawable(resId)\n        }\n        if (ivEmptyImg != null) {\n            ivEmptyImg!!.setImageResource(resId)\n        }\n    }\n\n\n    /**\n     * 设置页面图片\n     *\n     * @param noDataImg\n     */\n    fun setEmptyImg(noDataImg: Drawable) {\n        this.noDataImg = noDataImg\n        if (ivEmptyImg != null) {\n            ivEmptyImg!!.setImageDrawable(noDataImg)\n        }\n    }\n\n    /**\n     * 获取加载按钮文字\n     */\n    fun getReloadBtnText(): String? {\n        return reloadBtnText\n    }\n\n    /**\n     * 设置重新加载按钮文字\n     *\n     * @param resId\n     */\n    fun setReloadBtnText(resId: Int) {\n        this.reloadBtnText = mContext!!.getString(resId)\n        if (btnReload != null) {\n            btnReload!!.text = this.reloadBtnText\n        }\n    }\n\n    /**\n     * 设置重新加载按钮文字\n     *\n     * @param reloadBtnText\n     */\n    fun setReloadBtnText(reloadBtnText: String) {\n        this.reloadBtnText = reloadBtnText\n        if (btnReload != null) {\n            btnReload!!.text = this.reloadBtnText\n        }\n    }\n\n\n    /**\n     * 设置重新加载按钮文字大小\n     *\n     * @param reloadBtnTextSize\n     */\n    fun setReloadBtnTextSize(reloadBtnTextSize: Float) {\n        this.reloadBtnTextSize = reloadBtnTextSize\n        if (btnReload != null) {\n            btnReload!!.setTextSize(TypedValue.COMPLEX_UNIT_PX, this.reloadBtnTextSize)\n        }\n    }\n\n\n    /**\n     * 设置重新加载按钮文字颜色\n     *\n     * @param color\n     */\n    fun setReloadBtnTextColor(color: Int) {\n        this.reloadBtnTextColor = color\n        if (btnReload != null) {\n            btnReload!!.setTextColor(this.reloadBtnTextColor)\n        }\n    }\n\n    /**\n     * 设置重新加载按钮文字颜色\n     *\n     * @param colors\n     */\n    fun setReloadBtnTextColor(colors: ColorStateList) {\n        if (btnReload != null) {\n            btnReload!!.setTextColor(colors)\n        }\n    }\n\n\n    /**\n     * 设置加载按钮背景\n     *\n     * @param reloadBackground\n     */\n    fun setReloadBtnBackground(reloadBackground: Drawable) {\n        this.reloadBtnBackground = reloadBackground\n        if (btnReload != null) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n                btnReload!!.background = this.reloadBtnBackground\n            } else {\n                btnReload!!.setBackgroundDrawable(this.reloadBtnBackground)\n            }\n        }\n    }\n\n    /**\n     * 设置加载按钮背景\n     *\n     * @param color\n     */\n    fun setReloadBtnBackgroundColor(color: Int) {\n        this.reloadBtnBackground = ColorDrawable(color)\n        if (btnReload != null) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n                btnReload!!.background = this.reloadBtnBackground\n            } else {\n                btnReload!!.setBackgroundDrawable(this.reloadBtnBackground)\n            }\n        }\n    }\n\n    /**\n     * 设置加载按钮背景\n     *\n     * @param resId\n     */\n    fun setReloadBtnBackgroundResource(resId: Int) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            this.reloadBtnBackground = mContext!!.getDrawable(resId)\n        } else {\n            this.reloadBtnBackground = mContext!!.resources.getDrawable(resId)\n        }\n        if (btnReload != null) {\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n                btnReload!!.background = this.reloadBtnBackground\n            } else {\n                btnReload!!.setBackgroundDrawable(this.reloadBtnBackground)\n            }\n        }\n    }\n\n    /**\n     * 获取加载提示文字\n     */\n    fun getReloadText(): String? {\n        return reloadText\n    }\n\n    /**\n     * 设置重新加载提示文字\n     *\n     * @param resId\n     */\n    fun setReloadText(resId: Int) {\n        this.reloadText = mContext!!.getString(resId)\n        if (tvReloadMsg != null) {\n            tvReloadMsg!!.text = this.reloadText\n        }\n    }\n\n    /**\n     * 设置重新加载提示文字\n     *\n     * @param reloadText\n     */\n    fun setReloadText(reloadText: String) {\n        this.reloadText = reloadText\n        if (tvReloadMsg != null) {\n            tvReloadMsg!!.text = this.reloadText\n        }\n    }\n\n\n    /**\n     * 设置重新加载提示文字大小\n     *\n     * @param reloadTextSize\n     */\n    fun setReloadTextSize(reloadTextSize: Float) {\n        this.reloadTextSize = reloadTextSize\n        if (tvReloadMsg != null) {\n            tvReloadMsg!!.setTextSize(TypedValue.COMPLEX_UNIT_PX, this.reloadTextSize)\n        }\n    }\n\n\n    /**\n     * 设置重新加载提示文字颜色\n     *\n     * @param color\n     */\n    fun setReloadTextColor(color: Int) {\n        this.reloadTextColor = color\n        if (tvReloadMsg != null) {\n            tvReloadMsg!!.setTextColor(this.reloadTextColor)\n        }\n    }\n\n    /**\n     * 设置重新加载提示文字颜色\n     *\n     * @param colors\n     */\n    fun setReloadTextColor(colors: ColorStateList) {\n        if (tvReloadMsg != null) {\n            tvReloadMsg!!.setTextColor(colors)\n        }\n    }\n\n    /**\n     * 设置页面图片\n     *\n     * @param resId\n     */\n    fun setReloadImgResource(@DrawableRes resId: Int) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            this.reloadImage = mContext!!.getDrawable(resId)\n        } else {\n            this.reloadImage = mContext!!.resources.getDrawable(resId)\n        }\n        if (ivReloadImg != null) {\n            ivReloadImg!!.setImageResource(resId)\n        }\n    }\n\n\n    /**\n     * 设置页面图片\n     *\n     * @param reloadImage\n     */\n    fun setReloadImg(reloadImage: Drawable) {\n        this.reloadImage = reloadImage\n        if (ivReloadImg != null) {\n            ivReloadImg!!.setImageDrawable(reloadImage)\n        }\n    }\n\n\n    /**\n     * 设置加载提示文字\n     *\n     * @param resId\n     */\n    fun setLoadingText(resId: Int) {\n        this.loadingText = mContext!!.getString(resId)\n        if (tvLoadingMsg != null) {\n            tvLoadingMsg!!.text = this.loadingText\n        }\n    }\n\n    /**\n     * 设置加载提示文字\n     *\n     * @param loadingText\n     */\n    fun setLoadingText(loadingText: String) {\n        this.loadingText = loadingText\n        if (tvLoadingMsg != null) {\n            tvLoadingMsg!!.text = this.loadingText\n        }\n    }\n\n    /**\n     * 显示此视图\n     */\n    fun show() {\n        this.visibility = View.VISIBLE\n    }\n\n    /**\n     * 隐藏此视图\n     */\n    fun hide() {\n        this.visibility = View.GONE\n    }\n\n    /**\n     * 设置重新加载监听事件\n     *\n     * @param listener\n     */\n    fun setOnReloadListener(listener: OnReloadListener) {\n        this.onReloadListener = listener\n    }\n\n\n    interface OnReloadListener {\n        fun onReload()\n    }\n\n    companion object {\n        const val TYPE_EMPTY = 0 // 页面为空，没有数据时展示\n        const val TYPE_LOADING = 1 // 正在加载视图\n        const val TYPE_RELOAD = 2 // 加载失败，显示重新加载视图\n    }\n10、ShapeImageViewpackage：cn.onestravel.library.kotlin.base.view\n自定义矩形和圆形ImageView，实现带边框的圆角矩形ImageView或圆形ImageVIew\nviewShape的值为：\n\n\n\n值\n说明\n\n\n\nSHAPE_REC\n矩形ImageView\n\n\nSHAPE_CIRCLE\n圆形ImageView\n\n\nSHAPE_OVAL\n椭圆ImageView\n\n\n/**\n * 设置ImageView的形式，圆角矩形，圆形，或椭圆\n **/\nvar shape = SHAPE_REC: Int\n        get() = shape\n        set(shape) {\n            this.shape = shape\n            invalidate()\n        }\n/**\n * 设置ImageView边框颜色\n **/\n var borderColor: Int\n        get() = mBorderColor\n        set(mBorderColor) {\n            this.mBorderColor = mBorderColor\n            mBorderPaint.color = mBorderColor\n            invalidate()\n        }\n    /**\n      * 设置ImageView的圆角\n      **/\n    var roundRadius: Float\n        get() = mRoundRadius\n        set(mRoundRadius) {\n            this.mRoundRadius = mRoundRadius\n            invalidate()\n        }\n    /**\n      * 设置ImageView的边框宽度\n      **/\n    fun setBorderSize(mBorderSize: Int) {\n        this.borderSize = mBorderSize.toFloat()\n        mBorderPaint.strokeWidth = mBorderSize.toFloat()\n        initRect()\n        invalidate()\n    }\n    /**\n      * 设置ImageView的图片资源\n      **/\noverride fun setImageResource(resId: Int) {\n        super.setImageResource(resId)\n        mBitmap = ImageUtils.getBitmapFromDrawable(drawable)\n        setupBitmapShader()\n    }\n    /**\n      * 设置ImageView的Drawable\n      **/        \n    override fun setImageDrawable(drawable: Drawable?) {\n        super.setImageDrawable(drawable)\n        mBitmap = ImageUtils.getBitmapFromDrawable(drawable)\n        setupBitmapShader()\n    }\n\n\n二、采用RxJava+Retrofit架构封装的关于Http请求以及生命周期处理的文件介绍1、BaseRxActivitypackage：cn.onestravel.library.kotlin.rxrequest.activity\n继承自BaseActivity ，针对RxJava处理了相对应的生命周期，同时拥有BaseActivity的所有特性。\n生命周期处理：\nabstract class BaseRxActivity : BaseActivity(), LifecycleProvider&lt;ActivityEvent> {\n    private val lifecycleSubject:BehaviorSubject&lt;ActivityEvent> = BehaviorSubject.create()\n\n    @CheckResult\n    override fun lifecycle(): Observable&lt;ActivityEvent> {\n        return lifecycleSubject.hide()\n    }\n\n    @CheckResult\n    override fun &lt;T> bindUntilEvent(event: ActivityEvent): LifecycleTransformer&lt;T> {\n        return RxLifecycle.bindUntilEvent(lifecycleSubject, event)\n    }\n\n    @CheckResult\n    override fun &lt;T> bindToLifecycle(): LifecycleTransformer&lt;T> {\n        return RxLifecycleAndroid.bindActivity(lifecycleSubject)\n    }\n\n    @CallSuper\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        lifecycleSubject.onNext(ActivityEvent.CREATE)\n    }\n\n    @CallSuper\n    override fun onStart() {\n        super.onStart()\n        lifecycleSubject.onNext(ActivityEvent.START)\n    }\n\n    @CallSuper\n    override fun onResume() {\n        super.onResume()\n        lifecycleSubject.onNext(ActivityEvent.RESUME)\n    }\n\n    @CallSuper\n    override fun onPause() {\n        lifecycleSubject.onNext(ActivityEvent.PAUSE)\n        super.onPause()\n    }\n\n    @CallSuper\n    override fun onStop() {\n        lifecycleSubject.onNext(ActivityEvent.STOP)\n        super.onStop()\n    }\n\n    @CallSuper\n    override fun onDestroy() {\n        lifecycleSubject.onNext(ActivityEvent.DESTROY)\n        super.onDestroy()\n    }\n}\n2、BaseRxListActivitypackage：cn.onestravel.library.kotlin.rxrequest.activity\n继承自BaseListActivity ，针对RxJava处理了相对应的生命周期，同时拥有BaseListActivity下拉刷新，上拉加载的所有特性。\n3、BaseRxFragmentpackage：cn.onestravel.library.kotlin.rxrequest.fragment\n继承自BaseFragment ，针对RxJava处理了相对应的生命周期，同时拥有BaseFragment的所有特性。\n生命周期处理：\nabstract class BaseRxFragment : BaseFragment(), LifecycleProvider&lt;FragmentEvent> {\n    private val lifecycleSubject:BehaviorSubject&lt;FragmentEvent> = BehaviorSubject.create()\n\n    override fun lifecycle(): Observable&lt;FragmentEvent> {\n        return lifecycleSubject.hide()\n    }\n\n    @CheckResult\n    override fun &lt;T> bindUntilEvent(event: FragmentEvent): LifecycleTransformer&lt;T> {\n        return RxLifecycle.bindUntilEvent(lifecycleSubject, event)\n    }\n\n    @CheckResult\n    override fun &lt;T> bindToLifecycle(): LifecycleTransformer&lt;T> {\n        return RxLifecycleAndroid.bindFragment(lifecycleSubject)\n    }\n\n    @CallSuper\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        lifecycleSubject.onNext(FragmentEvent.CREATE)\n    }\n\n\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\n        lifecycleSubject.onNext(FragmentEvent.CREATE_VIEW)\n        return super.onCreateView(inflater, container, savedInstanceState)\n    }\n\n\n    @CallSuper\n    override fun onStart() {\n        super.onStart()\n        lifecycleSubject.onNext(FragmentEvent.START)\n    }\n\n    @CallSuper\n    override fun onResume() {\n        super.onResume()\n        lifecycleSubject.onNext(FragmentEvent.RESUME)\n    }\n\n    @CallSuper\n    override fun onPause() {\n        lifecycleSubject.onNext(FragmentEvent.PAUSE)\n        super.onPause()\n    }\n\n    @CallSuper\n    override fun onStop() {\n        lifecycleSubject.onNext(FragmentEvent.STOP)\n        super.onStop()\n    }\n\n    override fun onDestroyView() {\n        lifecycleSubject.onNext(FragmentEvent.DESTROY_VIEW)\n        super.onDestroyView()\n    }\n\n    @CallSuper\n    override fun onDestroy() {\n        lifecycleSubject.onNext(FragmentEvent.DESTROY)\n        super.onDestroy()\n    }\n}\n\n4、BaseRxListFragmentpackage：cn.onestravel.library.kotlin.rxrequest.fragment\n继承自BaseListFragment ，针对RxJava处理了相对应的生命周期，同时拥有BaseListFragment下拉刷新，上拉加载的所有特性。\n5、BaseObserver&lt;T: ResponseResult&gt;package：cn.onestravel.library.kotlin.rxrequest.common\nRxJava+Retrofit 请求的观察者，返回特定数据结构的数据，并进行相应的处理。\n具体实现如下：\n/**\n * @name cn.onestravel.library.kotlin.rxrequest.common.BaseObserver\n * @description 请求返回结果，返回json数据必须符合 {\"code\":\"0000\",\"msg\":\"\"}\n * @createTime 2018/12/12 17:00\n * @author onestravel\n * @version 1.0.0\n */\nabstract class BaseObserver&lt;T : ResponseResult> : Observer&lt;T> {\n\n    /**\n     * 请求开始 处理基本的loading框的显示等\n     *\n     * @param d\n     */\n    fun onStart(d: Disposable) {\n        Log.e(\n            TAG,\n            \"===========单个接口请求开始=========\"\n        )\n    }\n\n    /**\n     * 此方法必须实现\n     *\n     * @param result 请求成功的结果\n     */\n    abstract fun onSuccess(result: T)\n\n    /**\n     * 请求失败\n     *\n     * @param code 错误码\n     * @param msg  错误提示语\n     */\n    fun onFailure(code: String, msg: String?) {\n        Log.e(\n            TAG,\n            \"接口请求失败===code = \" + code + \"errorMsg =\" + msg \n        )\n    }\n\n    /**\n     * 请求都完成时之行此方法\n     */\n    fun onFinish() {\n\n    }\n\n    override fun onSubscribe(d: Disposable) {\n        onStart(d)\n    }\n\n    override fun onNext(result: T) {\n        if (BaseResponse.REQUEST_OK == result.code) {\n            onSuccess(result)\n            Log.i(TAG, \"请求成功responseBody====\" + JSON.toJSONString(result))\n        } else {\n            onFailure(result.code, result.msg)\n        }\n\n    }\n\n    override fun onError(e: Throwable) {\n        var errorMsg = \"\"\n        var errorCode = 0\n        if (e is HttpException) {\n            val httpException = e as HttpException\n            errorCode = httpException.response().code()\n            if (404 == errorCode || 500 == errorCode) {\n                errorMsg = \"请求异常，请稍候重试！\"\n            } else {\n\n            }\n\n        } else {\n            //todo 设置固定的错误码及错误提示\n        }\n        onFailure(errorCode.toString(), errorMsg)\n    }\n\n    override fun onComplete() {\n        onFinish()\n    }\n\n    companion object {\n        private val TAG = \"request\"\n    }\n}\n\nBaseResponse:\n/**\n * @name cn.onestravel.library.kotlin.rxrequest.common.BaseResponse\n * @description 请求返回结果数据基类\n * @createTime 2018/12/12 17:00\n * @author onestravel\n * @version 1.0.0\n */\nopen class BaseResponse(val code: String = \"0000\", val msg: String = \"\"): Serializable {\n    companion object {\n        val REQUEST_OK = \"0000\"  //请求成功的code码\n        val REQUEST_ERROR = \"-1\" //请求失败的code码\n    }\n}\nResponseResult:\n/**\n * @name cn.onestravel.library.kotlin.rxrequest.common.ResponseResult\n * @description 请求返回结果数据 符合 {\"code\":\"0000\",\"msg\":\"\",\"data\":{},\"datas\":[]} 的基类\n * @createTime 2018/12/12 17:00\n * @author onestravel\n * @version 1.0.0\n */\nclass ResponseResult :BaseResponse(), Serializable\n6、BaseObserver1&lt;DATA: Serializable&gt;package：cn.onestravel.library.kotlin.rxrequest.common\nRxJava+Retrofit 请求的观察者，返回特定数据结构的数据，并进行相应的处理。\n具体实现如下：\n/**\n * @name cn.onestravel.library.kotlin.rxrequest.common.BaseObserver\n * @description 请求返回结果，返回json数据必须符合  {\"code\":\"0000\",\"msg\":\"\",\"data\":{},\"datas\":[]},data 和 datas 的数据 bean 相同\n * @createTime 2018/12/12 17:00\n * @author onestravel\n * @version 1.0.0\n */\nabstract class BaseObserver1&lt;DATA : Serializable> : Observer&lt;ResponseResult1&lt;DATA>> {\n\n    /**\n     * 请求开始 处理基本的loading框的显示等\n     *\n     * @param d\n     */\n    fun onStart(d: Disposable) {\n        Log.e(\n            TAG,\n            \"===========单个接口请求开始  ==========\"\n        )\n    }\n\n    /**\n     * 此方法必须实现\n     *\n     * @param result 请求成功的结果\n     */\n    abstract fun onSuccess(result: ResponseResult1&lt;DATA>)\n\n    /**\n     * 请求失败\n     *\n     * @param code 错误码\n     * @param msg  错误提示语\n     */\n    fun onFailure(code: String, msg: String?) {\n        Log.e(\n            TAG,\n            \"接口请求失败============code = \" + code + \"errorMsg =\" + msg    )\n    }\n\n    /**\n     * 请求都完成时之行此方法\n     */\n    open fun onFinish() {\n\n    }\n\n    override fun onSubscribe(d: Disposable) {\n        onStart(d)\n    }\n\n    override fun onNext(result: ResponseResult1&lt;DATA>) {\n        if (BaseResponse.REQUEST_OK == result.code) {\n            onSuccess(result)\n            Log.i(TAG, \"请求成功responseBody====\" + JSON.toJSONString(result))\n        } else {\n            onFailure(result.code, result.msg)\n        }\n\n    }\n\n    override fun onError(e: Throwable) {\n        var errorMsg = \"\"\n        var errorCode = 0\n        if (e is HttpException) {\n            val httpException = e as HttpException\n            errorCode = httpException.response().code()\n            if (404 == errorCode || 500 == errorCode) {\n                errorMsg = \"请求异常，请稍候重试！\"\n            } else {\n\n            }\n\n        } else {\n            //todo 设置固定的错误码及错误提示\n        }\n        onFailure(errorCode.toString(), errorMsg)\n    }\n\n    override fun onComplete() {\n        onFinish()\n    }\n\n    companion object {\n        private val TAG = \"request\"\n    }\n}\n\nResponseResult1:\n/**\n * @name cn.onestravel.library.kotlin.rxrequest.common.ResponseResult\n * @description 请求返回结果数据 符合 {\"code\":\"0000\",\"msg\":\"\",\"data\":{},\"datas\":[]} 的基类\n * @createTime 2018/12/12 17:00\n * @author onestravel\n * @version 1.0.0\n */\nclass ResponseResult1&lt;DATA:Serializable>(\n    val data: DATA?,\n    val datas: MutableList&lt;DATA>? = ArrayList()\n) :BaseResponse(), Serializable\n\n\n7、BaseObserver2&lt;DATA : Serializable,ITEM:Serializable&gt;package：cn.onestravel.library.kotlin.rxrequest.common\nRxJava+Retrofit 请求的观察者，返回特定数据结构的数据，并进行相应的处理。\n具体实现如下：\npackage cn.onestravel.library.kotlin.rxrequest.common\n\nimport android.util.Log\nimport io.reactivex.Observer\nimport io.reactivex.disposables.Disposable\nimport retrofit2.HttpException\nimport java.io.Serializable\n\n/**\n * @name cn.onestravel.library.kotlin.rxrequest.common.BaseObserver2\n * @description 请求返回结果，返回json数据必须符合 {\"code\":\"0000\",\"msg\":\"\",\"data\":{},\"datas\":[]},data 和 datas 的数据 bean 可以不相同\n * @createTime 2018/12/12 17:00\n * @author onestravel\n * @version 1.0.0\n */\nabstract class BaseObserver2&lt;DATA : Serializable,ITEM:Serializable> : Observer&lt;ResponseResult2&lt;DATA,ITEM>>, ObserverResult&lt;ResponseResult2&lt;DATA,ITEM>> {\n    /**\n     * 请求开始 处理基本的loading框的显示等\n     *\n     * @param d\n     */\n    override fun onStart(d: Disposable) {\n        Log.e(\n             BaseObserver2.TAG,\n            \"===========单个接口请求开始  ==========\"\n        )\n    }\n\n    /**\n     * 此方法必须实现\n     *\n     * @param result 请求成功的结果\n     */\n    abstract override fun onSuccess(result: ResponseResult2&lt;DATA, ITEM>)\n\n    /**\n     * 请求失败\n     *\n     * @param code 错误码\n     * @param msg  错误提示语\n     */\n    override fun onFailure(code: String, msg: String?) {\n        Log.e(\n             BaseObserver2.TAG,\n            \"接口请求失败============code = \" + code + \"errorMsg =\" + msg    )\n    }\n\n    /**\n     * 请求都完成时之行此方法\n     */\n    override fun onFinish() {\n\n    }\n\n    override fun onSubscribe(d: Disposable) {\n        onStart(d)\n    }\n    override fun onNext(baseObject: ResponseResult2&lt;DATA,ITEM>) {\n        //        Log.i(\"responseBody====\",)\n        if (BaseResponse.REQUEST_OK == baseObject.code) {\n            onSuccess(baseObject)\n        } else {\n            onFailure(baseObject.code, baseObject.msg)\n        }\n    }\n\n    /**\n     *\n     */\n    override fun onError(e: Throwable) {\n        var errorMsg = \"\"\n        var errorCode = 0\n        if (e is HttpException) {\n            val httpException = e as HttpException\n            errorCode = httpException.response().code()\n            if (404 == errorCode || 500 == errorCode) {\n                errorMsg = \"请求异常，请稍候重试！\"\n            } else {\n\n            }\n\n        } else {\n            //todo 设置固定的错误码及错误提示\n        }\n        onFailure(errorCode.toString(), errorMsg)\n    }\n\n    override fun onComplete() {\n        onFinish()\n    }\n\n    companion object {\n        private val TAG = \"RequestBaseObserver2\"\n    }\n}\n\nResponseResult2:\n/**\n * @name cn.onestravel.library.kotlin.rxrequest.common.ResponseResult\n * @description 请求返回结果数据 符合 {\"code\":\"0000\",\"msg\":\"\",\"data\":{},\"datas\":[]} 的基类\n * @createTime 2018/12/12 17:00\n * @author onestravel\n * @version 1.0.0\n */\nclass ResponseResult2&lt;DATA:Serializable,ITEM:Serializable>(\n    val data: DATA?,\n    val datas: MutableList&lt;ITEM>? = ArrayList()\n) :BaseResponse(), Serializable\n\n\n8、BaseLoaderpackage：cn.onestravel.library.kotlin.rxrequest.loader\n公共的Loader，处理observe针对请求进行线程切换\nabstract class BaseLoader&lt;S : BaseService> {\n    protected val mServiceManager: RetrofitServiceManager by lazy { RetrofitServiceManager.INSTANCE }\n    protected val mService: S by lazy { createService() }\n\n    /**\n     * 创建 Service 实例\n     */\n    abstract fun createService(): S\n\n    /**\n     * 设置Observable的工作线程\n     * @param observable\n     * @param &lt;T>\n     * @return\n    &lt;/T> */\n    fun &lt;T> observe(observable: Observable&lt;T>): Observable&lt;T> {\n        return observable.subscribeOn(Schedulers.io())\n            .unsubscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n    }\n\n\n}\n\n9、BaseServicepackage：cn.onestravel.library.kotlin.rxrequest.service\n所有 Retrofit 请求的 Service 的接口基类，目前只用于规范子类，可声明对应公用方法\n10、RetrofitServiceManagerpackage：cn.onestravel.library.kotlin.rxrequest.service\n生成接口service实例的管理类，初始化Retrofit 实例，设置请求相关的一些拦截器、超时时间等配置，定义Http请求的公共URL\n/**\n * @name cn.onestravel.library.kotlin.rxrequest.service.RetrofitServiceManager\n * @description 生成接口实例的管理类\n * @createTime 2018/12/12 17:00\n * @author onestravel\n * @version 1.0.0\n */\nclass RetrofitServiceManager private constructor() {\n    private val mRetrofit: Retrofit\n    init {\n        val interceptorBuild = HttpCommonInterceptor.Builder()\n\n        val logging = HttpLoggingInterceptor()\n        logging.level = HttpLoggingInterceptor.Level.BODY\n        val okHttpClientBuild = OkHttpClient.Builder()\n        okHttpClientBuild.connectTimeout(CONNECTION_TIMEOUT.toLong(), TimeUnit.SECONDS)\n            .readTimeout(READ_TIMEOUT.toLong(), TimeUnit.SECONDS)\n            .writeTimeout(WRITE_TIMEOUT.toLong(), TimeUnit.SECONDS)\n            .addInterceptor(interceptorBuild.build())//拦截器添加公共请求参数\n            .addInterceptor(RetryInterceptor(2))//重试三次的拦截\n                        .addInterceptor(logging)//请求日志打印\n\n        //初始化Retrofit\n        mRetrofit = Retrofit.Builder()\n            .baseUrl(BASE_URL)\n            .addConverterFactory(GsonConverterFactory.create())\n            .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n            .client(okHttpClientBuild.build())\n            .build()\n\n    }\n\n\n\n    /**\n     * 生成对应接口的实例\n     *\n     * @param service\n     * @param &lt;T>\n     * @return\n    &lt;/T> */\n    fun &lt;T:BaseService> create(service: Class&lt;T>): T {\n        return mRetrofit.create(service)\n\n    }\n\n    companion object {\n        val INSTANCE by lazy { RetrofitServiceManager() }\n        private const val CONNECTION_TIMEOUT = 5\n        private const val READ_TIMEOUT = 20\n        private const val WRITE_TIMEOUT = 10\n        private const val BASE_URL = \"http://192.168.1.12:9090/\"\n    }\n}\n\n三、采用Mvp架构封装的文件介绍1、BaseMvpActivity&lt;V : BaseMvpView, P : BaseMvpPresenter&gt;package：cn.onestravel.library.kotlin.mvp.activity\n所有Mvp架构的 Activity 的基类,自BaseActivity ，拥有BaseActivity的所有特性,处理了P层的相关生命周期。\n/**\n * @name  BaseMvpActivity\n * @description 所有Mvp架构的 Activity 的基类\n * @createTime 2018/12/12 17:00\n * @author onestravel\n * @version 1.0.0\n */\nabstract class BaseMvpActivity&lt;V : BaseMvpView, P : BaseMvpPresenter&lt;V>> : BaseActivity(), BaseMvpView {\n    private val presenter by lazy { createPresenter() }\n    private var mLoadingDialog: LoadingDialog? = null\n    protected abstract fun createPresenter(): P\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        if (presenter == null) {\n            throw  NullPointerException(\"Presenter is null! Do you return null in createPresenter()?\")\n        }\n        presenter.onMvpAttachView(this as V, savedInstanceState)\n    }\n\n\n    override fun onStart() {\n        super.onStart()\n        presenter.let {\n            it.onMvpStart()\n        }\n    }\n\n    override fun onResume() {\n        super.onResume()\n        presenter.let {\n            it.onMvpResume()\n        }\n    }\n\n    override fun onPause() {\n        presenter.let {\n            it.onMvpPause()\n        }\n        super.onPause()\n    }\n\n    override fun onStop() {\n        presenter.let {\n            it.onMvpStop()\n        }\n        super.onStop()\n    }\n\n\n    override fun onSaveInstanceState(outState: Bundle?) {\n        super.onSaveInstanceState(outState)\n        presenter?.let {\n            it.onMvpSaveInstanceState(outState)\n        }\n    }\n\n    override fun onDestroy() {\n        presenter?.let {\n            it.onMvpDetachView(false)\n            it.onMvpDestroy()\n        }\n        mLoadingDialog?.let {\n            it.destroy()\n            mLoadingDialog = null\n        }\n        super.onDestroy()\n    }\n\n    override fun showLoading(content: String?) {\n        if (mLoadingDialog == null) {\n            mLoadingDialog = LoadingDialog.getInstance(this)\n            mLoadingDialog!!.title = content?:\"正在加载...\"\n            if (!mLoadingDialog!!.isShowing) {\n                mLoadingDialog!!.show()\n            }\n        }\n    }\n\n    override fun hideLoading() {\n        mLoadingDialog?.let {\n            mLoadingDialog!!.dismiss()\n        }\n    }\n\n    override fun onResponseError(msg: String?) {\n        msg?.let {\n            showToast(msg)\n        }\n    }\n\n}\n2、BaseMvpListActivity&lt;V : BaseMvpView, P : BaseMvpPresenter&gt;package：cn.onestravel.library.kotlin.mvp.activity\n所有Mvp架构的 ListActivity 的基类,自BaseListActivity ，拥有BaseListActivity的所有特性，并且处理了P层的相关生命周期。\n3、BaseRxMvpActivity&lt;V : BaseMvpView, P : BaseMvpPresenter&gt;package：cn.onestravel.library.kotlin.mvp.activity\n所有Mvp架构的 采用RxJava+Retrofit 请求的Activity 的基类，继承自BaseRxActivity ，拥有BaseRxActivity的所有特性，并且处理了P层的相关生命周期。\n4、BaseRxMvpListActivity&lt;V : BaseMvpView, P : BaseMvpPresenter&gt;package：cn.onestravel.library.kotlin.mvp.activity\n所有Mvp架构的 采用RxJava+Retrofit 请求的带有列表的Activity，继承自BaseRxListActivity ，拥有BaseRxListActivity的所有特性，并且处理了P层的相关生命周期。\n5、Fragment 有与前4个Activity功能相同Fragment，就不多做介绍了。package：cn.onestravel.library.kotlin.mvp.fragment\n6、BaseMvpModelpackage：cn.onestravel.library.kotlin.mvp.model\nMvp模式中所有Model层的基类，是一个接口，可以声明共同的方法，交由子类去实现。\n7、BaseMvpPresenterpackage：cn.onestravel.library.kotlin.mvp.presenter\nMvp模式中所有presenter层的基类，是一个接口，声明了presenter层相关的生命周期方法，由子类去实现。\n/**\n * @name  BaseMvpPresenterImpl\n * @description 所有界面presenter的接口类\n * @createTime 2018/12/12 16:27\n * @author onestravel\n * @version 1.0.0\n */\n\ninterface BaseMvpPresenter&lt;in V : BaseMvpView> {\n    fun onMvpAttachView(view: V, savedInstanceState: Bundle?)\n\n    fun onMvpStart()\n\n    fun onMvpResume()\n\n    fun onMvpPause()\n\n    fun onMvpStop()\n\n    fun onMvpSaveInstanceState(savedInstanceState: Bundle?)\n\n    fun onMvpDetachView(retainInstance: Boolean)\n\n    fun onMvpDestroy()\n\n}\n8、BaseMvpPresenterImpl&lt;V: BaseMvpView&gt;package：cn.onestravel.library.kotlin.mvp.presenter.impl\nMvp模式中所有presenter层的接口的实现类，对presenter层相关的生命周期方法进行实现；并且实现与View层的绑定，持有View层的引用。\n/**\n * @name  BaseMvpPresenterImpl\n * @description 所有界面presenter的接口类\n * @createTime 2018/12/12 16:27\n * @author onestravel\n * @version 1.0.0\n */\n\ninterface BaseMvpPresenter&lt;in V : BaseMvpView> {\n    fun onMvpAttachView(view: V, savedInstanceState: Bundle?)\n\n    fun onMvpStart()\n\n    fun onMvpResume()\n\n    fun onMvpPause()\n\n    fun onMvpStop()\n\n    fun onMvpSaveInstanceState(savedInstanceState: Bundle?)\n\n    fun onMvpDetachView(retainInstance: Boolean)\n\n    fun onMvpDestroy()\n\n}\n9、BaseMvpViewpackage：cn.onestravel.library.kotlin.mvp.view\nMvp模式中所有View层的接口类，声明了一些View层常用的加载进度显示与隐藏，请求失败提示等公用的方法。\n/**\n * @name  BaseMvpPresenterImpl\n * @description 所有界面presenter的接口类\n * @createTime 2018/12/12 16:27\n * @author onestravel\n * @version 1.0.0\n */\n\ninterface BaseMvpPresenter&lt;in V : BaseMvpView> {\n    fun onMvpAttachView(view: V, savedInstanceState: Bundle?)\n\n    fun onMvpStart()\n\n    fun onMvpResume()\n\n    fun onMvpPause()\n\n    fun onMvpStop()\n\n    fun onMvpSaveInstanceState(savedInstanceState: Bundle?)\n\n    fun onMvpDetachView(retainInstance: Boolean)\n\n    fun onMvpDestroy()\n\n}\n声明：针对Kotlin项目的一些常用封装，到这里就介绍完了，后面还会增加MVVM模式的一些封装，敬请期待！！\n在封装或者介绍过程中，如有什么不正确或者不明白的地方，期待与您进行交流，共同提高！\n联系邮件：server@onestravel.cn\n鸣谢！！！\n","categories":["Kotlin"],"tags":["Android","Kotlin"]},{"title":"(七)Kotlin 小案例与展望未来","url":"https://blog.onestravel.cn/20181212/43601972e2fd/","content":"一、Kotlin 的应用场景1、Kotlin Script\nGradle 脚本，Gradle3.0 开始部分支出，尚在完善中\n\n2、Java 虚拟机应用\nWeb 应用，完美支持\nJavaFx,jdk8开始完美支持\n\n3、前端开发\n1.1 开始正式支持 Kotlin-JavaScript\n\n4、Android 应用开发\nKotlin 目前的主要战场\n\n5、Native 程序\n直接编译 Kotlin 代码为机器码，不依赖Jvm\n支持与 C 代码交互\n技术预览版功能有限，前途无量\n\n二、Kotlin Script 实例1、安装 Kotlin 编译库Windows下Kotlin命令行开发环境安装\n安装环境准备\n\nKotlin编译器：从GitHub下载，截止2017-9-5 最新版本是1.1.4，GitHub主页\nJava JDK 8，可以从Oracle官网下载，下载JDK8\n\n安装\n\n在Windows操作系统完成JDK 8的安装以后，安装Kotlin编译器：\n解压Kotlin安装包：kotlin-compiler-1.1.4.zip，本文解压到D盘kotlin目录下\n将D:\\kotlin\\kotlinc\\bin目录路径，添加到Windows系统环境变量即可\nWindows 10环境变量设置：【控制面板】中直接搜索【环境变量】，然后【编辑系统环境变量】即可；\n\n验证安装是否成功\n\n打开windows的命令行窗口输入命令：kotlinc -version，如果提示Kotlin 1.1.4版本号，安装成功\n其它可选的安装平台在Windows和Linux、OS X上通用的安装方法：\n\nKotlin编译器，从GitHub下载，截止2017-9-5 最新版本是1.1.4，GitHub  - Kotlin主页\n下载Java JDK 环境安装\n\nLinux，OS X，FreeBSB，Solaris等*Unix系统支持以下方法：\n    // sdkman 包管理工具\n    $ curl -s https://get.sdkman.io | bash\n\n    // 一定要新开终端窗口执行以下命令\n    $ sdk install kotlinMax OS X 还支持以下方式：\n    // homebrew工具安装\n    $ brew update\n    $ brew install kotlin2、编译执行Kotlin Script(.kts) 文件    // 编译.kts 脚本文件\n    kotlinc -script *.kts\n\n    // 编译源码为可运行的jar包\n    kotlinc D:\\kotlin_code\\hello.kt -include-runtime -d hello.jar\n\n    // 使用java执行hello.jar\n    java -jar D:\\kotlin_code\\hello.jar\n\n    // 使用java执行类名运行\n    java -cp D:\\kotlin_code\\hello.jar  HelloKt\n\n    // 使用kotlin执行，需要指明main类，执行类名\n    kotlin -cp D:\\kotlin_code HelloKt\n\n    // 或者直接运行jar包\n    kotlin D:\\kotlin_code\\hello.jar三、Kotlin Android 实例1、Kotlin Android 插件- kotlin.android.extensionsapply plugin &quot;kotlin.android.extensions&quot;使用该插件可以在代码中省去 findViewById ，可直接使用对应 xml 布局文件中对应 View 的 id 属性定义的名称来进行相应的操作如：\nmain_layout.xml\n&lt;TextView\nandroid:layout_width=&quot;wrap_content&quot;\nandroid:layout_height=&quot;wrap_content&quot;\nandroid:id=&quot;@+id/tvName&quot;/&gt;MainActivity.kt\ntvName.text=&quot;Hello World&quot;- anko 库\n添加 anko 库\n\ncompile &quot;org.jetbrains.anko:anko-sdk15:0.9.1&quot;\n改变 View 的setOnClickListener\n\ntvName.onClick&#123;view -&gt;\n    (view!! as TextView).text=&quot;$&#123;System.currentTimeMilles()&#125;&quot;\n&#125;\n改变 startActivity\n\nval intent = Intent(this@MainAvtivity,Main2Activity::class.java)\nintent.putExtra(&quot;key&quot;,&quot;From MainActivity&quot;)\nthis@MainAvtivity.startActivity(intent)更改后为\nstartActivity&lt;Main2Activity&gt;(&quot;key&quot; to &quot;From MainActivity&quot;)\n代码中定义View,可无需布局文件\n\nMain2Activity.kt\noverride fun onCreate(savedInstanceState: Bundle?)&#123;\n    super.onCreate(savedInstanceState)\n    relativeLayout&#123;\n        textView(intent.extras[&quot;key&quot;]?.toString()?: &quot;Hello&quot;)&#123;\n\n        &#125;.lparams(matchParent,matchParent)&#123;\n            gravity = Gravity.CENTER\n        &#125;\n    &#125;.lparams(matchParent,matchParent)&#123;\n        gravity = Gravity.CENTER\n    &#125;\n&#125;四、Kotlin javascript 实例创建一个kotlin (javascript) 的项目\n新建 Main.kt 文件\nfun main(args:Array&lt;String&gt;)&#123;\n    document.write(&quot;Hello World!&quot;)\n&#125;build 该项目，会在out 下生成对应的js 文件；页面引入对应的js文件，就可以在浏览器访问该页面了\nindex.html\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Hello Kotlin javasicrpt&lt;/title&gt;\n    &lt;script src=&quot;$&#123;kotlin.js文件所在路径&#125;/kotlin.js&quot;/&gt;\n    &lt;script src=&quot;$&#123;kotlin-javascript.js文件所在路径&#125;/kotlin-javascript.js&quot;/&gt;\n    &lt;/head&gt;\n\n    &lt;body&gt;\n\n    &lt;/body&gt;\n&lt;/html&gt;五、Kotlin SpringBoot 实例1、配置插件buildscript&#123;\n    ext.springBootVersion = &quot;1.5.9.RELEASE&quot;\n    dependencies&#123;\n        classpath &quot;org.jetbrains.kotlin:kotlin-noarg:@kotlin_version&quot;\n        classpath &quot;org.jetbrains.kotlin:kotlin-allopen:@kotlin_version&quot;\n        classpath &quot;org.springframework.boot:Spring-boot-gradle-plugin:@springBootVersion&quot;\n    &#125;\n&#125;\napply plugin: &#39;kotlin-spring&#39;\napply plugin: &#39;kotlin-jpa&#39;\napply plugin: &#39;org.springframework.boot&#39;\ndependencies&#123;\n    compile &quot;org.springframework.boot:spring-boot-starter-web&quot;\n    compile &quot;org.springframework.boot:spring-boot-starter-data-jpa&quot;\n    compile &quot;com.h2database:h2&quot;\n    compile &quot;com.fasterxml.jackson.module:jackson-module-kotlin:2.8.4&quot;\n&#125;五、Kotlin Native 实例","categories":["Kotlin"],"tags":["Android","Kotlin"]},{"title":"(六)Kotlin 与 Java 混合开发","url":"https://blog.onestravel.cn/20181211/7ea523de3217/","content":"一、基本互操作1、属性读写\nKotlin 自动识别 Java Getter/Setter\nJava 操作 Kotlin 属性通过 Getter/Setter\n\n2、空安全类型\nKotlin 空安全类型的原理\n平台类型 Platform Type,自己明确传入的参数和返回值是否可能为空\n可使用注解 @Nullable 和 @NotNull 来确保不能为空\n\n3、几类函数的调用\n包级函数：静态方法\n扩展方法：带Receiver 的静态方法\n运算符重载：带 Receiver 的对应名称的静态方法\n\n4、几个常用注解的使用\n@JvmField : 将属性编译为 Java 变量\n@JvmStatic : 将对象的方法编译成 Java 静态方法\n@JvmOverloads : 默认参数生成重载方法\n@file:JvmName : 知道 Kotlin 文件编译后的类名，默认为 Kotlin 文件名+Kt\n\n5、NoArg 与 AllOpen\nNoArg 为被标注的类生成无参构造方法\nNoArg 支持 Jpa 注解，如：@Entity\nAllOpen 为被标注的类去掉 final ,允许被继承\nAllOpen 支持 Spring 注解，如: @Component\n支持自定义注解类型，如：@PoKo\n\n6、泛型\n通配符 Kotlin 的 * 对象于 Java 的 ?\n协变和逆变 out/in\n\nArrayList&lt;out String&gt;\n没有 Raw 类型\n\nJava 的List  -&gt;   Kotlin 的List&lt;*&gt;二、SAM 转换\nSingle Abstract Method\nSAM 转换的条件   Java的接口，单一接口方法\n注意转换后的实例变化\n\n三、正则表达式\n用 Raw 字符串定义正则表达式\nJava 的 Pattern 在 Kotlin 中同样适用\n可通过Kotlin 的 Regex 自定义Kotlin 风格的正则表达式\n\n四、集合框架\nKotlin 到 Java 的类型映射\n不可变与可变集合接口，Kotlin 中所有的List,Map,Set 都是不可变的接口\n部分接口优化，比如：list.removeAt(0);\n\n五、IO 操作\nFile、Stream、Reader、Writer的扩展方法\n使用use 扩展自动关闭资源\n小文件一次性读取 readLines()\n\n六、装箱与拆箱\nJava 的基本数据类型，都会映射到 Kotlin 中的基本类型\n由于Kotlin 中不区分Java 中的装箱类型与拆箱类型，需要注意规避基本类型相关的问题\n\n七、注解处理器\napply plugin: “kotlin-kapt”\n注意添加生成的代码路径到 SourceSets{}\n注意 Intellij 暂时不支持注解处理器的编译\n\n","categories":["Kotlin"],"tags":["Android","Kotlin"]},{"title":"(五)协程 Coroutine","url":"https://blog.onestravel.cn/20181210/c28a6aeddf4f/","content":"一、协程的概念\n协作程序，解决异步问题\n应用层完成调度\n常见的支持协程的语言如： lua，C#\n\n二、协程要解决什么问题例如：\n现在要开始协程啦&#123;\n    //现在在协程里面了\n    //花括号内的代码可以是一段运行在UI线程的代码\n    val view = ...  //初始化视图\n    val image =    //异步加载图片,运行在其他子线程，执行到这一步就挂起，等到子线程返回图片，继续执行，不会阻塞线程\n    view.setImage(image)\n&#125;\n异步代码想同步代码一样直观\n简化异步代码异常处理\n轻量级的并发方案\n\n三、kotlin如何支持协程\n编译器对 suspend 函数的编译支持\n标准库的基本API支持\nkotlinx.coroutine 应用级的支持\n\n四、协程的基本API\ncreateCoroutine：创建协程\nstartCoroutine：启动协程\nsuspendCoroutine：挂起协程\nContinuation 接口：运行控制类，负责结果和异常的返回\nCoroutineContext 接口：运行上下文，资源持有，运行调度\nContinuationInterceptor 接口：协程控制拦截器，可用来处理协程调度\n\n五、协程的执行流程\n协程被编译成状态机\nsuspend 函数即状态转移\n\n六、协程的运行结果\n正常的结果通过 resume 返回\n异常通过 resumeWithException 抛出\n\n七、kotlinx.coroutine 框架介绍\nKotlin 官方协程应用框架\n提供大量对协程API的封装\n\n\n\n\n主要模块\n说明\n\n\n\nkotlin-coroutines-core\n核心库\n\n\nkotlin-coroutines-jdk8\nJava8 支持库\n\n\nkotlin-coroutines-nio\n异步IO库\n\n\nkotlin-coroutines-reactive\nReactive Streams 支持\n\n\nkotlin-coroutines-reactor\nReactor 支持\n\n\nkotlin-coroutines-rx1\nRxJava 1.x 支持\n\n\nkotlin-coroutines-rx2\nRxJava 2.x 支持\n\n\nkotlin-coroutines-android\nAndroid UI 支持\n\n\nkotlin-coroutines-javafx\nJavaFx UI 支持\n\n\nkotlin-coroutines-swing\nSwing UI 支持\n\n\n","categories":["Kotlin"],"tags":["Android","Kotlin"]},{"title":"(四)Kotlin 领域特定语言 DSL","url":"https://blog.onestravel.cn/20181209/98ce05fb6cdd/","content":"一、领域特定语言 DSL的概念\n只在特定领域使用的语言;例如：HTML、Gradle、SQL\n\n二、领域特定语言 DSL的特点\n它也是计算机编程语言\n具有语言表达能力\n表达能力比较有限\n关注某个特定领域\n\n三、Html DSL四、Gradle DSL以下内容引用自 Kotlin 语言中文站使用 Gradle为了用 Gradle 构建 Kotlin，你应该设置好 kotlin-gradle 插件，将其应用到你的项目中，并且添加 kotlin-stdlib 依赖。这些操作也可以在 IntelliJ IDEA 中通过调用 Project action 中的 Tools | Kotlin | Configure Kotlin 自动执行。\n插件和版本使用 kotlin-gradle-plugin 编译 Kotlin 源代码和模块.\n要使用的 Kotlin 版本通常定义为 kotlin_version 属性：\nbuildscript &#123;\n    ext.kotlin_version = &#39;1.3.11&#39;\n\n    repositories &#123;\n        mavenCentral()\n    &#125;\n\n    dependencies &#123;\n        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;\n    &#125;\n&#125;\n当通过 Gradle 插件 DSL 与 Gradle Kotlin DSL 使用 Kotlin Gradle 插件 1.1.1 及以上版本时，这不是必需的。\n针对 JVM针对 JVM，需要应用 Kotlin 插件：\napply plugin: &quot;kotlin&quot;\n或者，从 Kotlin 1.1.1 起，可以使用 Gradle 插件 DSL 来应用该插件：\nplugins &#123;\n    id &quot;org.jetbrains.kotlin.jvm&quot; version &quot;1.3.11&quot;\n&#125;\n在这个块中的 version 必须是字面值，并且不能从其他构建脚本中应用。对于 Gradle Kotlin DSL，请按以下方式应用插件：\nplugins &#123;\n    kotlin(&quot;jvm&quot;) version &quot;1.3.11&quot;\n&#125;\nKotlin 源代码可以与同一个文件夹或不同文件夹中的 Java 源代码混用。默认约定是使用不同的文件夹：\nproject\n    - src\n        - main (root)\n            - kotlin\n            - java\n如果不使用默认约定，那么应该更新相应的 sourceSets 属性：\nsourceSets &#123;\n    main.kotlin.srcDirs += &#39;src/main/myKotlin&#39;\n    main.java.srcDirs += &#39;src/main/myJava&#39;\n&#125;\n对于 Gradle Kotlin DSL，请改用 java.sourceSets &#123; …… &#125; 配置源集。\n针对 JavaScript当针对 JavaScript 时，须应用不同的插件：\napply plugin: &quot;kotlin2js&quot;\n这个插件只适用于 Kotlin 文件，因此建议将 Kotlin 和 Java 文件分开（如果是同一项目包含 Java 文件的情况）。与针对 JVM 一样，如果不使用默认约定，我们需要使用 sourceSets 来指定源代码文件夹：\nsourceSets &#123;\n    main.kotlin.srcDirs += &#39;src/main/myKotlin&#39;\n&#125;\n除了输出的 JavaScript 文件，该插件默认会创建一个带二进制描述符的额外 JS 文件。 如果你是构建其他 Kotlin 模块可以依赖的可重用库，那么该文件是必需的，并且应该与转换结果一起分发。 其生成由 kotlinOptions.metaInfo 选项控制：\ncompileKotlin2Js &#123;\n    kotlinOptions.metaInfo = true\n&#125;\n针对 AndroidAndroid 的 Gradle 模型与普通 Gradle 有点不同，所以如果我们要构建一个用 Kotlin 编写的 Android 项目，我们需要用 kotlin-android 插件取代 kotlin 插件：\nbuildscript &#123;\n    ext.kotlin_version = &#39;1.3.11&#39;\n\n    ……\n\n    dependencies &#123;\n        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;\n    &#125;\n&#125;\napply plugin: &#39;com.android.application&#39;\napply plugin: &#39;kotlin-android&#39;\n不要忘记配置标准库依赖关系。\nAndroid Studio如果使用 Android Studio，那么需要在 android 下添加以下内容：\nandroid &#123;\n  ……\n\n  sourceSets &#123;\n    main.java.srcDirs += &#39;src/main/kotlin&#39;\n  &#125;\n&#125;\n这让 Android Studio 知道该 kotlin 目录是源代码根目录，所以当项目模型加载到 IDE 中时，它会被正确识别。或者，你可以将 Kotlin 类放在 Java 源代码目录中，该目录通常位于 src/main/java。\n配置依赖除了上面显示的 kotlin-gradle-plugin 依赖之外，还需要添加 Kotlin 标准库的依赖：\nrepositories &#123;\n    mavenCentral()\n&#125;\n\ndependencies &#123;\n    compile &quot;org.jetbrains.kotlin:kotlin-stdlib&quot;\n&#125;\n如果针对 JavaScript，请使用 compile &quot;org.jetbrains.kotlin:kotlin-stdlib-js&quot; 替代之。\n如果是针对 JDK 7 或 JDK 8，那么可以使用扩展版本的 Kotlin 标准库，其中包含为新版 JDK 增加的额外的扩展函数。使用以下依赖之一来取代 kotlin-stdlib ：\ncompile &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7&quot;\ncompile &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot;\n对于 Gradle Kotlin DSL，以下表示法的依赖关系与其等价：\ndependencies &#123;\n    compile(kotlin(&quot;stdlib&quot;))\n    // 或者以下之一：\n    compile(kotlin(&quot;stdlib-jdk7&quot;))\n    compile(kotlin(&quot;stdlib-jdk8&quot;))\n&#125;\n在 Kotlin 1.1.x 中，请使用 kotlin-stdlib-jre7 与 kotlin-stdlib-jre8。\n如果你的项目中使用 Kotlin 反射或者测试设施，你也需要添加相应的依赖：\ncompile &quot;org.jetbrains.kotlin:kotlin-reflect&quot;\ntestCompile &quot;org.jetbrains.kotlin:kotlin-test&quot;\ntestCompile &quot;org.jetbrains.kotlin:kotlin-test-junit&quot;\n或者，对于 Gradle Kotlin DSL：\ncompile(kotlin(&quot;reflect&quot;))\ntestCompile(kotlin(&quot;test&quot;))\ntestCompile(kotlin(&quot;test-junit&quot;))\n从 Kotlin 1.1.2 起，使用 org.jetbrains.kotlin group 的依赖项默认使用从已应用的插件获得的版本来解析。你可以用完整的依赖关系符号 （如 compile &quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;，或者在 Gradle Kotlin DSL 中用 kotlin(&quot;stdlib&quot;, kotlinVersion)）手动提供其版本。\n注解处理请参见 Kotlin 注解处理工具（kapt）的描述。\n增量编译Kotlin 支持 Gradle 中可选的增量编译。 增量编译跟踪构建之间源文件的改动，因此只有受这些改动影响的文件才会被编译。\n从 Kotlin 1.1.1 起，默认启用增量编译。\n有几种方法来覆盖默认设置：\n\n将 kotlin.incremental=true 或者 kotlin.incremental=false 行添加到一个 gradle.properties 或者一个 local.properties 文件中；\n\n将 -Pkotlin.incremental=true 或 -Pkotlin.incremental=false 添加到 Gradle 命令行参数。请注意，这样用法中，该参数必须添加到后续每个子构建，并且任何具有禁用增量编译的构建将使增量缓存失效。\n\n\n请注意，第一次构建不会是增量的。\nCoroutines supportCoroutines support is an experimental feature in Kotlin 1.2, so the Kotlin compiler reports a warning when you use coroutines in your project. To turn off the warning, add the following block to your build.gradle file:\nkotlin &#123;\n    experimental &#123;\n        coroutines &#39;enable&#39;\n    &#125;\n&#125;\nOr, with Gradle Kotlin DSL:\nimport org.jetbrains.kotlin.gradle.dsl.Coroutines\n// ...\n\nkotlin.experimental.coroutines = Coroutines.ENABLE\nModule namesThe Kotlin modules that the build produces are named accordingly to the archivesBaseName property of the project. If a project has a broad name like lib or jvm, which is common for subprojects, the Kotlin output files related to the module (*.kotlin_module) might clash with those from third-party modules with the same name. This causes problems when a project is packaged into a single archive (e.g. APK).\nTo avoid this, consider setting a unique archivesBaseName manually:\narchivesBaseName = &#39;myExampleProject_lib&#39;\nWith Gradle Kotlin DSL, it is:\nsetProperty(&quot;archivesBaseName&quot;, &quot;myExampleProject_lib&quot;)\nGradle 构建缓存支持（自 1.2.20 起）Kotlin 插件支持 Gradle 构建缓存（需要 Gradle 4.3 及以上版本；低版本则禁用缓存）。\n由于注解处理器运行的任意代码可能不一定会将任务输入转换为输出、可能访问与修改 Gradle 未跟踪的文件等，因此默认不缓存 kapt 注解处理任务。要启用 kapt 缓存，请将以下列几行添加到构建脚本中：\nkapt &#123;\n    useBuildCache = true\n&#125;\n要禁用所有 Kotlin 任务的缓存，请将系统属性标志 kotlin.caching.enabled 设置为 false（运行构建带上参数 -Dkotlin.caching.enabled=false）。\n编译器选项要指定附加的编译选项，请使用 Kotlin 编译任务的 kotlinOptions 属性。\n当针对 JVM 时，对于生产代码这些任务称为 compileKotlin 而对于测试代码称为 compileTestKotlin。对于自定义源文件集（source set）这些任务称呼取决于 compile＜Name＞Kotlin 模式。\nAndroid 项目中的任务名称包含构建变体 名称，并遵循 compile&lt;BuildVariant&gt;Kotlin 的模式，例如 compileDebugKotlin、 compileReleaseUnitTestKotlin。\n当针对 JavaScript 时，这些任务分别称为 compileKotlin2Js 与 compileTestKotlin2Js，以及对于自定义源文件集称为 compile＜Name＞Kotlin2Js。\n要配置单个任务，请使用其名称。示例：\ncompileKotlin &#123;\n    kotlinOptions.suppressWarnings = true\n&#125;\n\ncompileKotlin &#123;\n    kotlinOptions &#123;\n        suppressWarnings = true\n    &#125;\n&#125;\n对于 Gradle Kotlin DSL，首先从项目的 tasks 中获取任务：\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n// ……\n\nval compileKotlin: KotlinCompile by tasks\n\ncompileKotlin.kotlinOptions.suppressWarnings = true\n相应地，为 JS 与 Common 目标使用类型 Kotlin2JsCompile 与 KotlinCompileCommon。\n也可以在项目中配置所有 Kotlin 编译任务：\ntasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile::class.java).all &#123;\n    kotlinOptions &#123; …… &#125;\n&#125;\n对于 Gradle 任务的完整选项列表如下：\nJVM、JS 与 JS DCE 的公共属性\n\n\n名称\n描述\n可能的值\n默认值\n\n\n\nallWarningsAsErrors\n任何警告都报告为错误\n\nfalse\n\n\nsuppressWarnings\n不生成警告\n\nfalse\n\n\nverbose\n启用详细日志输出\n\nfalse\n\n\nfreeCompilerArgs\n附加编译器参数的列表\n\n[]\n\n\nJVM 与 JS 的公共属性\n\n\nName\nDescription\nPossible values\nDefault value\n\n\n\napiVersion\n只允许使用来自捆绑库的指定版本中的声明\n“1.0”、 “1.1”、 “1.2”、 “1.3”、 “1.4 (EXPERIMENTAL)”\n\n\n\nlanguageVersion\n提供与指定语言版本源代码兼容性\n“1.0”、 “1.1”、 “1.2”、 “1.3”、 “1.4 (EXPERIMENTAL)”\n\n\n\nJVM 特有的属性\n\n\n名称\n描述\n可能的值\n默认值\n\n\n\njavaParameters\n为方法参数生成 Java 1.8 反射的元数据\n\nfalse\n\n\njdkHome\n要包含到 classpath 中的 JDK 主目录路径，如果与默认 JAVA_HOME 不同的话\n\n\n\n\njvmTarget\n生成的 JVM 字节码的目标版本（1.6 或 1.8），默认为 1.6\n“1.6”、 “1.8”\n“1.6”\n\n\nnoJdk\n不要在 classpath 中包含 Java 运行时\n\nfalse\n\n\nnoReflect\n不要在 classpath 中包含 Kotlin 反射实现\n\ntrue\n\n\nnoStdlib\n不要在 classpath 中包含 Kotlin 运行时\n\ntrue\n\n\nJS 特有的属性\n\n\n名称\n描述\n可能的值\n默认值\n\n\n\nfriendModulesDisabled\n禁用内部声明导出\n\nfalse\n\n\nmain\n是否要调用 main 函数\n“call”、 “noCall”\n“call”\n\n\nmetaInfo\n使用元数据生成 .meta.js 与 .kjsm 文件。用于创建库\n\ntrue\n\n\nmoduleKind\n编译器生成的模块类型\n“plain”、 “amd”、 “commonjs”、 “umd”\n“plain”\n\n\nnoStdlib\n不使用捆绑的 Kotlin stdlib\n\ntrue\n\n\noutputFile\n输出文件路径\n\n\n\n\nsourceMap\n生成源代码映射（source map）\n\nfalse\n\n\nsourceMapEmbedSources\n将源代码嵌入到源代码映射中\n“never”、 “always”、 “inlining”\n\n\n\nsourceMapPrefix\n源代码映射中路径的前缀\n\n\n\n\ntarget\n生成指定 ECMA 版本的 JS 文件\n“v5”\n“v5”\n\n\ntypedArrays\n将原生数组转换为 JS 带类型数组\n\ntrue\n\n\n生成文档要生成 Kotlin 项目的文档，请使用 Dokka； 相关配置说明请参见 Dokka README 。Dokka 支持混合语言项目，并且可以生成多种格式的输出 ，包括标准 JavaDoc。\nOSGi关于 OSGi 支持请参见 Kotlin OSGi 页。\n使用 Gradle Kotlin DSL使用 Gradle Kotlin DSL 时，请使用 plugins &#123; …… &#125; 块应用 Kotlin 插件。如果使用 apply &#123; plugin(……) &#125; 来应用的话，可能会遇到未解析的到由 Gradle Kotlin DSL 所生成扩展的引用问题。为了解决这个问题，可以注释掉出错的用法，运行 Gradle 任务 kotlinDslAccessorsSnapshot，然后解除该用法注释并重新运行构建或者重新将项目导入到 IDE 中。\n","categories":["Kotlin"],"tags":["Android","Kotlin"]},{"title":"(三)Kotlin 高阶函数","url":"https://blog.onestravel.cn/20181208/5a7806e57e9b/","content":"一、基本概念\n传入或者返回函数的函数\n函数引用  ::println\n带有 Receiver 的引用 pdfPrinter::println\n\n二、常见高阶函数（forEach/map/flatMap）\nforEach : 迭代/遍历数组/list\n\n//forEach函数使用的一般结构\nobject.forEach&#123;\n    //todo\n&#125;\n\n例：\nval list = listOf(1,3,5,10,18,36,2,9)\nlist.forEach(::println)\nmap : 接受一个lambda表达式，并且有返回值，形成一个新的list\n\n//map函数使用的一般结构\nobject.map&#123;\n    //todo\n&#125;\n\n例：\nval newList = list.map&#123;\n    it * 2 + 3//相当于返回值\n&#125;\n\nval newList2 = list.map(Int::toDouble)\nflatMap : 集合数据进行合并成一个集合\n\n//map函数使用的一般结构\nobject.flatMap &#123;\n    it\n    //todo\n&#125;\n或\nobject.flatMap &#123;\n    it.map &#123;\n        //todo\n    &#125;\n&#125;\n\n\n例：\nval list = listOf(\n    1..20,\n    2..15,\n    100..166)\n val flatList = list.flatMap&#123;\n     it\n &#125;   \n\n  val flatList = list.flatMap&#123;\n     it.map&#123;\n         &quot;No.$it&quot;\n     &#125;\n &#125;\n\nreduce : 使用reduce对集合进行计算操作\n\n//reduce函数使用的一般结构\nobject.reduce&#123;acc,i -&gt;\n    //acc 为累计的结果\n    //acc todo\n&#125;\n\n例：\nlist.reduce&#123;acc,i -&gt; acc + i&#125;\n\nfun factorial(n: Int):Int&#123;\nif(n==0) return 1\nreturn (1..n)reduce&#123;acc,i -&gt; acc * i&#125;\n&#125;\n\n//对0-6的数分别求阶乘，并且打印出来\n(0..6).map(::factorial).forEach(::println)\n\nfold : 使用fold对集合进行自定义计算\n\n//fold函数使用的一般结构\nobject.fold([初始值])&#123;acc,i -&gt;\n    //todo\n&#125;\n\n例：\n// 对0-6 的阶乘进行求和并加上初始值 5\nprintln((0..6).map(::factorial).fold(5)&#123;acc,i -&gt;\n acc + i\n&#125;)\n\n//字符串拼接\nprintln((0..6).map(::factorial).fold(StringBuilder())&#123;acc,i -&gt;\n acc.append(i).append(&quot;,&quot;)\n&#125;)\n\n// 字符串连接\nprintln((0..6).joinToString(&quot;,&quot;))\n\nfoldRight : 与fold不同的是顺序相反\n\n//foldRight函数使用的一般结构\nobject.foldRight([初始值])&#123;i,acc -&gt;\n    //todo\n&#125;\n\n例：\n\n//字符串拼接\nprintln((0..6).map(::factorial).foldRight(StringBuilder())&#123;i,acc -&gt;\n acc.append(i).append(&quot;,&quot;)\n&#125;)\nfilter : 传入Lambda 表达式为true是，保留该元素；使用filter对集合进行按条件过滤\n\n//filter函数使用的一般结构\nobject.filter&#123;\n    //todo\n&#125;\n\n例：\n//给一个长度为 n 的数组，每个元素都在 [1,n] 之间，要求找出 [1,n] 中没有在数组里出现的元素。\nfun findDisappearNumbers(nums: IntArray): List&lt;Int&gt; &#123;\n    val ifAppear = BooleanArray(nums.size + 1)\n    nums.forEach &#123; ifAppear[it] = true &#125;\n    return ifAppear.mapIndexed &#123;\n        index, boolean -&gt;\n        if (boolean || index == 0) -1 else index\n    &#125;.filter &#123; it != -1 &#125;\n&#125;\ntakeWhile : 循环遍历集合，直到第一个不满足条件的数据时，停止循环\n\n//takeWhile函数使用的一般结构\nobject.takeWhile&#123;\n    //todo\n&#125;\nlet : let扩展函数的实际上是一个作用域函数，当你需要去定义一个变量在一个特定的作用域范围内，let函数的是一个不错的选择；let函数另一个作用就是可以避免写一些判断null的操作。\n\n//let函数使用的一般结构\nobject.let&#123;\nit.todo()//在函数体内使用it替代object对象去访问其公有的属性和方法\n...\n&#125;\n\n//另一种用途 判断object为null的操作\nobject?.let&#123;//表示object不为null的条件下，才会去执行let函数体\nit.todo()\n&#125;\n\n例：\ndata class Person(val name: String,val age:Int)&#123;\n    fun work()&#123;\n        println(&quot;$name is working!!!&quot;)\n    &#125;\n&#125;\n\nfun findPerson():Person?&#123;\n    return null\n&#125;\n\nfun main(args: Array&lt;String&gt;)&#123;\n    findPerson()?.let&#123;person -&gt;\n        person.work()\n        println(person.age)\n    &#125;\n&#125;\n\napply : apply一般用于一个对象实例初始化的时候，需要对对象中的属性进行赋值;一般可用于多个扩展函数链式调用 ;数据model多层级包裹判空处理的问题\n\n//apply函数使用的一般结构\nobject.apply&#123;\n//todo\n&#125;\n\n//例：\n//1、\ndata class Person(val name: String,val age:Int)&#123;\n    fun work()&#123;\n        println(&quot;$name is working!!!&quot;)\n    &#125;\n&#125;\n\nfun findPerson():Person?&#123;\n    return null\n&#125;\n\nfun main(args: Array&lt;String&gt;)&#123;\n    findPerson()?.apply&#123;\n        work()\n        println(age)\n    &#125;\n&#125;\n\n//2、\nmSectionMetaData?.apply&#123;\n\n//mSectionMetaData不为空的时候操作mSectionMetaData\n\n&#125;?.questionnaire?.apply&#123;\n\n//questionnaire不为空的时候操作questionnaire\n\n&#125;?.section?.apply&#123;\n\n//section不为空的时候操作section\n\n&#125;?.sectionArticle?.apply&#123;\n\n//sectionArticle不为空的时候操作sectionArticle\n\n&#125;\n\nwith : 适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可\n\n//with函数使用的一般结构\nwith(object)&#123;\n   //todo\n &#125;\n\n 例：\n val br = Buffered\nrun ： run函数是let,with两个函数结合体，准确来说它弥补了let函数在函数体内必须使用it参数替代对象，在run函数中可以像with函数一样可以省略，直接访问实例的公有属性和方法，另一方面它弥补了with函数传入对象判空问题，在run函数中可以像let函数一样做判空处理\n\n//run函数使用的一般结构\nobject.run&#123;\n//todo\n&#125;\nalso : 适用于let函数的任何场景，also函数和let很像，只是唯一的不同点就是let函数最后的返回值是最后一行的返回值而also函数的返回值是返回当前的这个对象。一般可用于多个扩展函数链式调用\n\n//also函数使用的一般结构\nobject.also&#123;\n//todo\n&#125;\nuse : use函数作用于现实了Closeable接口的类，比如文件io操作\n\n//use函数使用的一般结构\nobject.use&#123;\n    //todo\n&#125;\n\n例：\nvar l = BufferedReader(FileReader(&quot;123.txt&quot;)).use &#123;\n    var line: String = &quot;&quot;\n    while (true)&#123;\n        line += it.readLine()?: break\n    &#125;\n    line\n&#125;\nprintln(l)\n三、尾递归优化\n递归的一种特殊形式\n调用自身后无其他操作\ntailrec 关键字提示编译器尾递归优化\n尾递归与迭代的关系，尾递归一般情况下可以直接转换为迭代\n\n四、闭包\n闭包就是函数的运行环境\n持有函数运行状态\n函数内部可以定义函数\n函数内部也可以定义类\n\n五、函数复合\n函数复合就是f(g(x))的形式的函数\n\n六、Currying (科理化)\n就是多元函数变成一元函数调用链\n\nfun log(tag:String,target:OutputStream,message:Any?)&#123;\n    target.write(&quot;[$tag]: $message\\n&quot;.toByteArray())\n&#125;\n\nfun curriedLog(tag:String):(target:OutputStream) -&gt; (message:Any?)&#123;\n    //todo\n&#125;\n//fun log(tag:String)\n//    =fun (target:OutputStream)\n//    =(message:Any?)\n//    =target.write(&quot;[$tag]: $message\\n&quot;.toByteArray())\n\nfun&lt;P1,P2,P3,R&gt; Function3&lt;P1,P2,P3,R&gt;.curried()\n    =fun(p1:P1)=fun(p2:P2)=fun(p3:P3)=this(p1,p2,p3)\n\nfun main(args: Array&lt;String&gt;)&#123;\n    log(&quot;Test&quot;,System.out,&quot;Hello World！&quot;)\n   // log(&quot;Test&quot;)(System.out)(&quot;Hello World Currying&quot;)\n    ::log.curried()(&quot;Test&quot;)(System.out)(&quot;Hello World Currying&quot;)\n&#125;七、偏函数\n传入部分参数之后得到的新函数就是偏函数\n\nfun log(tag:String,target:OutputStream,message:Any?)&#123;\n    target.write(&quot;[$tag]: $message\\n&quot;.toByteArray())\n&#125;\n\nfun&lt;P1,P2,P3,R&gt; Function3&lt;P1,P2,P3,R&gt;.curried()\n    =fun(p1:P1)=fun(p2:P2)=fun(p3:P3)=this(p1,p2,p3)\n\nfun main(args: Array&lt;String&gt;)&#123;\n    val consoleLog = (::log.cueried())(&quot;Test out&quot;)(System.out)\n    consoleLog(&quot;Hello 偏函数！&quot;)\n&#125;\n","categories":["Kotlin"],"tags":["Android","Kotlin"]},{"title":"(二)Kotlin 面向对象","url":"https://blog.onestravel.cn/20181207/c5692c65d25c/","content":"一、面向对象的概念\n本质上就是解决如何用程序描述世界的问题\n讨论如何把实际存在的东西映射成程序的类和对象\n一种程序设计的思路,思想,方法\n程序设计层面的概念\n设计模式：前人的程序设计经验\n\n二、抽象类与接口相当于半成品与协议\n1、接口\n接口，直观理解就是一种约定\n\ninterface InputDevice&#123;\n    fun input(event: Any)\n&#125;\n接口不能有状态\n必须由类对其进行实现后使用\n\n2、抽象类\n实现了一部分协议的半成品\n可以有状态，可以有方法实现\n必须由子类继承后使用\n\n3、抽象类和接口的共性\n比较抽象，不能直接实例化\n需要有子类（实现类）实现的方法\n父类（接口）变量可以接受子类（实现类）的赋值\n\n3、抽象类和接口的区别\n抽象类有状态，接口没有状态\n抽象类有方法实现，接口只能有无状态的默认实现\n抽象类只能单继承，接口可以多实现\n抽象类反应本质，接口体现能力\n\n三、类的继承与接口的实现\n父类需要 open 才可以被继承\n父类方法、属性需要 open 才可以倍复写\n接口、接口方法、抽象类默认为 open\n复写父类（接口）成员需要 override 关键字\nclass D:A(),B,C\n注意继承类时实际上调用了父类构造方法\n类只能单继承，接口可以多实现\n\n接口代理\nclass Manager(driver: Driver):Driver by driver\n接口方法实现交给代理类实现\n\n接口方法冲突- 接口方法可以有默认实现\n- 签名一致且返回值相同的冲突\n- 子类（实现类）必须复写冲突方法\n- super&lt;[父类（接口）名]&gt;.[方法名]([参数列表])四、类及其成员的可见性\n\n\nKotlin\nJava\n\n\n\nprivate\nprivate\n\n\nprotected\nprotected\n\n\n–\ndefault(包内可见)\n\n\ninternal(模块内可见)\n–\n\n\npublic\npublic\n\n\n五、object\n只有一个实例的类（单例）\n不能自定义构造方法\n可以实现接口、继承父类\n本质上就是单例模式最基本的实现\n\n六、伴生对象与静态成员\n每个类可以对应一个伴生对象\n伴生对象的成员全局独一份\n伴生对象的成员类似Java的静态成员\n静态成员考虑用包级函数、变量代替\n使用JvmField和JvmStatic，可以让伴生对象在Java中使用时看起来像静态成员和静态方法\n\n七、方法重载(Overloads)和默认参数重载\n写了一个方法和已经存在的方法重名，参数不相同\nJvm函数签名的概念：函数名、参数列表\n跟返回值没有关系\n\n默认参数\n为函数参数设定一个默认值\n可以为任意位置的参数设置默认值\n函数调用产生混淆时用具名参数\n\n方法重载与默认参数\n方法重载与默认参数可以互相转换，在Java中调用有默认参数的方法时，该方法需要使用注解@JvmOverloads\n避免定义关系不大的重载方法\n\n八、扩展成员（二次加工）\n为现有类添加方法、属性\n\nfun X.y():Z&#123;...&#125;\nval X.m\n//注意扩展属性不能初始化，类似接口属性\nJava 调用扩展成员类似调用静态方法\n\n\n九、属性代理\n定义方法\n\nval/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;\n代理者需要实现相应的setValue/getValue方法\n\nby lazy 就是在第一次使用的时候才去实例化对象\n\n\n十、数据类（data class）\n默认实现 copy()、toString()、equals()等方法\n编译器默认生成component[1-N]方法，可以自己复写\n\ndata class China(val code:Int,name: String)\nval (a,b) = China(0,&quot;中国&quot;)\npringln(&quot;$a -&gt; $b&quot;)\nallOpen和noArg 插件解决data class 的类被解析成final类，并且无空构造方法的问题\n\n//build.gradle 中的 dependencies 中添加\ndependencies&#123;\n    classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;\n    classpath &quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;\n    classpath &quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;\n&#125;\n\n//build.gradle 中 添加插件的应用\napply plugin: &#39;kotlin-noarg&#39;\napply plugin: &#39;kotlin-allopen&#39;\n\n// 插件的配置\n\nnoArg&#123;\n    annotation(&quot;注解类名&quot;)\n&#125;\n\nallOpen&#123;\n    annotation(&quot;注解类名&quot;)\n&#125;\n属性需要写到构造方法，初始化时需要传入参数\n\n十一、内部类\n定义在类内部的类\n与类成员有相似的访问控制\n默认是静态内部类，非静态用 inner 关键字\nthis@Outter 与 this@Inner\n\n匿名内部类\n没有定义名字的类\n类名编译时生成，类似Outter$1.class\n可继承父类、实现多个接口，与Java 不一样\n\n十二、枚举类\n实例可数的类，注意枚举也是类\n可以修改构造方法，添加成员\n可以提升代码的表现力，也有一定的性能开销\n\n十二、密封类（sealed class）\n子类可数的类  \n&lt;V1.1,子类必须定义为密封类的内部类   \nv1.1开始,子类只需要与密封类在同一个文件中\n子类可以有多个构造参数\n表示状态适合使用枚举，需要传输指令时适合使用密封类\n\n","categories":["Kotlin"],"tags":["Android","Kotlin"]},{"title":"(一)Kotlin 基础语法","url":"https://blog.onestravel.cn/20181206/0151de5b59e5/","content":"一、 Kotlin语法1. 变量与常量 &lt;修饰符&gt; &lt;变量/常量名&gt;[:类型] = [值]在一般情况下:[类型]可省略，编译器进行类型推导\n常量：//val 修饰的为常量，不可再次赋值\nval FINAL_HELLO_WORLD :String = &quot;Hello World&quot;\n\nval USER_TYPE = &quot;Admin&quot;变量：//var 修饰的为变量，值可变化\nvar index:Int =1\n//index 自增\nindex++\n\nvar username=&quot;ZhangSan&quot;字符串模板：在Kotlin中可使用字符串模板来实现字符串中输出变量/常量值\nvar username=&quot;ZhangSan&quot;\nfun main(args:Array&lt;String&gt;)&#123;\n    username = args[0]\n    println(&quot;欢迎 $&#123;username&#125; 登录系统！&quot;)\n&#125;2. 函数（得函数者得天下）\n[函数修饰符] [函数名称]([参数列表])[:返回值类型]{[函数体]}\n\n[函数修饰符] [函数名称]([参数列表])=[表达式]\n\n注：[]中的内容可省略，编译器可进行类型推导得出\n\n\n\n // 根据时间字符串返回日期\nprivate fun getDate(dateStr:String): Date &#123;\n    val sdf = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)\n    return sdf.parse(dateStr)\n&#125;\n\n\n// 传入两个整形数，计算他们的和并输出\nfun add(num1:Int,num2:Int)&#123;\n    println(&quot;$num1 + $num2 = $&#123;num1+num2&#125;&quot;)\n&#125;\n\n// 传入姓名，输出 Hi [传入的姓名]\nfun sayHi(name:String)=println(&quot;Hi $name&quot;)\n\n\n匿名函数\n\n匿名函数就是没有函数名称的函数，但是匿名函数必须赋值给一个变量/常量\n// 匿名函数\nval sayHi = fun(name:String)=println(&quot;Hi $name&quot;)3. Lambda 表达式Lambda 表达式 就是匿名函数\n\n语法：{[参数列表] -&gt; [函数体，最后一行是返回值]}\n\n例如：\nval sum = &#123;a:Int,b:Int -&gt; a+b&#125;\nLambda 表达式类型表示\n\n// 无参，返回值为Unit\n() -&gt; Unit\n\n// 传入整型，返回一个整型\n(Int) -&gt; Int\n\n// 传入字符串、Lambda表达式，返回Boolean\n(String,(String) -&gt; String) -&gt; Boolean\nLambda 表达式的调用\n\n用()进行调用\n等价于 invoke()\nval sum = &#123;a:Int,b:Int -&gt; a+b&#125;\nsum(2,3)\nsum.invoke(2,3)\nLambda 表达式的简化\n\n函数参数调用时最后一个Lambda可以移出去\n函数参数只有一个Lambda，调用时小括号可以省略\nLambda只有一个参数可以默认为it\n入参、返回值与形参一致的函数可以用函数的引用的方式作为实参传入\nval arr: Array&lt;String&gt; = arrayOf(&quot;1&quot;,&quot;s&quot;,&quot;sd&quot;,&quot;rer&quot;,&quot;54&quot;,&quot;65&quot;)\n\n// Lambda 表达式 ，传入it ,并且打印it\n// Lambda只有一个参数可以默认为it\narr.forEach(&#123;it -&gt; println(it)&#125;)\n\n// 上面的Lambda 表达式简化后\n// Lambda只有一个参数可以默认为it\n// 函数参数调用时最后一个Lambda可以移出去\narr.forEach()&#123;println(it)&#125;\n\n// 上面的Lambda 表达式简化后\n// Lambda只有一个参数可以默认为it\n// 函数参数只有一个Lambda，调用时小括号可以省略\narr.forEach&#123;println(it)&#125;\n\n// 上面的Lambda 表达式简化后\n// Lambda只有一个参数可以默认为it\n// 入参、返回值与形参一致的函数可以用函数的引用的方式作为实参传入\narr.forEach(::println)\n\n\n\n// 判断数组中值为rer 是跳出本次循环，继续下次循环，相当于continue\n\n arr.forEach ForEach@&#123;\n     if(it == &quot;rer&quot;) return@ForEach\n     println(it)\n &#125;\n\n// 判断数组中值为rer 是跳出循环，不再进行下面的循环，继续制作该循环后面的代码\n run breaking@ &#123;\n     arr.forEach &#123;\n        if(it == &quot;rer&quot;) return@breaking\n        println(it)\n    &#125;&#125;3. 类成员\n属性：或者说成员变量，类范围内的变量\n方法：或者说成员函数，类范围内的函数\n\n函数和方法的区别：\n函数强调功能本身，不考虑从属\n方法的称呼通常是从类的角度出发\n只是叫法不同而已\n\n定义属性\n\n构造方法参数中val/var 修饰的都是属性\n类内部也可以定义属性\nclass Hello(val aFiled:Int,notAField:Int)&#123;\n    var anotherField:Float = 3f\n&#125;\n属性访问控制\n\n属性可以定义getter/setter\nval a: Int=0\n    get()=field\n\nvar b: Float = 0f\n    get()&#123;\n        return field / 3;\n    &#125;\n    set(value)&#123;field = value&#125;\n属性初始化\n\n属性的初始化尽量在构造方法中完成\n无法在构造方法中初始化，尝试降级为局部变量\nvar 用 lateinit 延迟初始化，val 用 lazy 延迟初始化\n可空类型谨慎用 null 直接初始化\n4. 运算符( +-*/%^? )官网定义\n\n\n\nExpression\nTranslated to\n\n\n\n+a\na.unaryPlus()\n\n\n-a\na.unaryMinus()\n\n\n!a\na.not()\n\n\n—\n—\n\n\na++\na.inc() + see below\n\n\na–\na.dec() + see below\n\n\n—\n—\n\n\na+b\na.plus(b)\n\n\na-b\na.minus(b)\n\n\na*b\na.times(b)\n\n\na/b\na.div(b)\n\n\na%b\na.rem(b),a.mod(b)(deprecated)\n\n\na..b\na.rangeTo(b)\n\n\n—\n—\n\n\na in b\nb.contains(a)\n\n\na !in b\n!b.contains(a)\n\n\n—\n—\n\n\na[i]\na.get(i)\n\n\na[i,j]\na.get(i,j)\n\n\na[i_1,…,i_n]\na.get(i_1,…,i_n)\n\n\na[i] = b\na.set(i,b)\n\n\na[i,j] = b\na.set(i,,j,b)\n\n\na[i_1,…,i_n] =b\na.set(i_1,…,i_n,b)\n\n\n—\n—\n\n\na()\na.invoke()\n\n\na(i)\na.invoke(i)\n\n\na(i,j)\na.invoke(i,j)\n\n\n—\n—\n\n\na += b\na.plusAssign(b)\n\n\na -= b\na.minusAssign(b)\n\n\na *= b\na.timesAssign(b)\n\n\na /= b\na.divAssign(b)\n\n\na %= b\na.modAssign(b)\n\n\n\n基本运算符\n\n任何类可以定义或者重载父类的基本运算符\n通过运算符对应的具名函数来定义\n对参数的个数做要求，对参数和返回值类型不做要求\n不能像 Scala 一样定义人与运算符\n// 定义一个复数，实部与实部相加，虚部与虚部相加\nclass Complex(var real: Double,var imaginary: Double)&#123;\n    operator fun plus(other: Complex):Complex&#123;\n        return Complex(real+other.real,imaginary + other.imaginary)\n    &#125;\n    override fun toString():String&#123;\n        return &quot;$real + $&#123;imaginary&#125;i&quot;\n    &#125;\n&#125;\n\n\nfun main(args: Array&lt;String&gt;)&#123;\n    val c1 = Complex(3.0,4.0)//3.0+4.0i\n    val c2 = Cpmplex(2.0,7.5)//2.0+7.5i\n    println(c1 + c2)\n&#125;\n中缀表达式\n\n只有一个参数，且用infix 修饰的函数\nclass Book &#123;\n    infix fun on(place:String)&#123;...&#125;\n&#125;\n\nBook() on &quot;My Desk&quot;\n分支表达式\n\nif 表达式if … else\nif(a == b) ... else if(a == c) ... else ...表达式与完备性\n\n\nval x = if(b&lt;0) 0 else b\n\nval x = if(b&lt;0)0 //错误，赋值时，分支必须完备\nwhen 表达式\n\n加强版的 switch ，支持任意类型\n支持纯表达式条件分支（类似if）\n表达式与完备性特性\n\n循环语句\n\n基本写法:for(element in elements) …\n给任意类实现 Iterator 方法\nval arr: Array&lt;String&gt; = arrayOf(&quot;1&quot;,&quot;s&quot;,&quot;sd&quot;,&quot;rer&quot;,&quot;54&quot;,&quot;65&quot;)\n\nfor(a in arr)&#123;\n    println(a)\n&#125;\n\n\nfor((index,value) in arr.withIndex())&#123;\n    println(&quot;$index -&gt; $value&quot;)\n&#125;\n\nfor(indexedValue in arr.withIndex())&#123;\n    println(&quot;$&#123;indexedValue.index&#125; -&gt; $&#123;indexedValue.value&#125;&quot;)\n&#125;\n\n\nclass MyIterator(val iterator: Iterator&lt;Int&gt;)&#123;\n    operator fun next():Int&#123;\n        return iterator.next\n    &#125;\n\n     operator fun hasNext():Boolean&#123;\n        return iterator.hasNext()\n    &#125;\n&#125;\n\ncal MyIntList&#123;\n    private val list = ArrayList&lt;Int&gt;()\n\n    fun add(int: Int)&#123;\n        list.add(int)\n    &#125;\n\n    fun remove(int: Int)&#123;\n        list.remove(int)\n    &#125;\n\n    operator fun iterator():MyIterator&#123;\n        return MyIterator(list.iterator())\n    &#125;\n&#125;\n\n\nfun main(args: Array&lt;String&gt;)&#123;\n    val list = MyIntList()\n    list.add(1)\n    list.add(2)\n    list.add(3)\n\n    for(i in list)&#123;\n        println(i)\n    &#125;\n\n&#125;\n\n// while\nvar x=5\nwhile(x&gt;0)&#123;\n    println(x)\n    x--\n&#125;\n\n\ndo&#123;\n   println(x)\n    x--\n&#125;while(x&gt;0)\n\n跳出或跳过循环\n\n跳出，终止循环  break  \n跳过当前循环  continue  \n多层循环嵌套的终止结合标签使用\nOutter@for(...)&#123;\n    Inner@while(i&lt;0)&#123;\n        if(...) break@Outter\n    &#125;\n&#125;5. 异常捕获使用 try{}catch(e: Exception){} 进行异常捕获\ntry&#123;  \n    //程序正常执行\n&#125;catch(e: Exception)&#123;\n    //程序出现异常，可根据异常类型捕获相应的异常\n&#125;finally&#123;\n    //无论执行成功还是出现异常都会执行\n&#125;6. 具名参数给函数的实参附上形参\nfun sum(arg1:Int,arg2:Int) = arg1 + arg2\n\nsun(arg2=3,arg1=2)7. 变长参数使用 vararg 修饰\n某个参数可以接受多个值\n可以不为最后一个参数\n如果传参是由歧义，需要使用具名参数\n8. Spread Operator使用 * 来展开\n只支持展开Array\n只用于变长列表的实参\nval arr=intArrayOf(1,2,3,4,5)\n\nfun printMethod(vararg arrs:Int)&#123;\n    arrs.forEach(::println)\n&#125;\n\nprintMethod(*arr)\n9.默认参数为函数参数指定默认值\n可以为任意位置的参数指定默认值\n传参时，如果有歧义，需要使用具名参数\nval arr=intArrayOf(1,2,3,4,5)\n\nfun printMethod(name:String = &quot;admin&quot;,vararg arrs:Int)&#123;\n    arrs.forEach(::println)\n&#125;\n\nprintMethod(arrs=*arr)10. 导出可执行程序\n在build.gradle 中增加\n\napply plugin: &#39;application&#39;\nmainClassName = &quot;&quot;//程序入口类路径，Kotlin文件名后加 Kt\ngradle 刷新/同步\ngradle 中的distribution 中点击installDist得到可执行的文件\n在项目目录下的build文件夹下的install文件夹下\n\n//命令行输入：\n# cd build/install/[项目名称]\n# chmod 755 bin/[项目名称]\n# bin/[项目名称]","categories":["Kotlin"],"tags":["Android","Kotlin"]},{"title":"（六）C++中的类型转换与STL标准模板库","url":"https://blog.onestravel.cn/20181123/fb0f12f8cca8/","content":"C++中的类型转换与STL标准模板库一、C++类型转换在C++中类型转换包含 static_cast、const_cast、dynamic_cast、reinterpret_cast 四种类型转换。使用原始类型转换，所有转换都是一种写法，可读性不高，有可能有潜在的风险\n1、static_cast该类型转换函数用于不同类型的属性之间的转换\n#include &lt;iostream&gt;\nusing namespace std;\n\n\nvoid* func()&#123;\n    int i = 0;\n    return &amp;i;\n&#125;\nvoid main()&#123;\n    //自动类型转换\n    //int i = 0;\n    //double d = i;\n    //或\n    //double d = 9.5;\n    //int i = d;\n\n    // int i = 8;\n    // double d = 9.5;\n    // i = static_cast&lt;int&gt;(d);\n    // cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;\n\n    int i = 9;\n    int *i_p = &amp;i;\n&#125;void* 转 char*\nvoid* func(int type)&#123;\n    switch(type)&#123;\n        case 1:\n            int i = 11;\n            return &amp;i;\n        case 2:\n            int a = &#39;X&#39;;\n            return &amp;a;\n        default:\n            return NULL;\n    &#125;\n&#125;\nvoid main()&#123;\n   //void* 转 char*\n   //char* c_p = (char*)func(2);\n   char* c_p = static_cast&lt;char*&gt;(func(2));\n\n   //C++\n\n   func\n   //C\n&#125;2、const_cast该类型转换函数用于去常量，一般使用在常量属性转为非常量属性时使用\nvoid func(char c[])&#123;\n    //可以修改\n    c[0] = &#39;H&#39;;\n    c[1] = &#39;a&#39;;\n&#125;\n\nvoid func2(const char c[])&#123;\n    //c[0] = &#39;H&#39;; //不能修改\n    //c[1] = &#39;a&#39;;//不能修改\n    //通过指针间接赋值\n    //其他人并不知道，这次转型是为了去常量\n    //char* c_p = (char*)c;\n    //c_p[1] = &#39;a&#39;;\n    //cout &lt;&lt; c &lt;&lt; endl;\n\n    //C++ 去常量，可读性高\n    char* c_p = const_cast&lt;char*&gt;(c);\n    c_p[1] = &#39;y&#39;;\n    cout &lt;&lt; c &lt;&lt; endl;\n&#125;\n\nvoid main()&#123;\n    char c[] = &quot;hello&quot;;\n    func2(c);\n\n    getchar();\n&#125;3、dynamic_cast该类型转换用于父类对象转换为子类时使用，处理父类转为子类时的不确定性（类型不匹配时转型失败，返回NULL）\nclass Person&#123;\npublic:\n    virtual void print()&#123;\n        cout &lt;&lt; &quot;人&quot; &lt;&lt;endl;\n    &#125;    \n&#125;;\n\nclass Man : public Person&#123;\npublic:\n    void print()&#123;\n        cout &lt;&lt; &quot;男人&quot; &lt;&lt;endl;\n    &#125;\n    void smoking()&#123;\n        cout &lt;&lt; &quot;吸烟&quot; &lt;&lt;endl;\n    &#125;\n&#125;;\n\nclass Woman : public Person&#123;\npublic:\n    void print()&#123;\n        cout &lt;&lt; &quot;女人&quot; &lt;&lt;endl;\n    &#125;\n    void makeup()&#123;\n        cout &lt;&lt; &quot;化妆&quot; &lt;&lt;endl;\n    &#125;\n&#125;;\n\nvoid func(Person* obj)&#123;\n    obj-&gt;print();\n    //调用子类的特有函数，需要转为实际类型\n    //当传入Woman对象时，转型为Man，转型失败，但是编译器并为察觉\n    //Man* man = (Man*)obj;\n    //man-&gt;print();\n\n    //转型失败，返回NULL  \n   //Man* man = dynamic_cast&lt;Man*&gt;(obj);\n    //man-&gt;print();\n    Man* man = dynamic_cast&lt;Man*&gt;(obj);\n    if(man!=NULL)&#123;\n        man-&gt;smoking();\n    &#125;\n\n    Woman* woman = dynamic_cast&lt;Woman*&gt;(obj);\n    if(woman!=NULL)&#123;\n        woman-&gt;makeup();\n    &#125;\n\n\n&#125;\nvoid main()&#123;\n    Woman w1;\n    //父类类型的指针指向子类对象\n    Person* p = &amp;w1;\n    func(p);\n\n    getchar();\n&#125;4、reinterpret_cast该类型转换用于函数指针之间的转型，在使用函数指针转型时使用\nvoid func1()&#123;\n\n&#125;\n\nchar* func2()&#123;\n    return &quot;abc&quot;;\n&#125;\n\ntypedef void(*f_p)();\n\nvoid main()&#123;\n    f_p f_array[6];\n    f_array[0] = func1;\n    //C 方式\n    f_array[1] = (f_p)func2;\n    f_array[1] = reinterpret_cast&lt;f_p&gt;func2;\n\n\n    getchar();\n&#125;二、IO 流在 C++ 中，通过 头文件中的 ifstream 读取文件，ofstream 写入文件，完成 IO 流操作\n1、文本文件操作对于文本文件，可进行使用 ifstream 中的 get(ch) 读取一个字符；使用 fout &lt;&lt; 写入一个字符串\n\n#include &lt;fstream&gt;\nvoid main()&#123;\n    char fname[] = &quot;D://dest.text&quot;;\n    //输出流\n    ofstream fout(fname);\n    //创建失败\n    if(fout.bad())&#123;\n        return -1;\n    &#125;\n    fout &lt;&lt; &quot;Jack&quot; &lt;&lt; endl;\n    fout &lt;&lt; &quot;Rose&quot; &lt;&lt; endl;\n    fout.close();\n\n    //读取\n    ifstream fin(fname);\n    if(fin.bad())&#123;\n        return -2;\n    &#125;\n    char ch;\n    while(fin.get(ch))&#123;\n        cout &lt;&lt; ch;\n    &#125;\n    fin.close();\n&#125;2、二进制文件操作对于二进制文件，可进行使用 ifstream中的read(buff,1024) 读取二进制文件，通过 ofstream中的write(buff,1024) 写入到对应文件中\n\n#include &lt;fstream&gt;\nvoid main()&#123;\n    char src[] = &quot;D://xueshan.jpg&quot;;\n    char src_copy[] = &quot;D://xueshan_copy.jpg&quot;;\n     //读取\n    ifstream fin(src,ios::binary);\n\n    //输出流\n    ofstream fout(src_copy,,ios::binary);\n    //创建失败\n    if(fin.bad()||fout.bad())&#123;\n        return -1;\n    &#125;\n    while(!fin.eof())&#123;\n        char buff[1024] = &#123;0&#125;;\n        fin.read(buff,1024);\n        //写入\n        fout.write(buff, 1024);\n    &#125;\n    //关闭\n    fin.close();\n    fout.close();\n&#125;3、对象持久化class Person&#123;\nprivate:\n    char* name;\n    int age;\npublic:\n    Person()&#123;&#125;\n    Person(char* name,int age)&#123;\n        this-&gt;name = name;\n        this-&gt;age = age;\n    &#125;\n\n    char* getName()&#123;\n        return this-&gt;name;\n    &#125;\n\n    int getAge()&#123;\n        return this-&gt;age;\n    &#125;\n\n    void print()&#123;\n        cout &lt;&lt; this-&gt;name &lt;&lt; &quot;,&quot; &lt;&lt; this-&gt;age &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid main()&#123;\n    Person p1(const_cast&lt;char*&gt;(&quot;Jack&quot;),25);\n    Person p2(const_cast&lt;char*&gt;(&quot;Rose&quot;),22);\n    //输出流\n    ofstream fout(&quot;D://c_obj.data&quot;,ios::binary);\n    //指针能够读取到正确的数据，读取内存区的长度\n    fout.write((char*)(&amp;p1), sizeof(Person));\n    fout.write((char*)(&amp;p2), sizeof(Person));\n    fout.close();\n\n    //输入流\n    ifstream fin(&quot;D://c_obj.data&quot;,ios::binary);\n    Person tmp;\n    fin.read((char*)(&amp;tmp), sizeof(Person));\n    tmp.print();\n\n    fin.read((char*)(&amp;tmp), sizeof(Person));\n    tmp.print();\n&#125;三、STL(standard template library)标准模板库在 C++ 中包含很多标准模板库，可以让代码更加简洁\n1、string 模板库使用 string 模板库，在边写代码时更改简洁易用，但是在JNI中 string 需要转为 char* ,，在转为jstring返回\n1.1 string 初始化#include &lt;string&gt;\nvoid main()&#123;\n    string s1 = &quot;Hello &quot;;\n    string s2(&quot; every day&quot;);\n    string s3 = s1 + s2;\n    cout &lt;&lt; s3 &lt;&lt; endl;\n\n    //string 转 c 字符串,在JNI中要转为C的str 然后再转为jstring返回\n    const char* c_str = s1.c_str();\n    cout &lt;&lt; c_str &lt;&lt; endl;\n&#125;1.2 string 遍历#include &lt;string&gt;\n//string遍历\nvoid main()\n&#123;\n    string s1 = &quot;craig david&quot;;\n    //             ^\n    //1 数组方式\n    for (int i = 0; i &lt; s1.length(); i++)\n    &#123;\n        cout &lt;&lt; s1[i] &lt;&lt; endl;\n    &#125;\n    //2 迭代器指针\n    for (string::iterator it = s1.begin(); it != s1.end(); it++)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n    //3 at函数(charAt)\n    // 可能会抛出异常\n    try\n    &#123;\n        for (int i = 0; i &lt; s1.length() + 3; i++)\n        &#123;\n            cout &lt;&lt; s1.at(i) &lt;&lt; &quot; &quot;;\n        &#125;\n    &#125;\n    catch (...)\n    &#123;\n        cout &lt;&lt; &quot;异常&quot; &lt;&lt; endl;\n    &#125;\n\n\n    system(&quot;pause&quot;);\n&#125;1.3 string 字符串查找替换#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n//字符串查找替换\nvoid main()\n&#123;\n    string s1 = &quot;apple google apple iphone&quot;;\n    //从0开始查找&quot;google&quot;的位置\n    int idx = s1.find(&quot;google&quot;, 0);\n    cout &lt;&lt; idx &lt;&lt; endl;\n\n    //统计apple出现的次数\n    int idx_app = s1.find(&quot;apple&quot;,0);\n    //npos大于任何有效下标的值\n    int num = 0;\n    while (idx_app != string::npos)\n    &#123;\n        num++;\n        cout &lt;&lt; &quot;找到的索引:&quot; &lt;&lt; idx_app &lt;&lt; endl;\n        idx_app+=5;\n        idx_app = s1.find(&quot;apple&quot;, idx_app);\n    &#125;\n\n    cout &lt;&lt; num &lt;&lt; endl;\n    system(&quot;pause&quot;);\n&#125;\n1.4 string 删除（截取）和插入#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n//删除（截取）和插入\nvoid main()\n&#123;\n    string s1 = &quot;apple google apple iphone&quot;;\n    //删除a，找到a所在的指针\n    string::iterator it = find(s1.begin(),s1.end(),&#39;g&#39;);\n    //只能删除一个字符\n    s1.erase(it);\n\n    //开头末尾插入字符串\n    s1.insert(0, &quot;macos&quot;);\n    s1.insert(s1.length(), &quot; facebook&quot;);\n\n    cout &lt;&lt; s1 &lt;&lt; endl;\n    system(&quot;pause&quot;);\n&#125;\n1.5 string 大小写转换#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt; //算法\n\nusing namespace std;\n//java StringBuffer才可变\n//String 不可变\n//大小写转换\nvoid main()\n&#123;\n    string s1 = &quot;JASON&quot;;\n    //原始字符串的起始地址，原始字符串的结束地址, 目标字符串的起始地址, 函数名称\n    transform(s1.begin(), s1.end()-1,s1.begin(), tolower);\n    cout &lt;&lt; s1 &lt;&lt; endl;\n\n\n    transform(s1.begin(), s1.end() - 1, s1.begin(), toupper);\n    cout &lt;&lt; s1 &lt;&lt; endl;\n\n    system(&quot;pause&quot;);\n&#125;\n2、容器 vector 模板库使用 vector 模板库，不需要使用动态内存分配，就可以使用动态数组\n2.1 vector 初始化与遍历#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt; &amp;v)\n&#123;\n    //通过数组的方式遍历\n    for (int i = 0; i &lt; v.size(); i++)\n    &#123;\n        cout &lt;&lt; v[i] &lt;&lt; endl;\n    &#125;\n&#125;\n\n\nvoid main()&#123;\n    //动态数组\n    vector&lt;int&gt; v;\n    v.push_back(12);\n    v.push_back(118);\n    v.push_back(1);\n    v.push_back(52);\n    v.push_back(20);\n    //遍历\n    for(int i = 0; i&lt;v.size(); i++)&#123;\n        cout &lt;&lt; v[i] &lt;&lt; endl;\n    &#125;\n\n    //部分复制\n    vector&lt;int&gt; v3(v1.begin(),v1.begin()+2);\n     for(int i = 0; i&lt;v3.size(); i++)&#123;\n        cout &lt;&lt; v3[i] &lt;&lt; endl;\n    &#125;\n\n&#125;2.2 vector 添加和删除//添加 删除\nvoid main()\n&#123;\n    //添加到结尾\n    vector&lt;int&gt; v1;\n    v1.push_back(20);\n    v1.push_back(40);\n    v1.push_back(15);\n    v1.push_back(7);\n\n    //访问头部\n    v1.front() = 11;\n    //访问尾部\n    v1.back() = 90;\n\n    //删除结尾的元素\n    //v1.pop_back();\n    while (v1.size() &gt; 0)\n    &#123;\n        cout &lt;&lt; &quot;末尾的元素：&quot; &lt;&lt; v1.back() &lt;&lt; endl;\n        v1.pop_back();\n    &#125;\n\n    printVector(v1);\n\n    system(&quot;pause&quot;);\n&#125;2.3 vector 数组方式//数组的方式\nvoid main()\n&#123;\n    vector&lt;int&gt; v1;\n    v1.push_back(20);\n    v1.push_back(40);\n    v1.push_back(15);\n    v1.push_back(7);\n\n    v1[2] = v1[2] +10;\n\n    //容器等价于动态数组    \n    vector&lt;int&gt; v2(10);\n    for (int i = 0; i &lt; v2.size(); i++)\n    &#123;\n        v2[i] = i + 1;\n    &#125;\n\n    printVector(v2);\n\n    system(&quot;pause&quot;);\n&#125;2.4 vector 迭代器遍历//迭代器遍历\n//迭代器的种类（正向，反向迭代器）\nvoid main()\n&#123;\n    vector&lt;int&gt; v1;\n    v1.push_back(20);\n    v1.push_back(40);\n    v1.push_back(15);\n    v1.push_back(7);\n    //正向\n    for (vector&lt;int&gt;::iterator it = v1.begin(); it &lt; v1.end(); it++)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n    cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;\n    //反向迭代\n    for (vector&lt;int&gt;::reverse_iterator it = v1.rbegin(); it &lt; v1.rend(); it++)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n\n    system(&quot;pause&quot;);\n&#125;2.5 vector 插入和删除void main()\n&#123;\n    vector&lt;int&gt; v1(10);\n    for (int i = 0; i &lt; v1.size(); i++)\n    &#123;\n        v1[i] = i + 1;\n    &#125;\n\n    //删除指定位置\n    vector&lt;int&gt;::iterator it = v1.begin();\n    it += 3;\n    v1.erase(it);\n\n    //distance(v1.begin(), it);\n\n    //删除区间\n    v1.erase(v1.begin(), v1.begin() + 3);\n\n    for (vector&lt;int&gt;::iterator it = v1.begin(); it &lt; v1.end(); it++)\n    &#123;\n        if (*it == 5)\n        &#123;        \n            printf(&quot;%x\\n&quot;, it);\n            vector&lt;int&gt;::iterator tmp = v1.erase(it); //注意以后开发中编译器版本问题\n            printf(&quot;%x,%x\\n&quot;,it,tmp);\n        &#125;\n    &#125;\n\n    //插入\n    v1.insert(v1.begin() + 2, 100);\n    v1.insert(v1.end() - 1, 200);\n\n    printVector(v1);\n\n    system(&quot;pause&quot;);\n&#125;3、队列 deque 模板库3.1 双向队列\n//双向队列\n#include &lt;deque&gt;\nvoid printDeque(deque&lt;int&gt;&amp; q)\n&#123;\n    for (int i = 0; i &lt; q.size(); i++)\n    &#123;\n        cout &lt;&lt; q[i] &lt;&lt; endl;\n    &#125;\n&#125;\n\n\nvoid main()\n&#123;\n    deque&lt;int&gt; d1;\n    //添加到尾部\n    d1.push_back(2);\n    d1.push_back(10);\n    //添加到头部\n    d1.push_front(-90);\n    d1.push_front(-30);\n\n    //printDeque(d1);\n\n    //cout &lt;&lt; d1.front() &lt;&lt; endl;\n    //cout &lt;&lt; d1.back() &lt;&lt; endl;\n\n    //两个方向弹出\n    //d1.pop_back();\n    //d1.pop_front();\n\n    printDeque(d1);\n\n    //查找第一个-90元素索引位置，无需遍历\n    deque&lt;int&gt;::iterator it = find(d1.begin(), d1.end(), -90);\n    if (it != d1.end())\n    &#123;\n        int idx = distance(d1.begin(), it);\n        cout &lt;&lt; &quot;索引位置为：&quot; &lt;&lt; idx &lt;&lt; endl;\n    &#125;\n\n\n    system(&quot;pause&quot;);\n&#125;3.2 没有迭代器的队列#include &lt;iostream&gt;\n#include &lt;queue&gt;\nusing namespace std;\nvoid main()\n&#123;\n    queue&lt;int&gt; q;\n    q.push(78);\n    q.push(18);\n    q.push(20);\n    q.push(33);\n\n    //q.front();\n    //q.back();\n    while (!q.empty())\n    &#123;\n        int tmp = q.front();\n        cout &lt;&lt; tmp &lt;&lt; endl;\n        q.pop();\n    &#125;    \n    system(&quot;pause&quot;);\n&#125;3.3 优先级队列#include &lt;iostream&gt;\n#include &lt;queue&gt;\nusing namespace std;\nvoid main()\n&#123;\n    //默认 最大值优先级\n    priority_queue&lt;int&gt; pq1;\n    pq1.push(12);\n    pq1.push(3);\n    pq1.push(40);\n    pq1.push(15);\n\n    while (!pq1.empty())\n    &#123;\n        int tmp = pq1.top();\n        cout &lt;&lt; tmp &lt;&lt; endl;\n        pq1.pop();\n    &#125;\n\n    cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;\n    //最小值优先级队列\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq2;\n    pq2.push(12);\n    pq2.push(3);\n    pq2.push(40);\n    pq2.push(15);\n\n    while (!pq2.empty())\n    &#123;\n        int tmp = pq2.top();\n        cout &lt;&lt; tmp &lt;&lt; endl;\n        pq2.pop();\n    &#125;\n\n    system(&quot;pause&quot;);\n&#125;4、stack 栈 模板4.1 stack 栈的初始化\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n    stack&lt;int&gt; s;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        s.push(i + 1);\n    &#125;\n\n    while (!s.empty())\n    &#123;\n        int tmp = s.top();\n        cout &lt;&lt; tmp &lt;&lt; endl;\n        s.pop();\n    &#125;\n\n    system(&quot;pause&quot;);\n&#125;5、list 模板5.1 list 初始化\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid printList(list&lt;int&gt;&amp; lst)\n&#123;\n    //迭代器\n    //没有重载“&lt;”运算符\n    for (list&lt;int&gt;::iterator it = lst.begin(); it != lst.end(); it++)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n&#125;\n//基本操作\n/*\nvoid main()\n&#123;\n    list&lt;int&gt; lst;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        //尾部插入元素\n        lst.push_back(i);\n    &#125;\n\n    //头部插入元素\n    lst.push_front(80);\n    lst.push_front(90);\n\n    list&lt;int&gt;::iterator it = lst.begin();\n    it++;\n    cout &lt;&lt; *it &lt;&lt; endl;\n    //it = it + 3; 注意：不支持随机访问        \n\n    printList(lst);\n\n    system(&quot;pause&quot;);\n&#125;5.2 list 插入\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n    list&lt;int&gt; lst;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        //尾部插入元素\n        lst.push_back(i);\n    &#125;\n\n    list&lt;int&gt;::iterator it = lst.begin();\n    it++;\n    lst.insert(it, 100);\n\n    printList(lst);\n    system(&quot;pause&quot;);\n&#125;5.3 list 初始化\n#include &lt;iostream&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n\nvoid main()\n&#123;\n    list&lt;int&gt; lst;\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        //尾部插入元素\n        lst.push_back(i);\n    &#125;\n\n    list&lt;int&gt;::iterator it = lst.begin();\n    //删除\n    it++;\n    //删除第二个元素\n    //lst.erase(it);\n\n    //删除区间（已经被删除了元素不能再删除）\n    list&lt;int&gt;::iterator it_begin = lst.begin();\n    list&lt;int&gt;::iterator it_end = lst.begin();\n    it_end++;\n    it_end++;\n    it_end++;\n    lst.erase(it_begin, it_end);\n\n    //直接根据内容删除元素\n    lst.remove(5);\n\n    printList(lst);\n\n    system(&quot;pause&quot;);\n&#125;6、set 模板6.1 set 初始化#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\n//set 元素唯一 默认从小到大\nvoid printSet(set&lt;int&gt; &amp;s)\n&#123;\n    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid main()\n&#123;\n    set&lt;int&gt; s;\n    //添加元素\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        s.insert(i+1);\n    &#125;\n    s.insert(20);\n    s.insert(15);\n    s.insert(15);\n\n    //删除\n    set&lt;int&gt;::iterator it = s.begin();\n    it++;\n    s.erase(it);    \n\n    printSet(s);\n    system(&quot;pause&quot;);\n&#125;6.2 set 元素按照从大到小排列#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;functional&gt;\nusing namespace std;\n\nvoid main()\n&#123;\n    //同Java中：Map&lt;String,List&lt;String&gt;&gt; \n    set&lt;int,greater&lt;int&gt;&gt; s;\n    s.insert(10);\n    s.insert(5);\n    s.insert(20);\n    s.insert(99);\n\n    for (set&lt;int,greater&lt;int&gt;&gt;::iterator it = s.begin(); it != s.end(); it++)\n    &#123;\n        cout &lt;&lt; *it &lt;&lt; endl;\n    &#125;\n\n    system(&quot;pause&quot;);\n&#125;6.3 set 自定义排序规则#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;functional&gt;\nusing namespace std;\n\n//元素类型为Teacher对象，按照年龄排序\n\nclass Teacher\n&#123;\npublic:\n    Teacher(char* name, int age)\n    &#123;\n        this-&gt;name = name;\n        this-&gt;age = age;\n    &#125;\n\n    void print()\n    &#123;\n        cout &lt;&lt; name &lt;&lt; &quot;,&quot; &lt;&lt; age &lt;&lt; endl;\n    &#125;\n\npublic:\n    char* name;\n    int age;\n&#125;;\n\n//自定义排序规则\n//仿函数\nstruct MyAgeSorter\n&#123;\n    bool operator()(const Teacher &amp;left, const Teacher &amp;right)\n    &#123;\n        return left.age &lt; right.age;\n    &#125;\n&#125;;\n\nvoid main()\n&#123;\n    set&lt;Teacher, MyAgeSorter&gt; s;\n    s.insert(Teacher(const_cast&lt;char*&gt;(&quot;jack&quot;),18));\n    s.insert(Teacher(const_cast&lt;char*&gt;(&quot;rose&quot;), 20));\n    s.insert(Teacher(const_cast&lt;char*&gt;(&quot;jason&quot;), 22));\n    s.insert(Teacher(const_cast&lt;char*&gt;(&quot;alan&quot;), 5));\n    //s.insert(Teacher(&quot;jimy&quot;, 5)); //不会插入\n\n    for (set&lt;Teacher&gt;::iterator it = s.begin(); it != s.end(); it++)\n    &#123;\n        cout &lt;&lt; (*it).name &lt;&lt; &quot;,&quot; &lt;&lt; (*it).age &lt;&lt; endl;\n    &#125;\n\n    system(&quot;pause&quot;);\n&#125;6.3 set 查找#include &lt;iostream&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nvoid main()\n&#123;\n    set&lt;int&gt; s;\n    //添加元素\n    for (int i = 0; i &lt; 10; i++)\n    &#123;\n        s.insert(i + 1);\n    &#125;\n\n    //printSet(s);\n\n    //等于4的元素指针\n    set&lt;int&gt;::iterator s_4 = s.lower_bound(4); \n    //cout &lt;&lt; *s_4 &lt;&lt; endl;\n    //大于4的元素指针\n    set&lt;int&gt;::iterator s_5 = s.upper_bound(4);\n    //cout &lt;&lt; *s_5 &lt;&lt; endl;\n\n    //一次性获取等于4的元素指针，和大于4的元素指针\\\n    //BasicNameValuePair\n    pair&lt;set&lt;int&gt;::iterator, set&lt;int&gt;::iterator&gt; p = s.equal_range(4);\n    cout &lt;&lt; *p.first &lt;&lt; endl;\n    cout &lt;&lt; *p.second &lt;&lt; endl;\n    system(&quot;pause&quot;);\n&#125;\n6.4 multiset 允许重复的元素#include &lt;iostream&gt;\n#include &lt;set&gt;\nusing namespace std;\nvoid main()\n&#123;\n    multiset&lt;int&gt; s;\n    s.insert(2);\n    s.insert(8);\n    s.insert(2);\n    s.insert(8);\n\n    for (multiset&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\n    &#123;\n        cout &lt;&lt;  *it &lt;&lt; endl;\n    &#125;\n\n    system(&quot;pause&quot;);\n&#125;7、map 模板7.1 map 初始化#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nvoid main()\n&#123;\n    //key -&gt; value\n    //1.\n    map&lt;int, string&gt; map1;\n    map1.insert(pair&lt;int, string&gt;(1, &quot;jack&quot;));\n    map1.insert(pair&lt;int, string&gt;(2, &quot;rose&quot;));\n\n    //2\n    map1.insert(make_pair(3, &quot;jason&quot;));\n\n    //3\n    map1.insert(map&lt;int, string&gt;::value_type(4, &quot;alan&quot;));\n\n    //4\n    map1[5] = &quot;jimmy&quot;; //map[&quot;NO1&quot;] = 90;\n\n    //前三种方式，如果key已经存在，重复添加会报错\n    //第四种方式，如果key已经存在，重复添加会覆盖\n\n    //遍历输出\n    for (map&lt;int, string&gt;::iterator it = map1.begin(); it != map1.end(); it++)\n    &#123;\n        cout &lt;&lt; it-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n\n\n    system(&quot;pause&quot;);\n&#125;7.2 map 删除元素的方式#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nvoid printMap(map&lt;int, string&gt; &amp;map1)\n&#123;\n    for (map&lt;int, string&gt;::iterator it = map1.begin(); it != map1.end(); it++)\n    &#123;\n        cout &lt;&lt; it-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid main()\n&#123;\n    map&lt;int, string&gt; map1;\n    map1.insert(pair&lt;int, string&gt;(1, &quot;jack&quot;));\n    map1.insert(pair&lt;int, string&gt;(2, &quot;rose&quot;));\n    map1.insert(pair&lt;int, string&gt;(3, &quot;jason&quot;));    \n\n    map&lt;int, string&gt;::iterator it = map1.begin();\n    it++;\n    map1.erase(it);\n\n    printMap(map1);\n\n    system(&quot;pause&quot;);\n&#125;7.3 map 添加元素的结果#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nvoid main()\n&#123;\n    map&lt;int, string&gt; map1;\n    map1.insert(pair&lt;int, string&gt;(1, &quot;jack&quot;));\n    map1.insert(pair&lt;int, string&gt;(2, &quot;rose&quot;));\n    map1.insert(pair&lt;int, string&gt;(3, &quot;jason&quot;));\n    //获取添加的结果（first元素指针，second 是否成功）\n    pair&lt;map&lt;int, string&gt;::iterator, bool&gt; res = map1.insert(pair&lt;int, string&gt;(3, &quot;alan&quot;));\n    if (res.second)\n    &#123;\n        cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &lt;&lt; &quot;添加失败&quot; &lt;&lt; endl;\n    &#125;\n\n    printMap(map1);\n\n    system(&quot;pause&quot;);\n&#125;7.3 map 查找#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nvoid main()\n&#123;\n    map&lt;int, string&gt; map1;\n    map1.insert(pair&lt;int, string&gt;(1, &quot;jack&quot;));\n    map1.insert(pair&lt;int, string&gt;(2, &quot;rose&quot;));\n    map1.insert(pair&lt;int, string&gt;(3, &quot;jason&quot;));    \n\n    printMap(map1);\n\n    cout &lt;&lt; &quot;---------&quot; &lt;&lt; endl;\n\n    //获取key等于大于5的元素的值\n    pair&lt;map&lt;int, string&gt;::iterator, map&lt;int, string&gt;::iterator&gt; p = map1.equal_range(2);\n    if (p.first != map1.end())&#123;\n        //等于2的元素key value\n        cout &lt;&lt; p.first-&gt;first &lt;&lt; p.first-&gt;second &lt;&lt; endl;\n\n        //大于2的元素key value\n        cout &lt;&lt; p.second-&gt;first &lt;&lt; p.second-&gt;second &lt;&lt; endl;\n    &#125;\n\n    system(&quot;pause&quot;);\n&#125;7.3 multimap#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\nusing namespace std;\n\n//一个key对应多个value\n//一个部门多个员工\n//multimap\n\nclass Employee\n&#123;\npublic:\n    Employee(char* name,int age)\n    &#123;\n        this-&gt;name = name;\n        this-&gt;age = age;\n    &#125;\n\npublic:\n    char* name;\n    int age;\n&#125;;\n\nvoid main()\n&#123;\n    multimap&lt;string, Employee&gt; map1;\n\n    //开发部\n    map1.insert(make_pair(&quot;开发&quot;, Employee(const_cast&lt;char*&gt;(&quot;搁浅&quot;), 20)));\n    map1.insert(make_pair(&quot;开发&quot;, Employee(const_cast&lt;char*&gt;(&quot;彪哥&quot;), 20)));\n\n    //财务\n    map1.insert(make_pair(&quot;财务&quot;, Employee(const_cast&lt;char*&gt;(&quot;小颖&quot;), 16)));\n    map1.insert(make_pair(&quot;财务&quot;, Employee(const_cast&lt;char*&gt;(&quot;rose&quot;), 20)));\n\n    //销售\n    map1.insert(make_pair(&quot;销售&quot;, Employee(const_cast&lt;char*&gt;(&quot;阿呆&quot;), 30)));\n    map1.insert(make_pair(&quot;销售&quot;, Employee(const_cast&lt;char*&gt;(&quot;呵呵&quot;), 30)));\n\n    //遍历输出\n    for (multimap&lt;string, Employee&gt;::iterator it = map1.begin(); it != map1.end(); it++)\n    &#123;\n        cout &lt;&lt; it-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; it-&gt;second.name  &lt;&lt; &quot;,&quot; &lt;&lt; it-&gt;second.age &lt;&lt; endl;\n    &#125;\n\n    cout &lt;&lt; &quot;----------------&quot; &lt;&lt; endl;\n    //只获取“财务”部的员工\n    //获取“财务部”员工的个数，key对应的value的个数\n    int num = map1.count(&quot;财务&quot;);\n    multimap&lt;string, Employee&gt;::iterator it = map1.find(&quot;财务&quot;);\n    int c = 0; //控制循环的次数\n    while (it != map1.end() &amp;&amp; c &lt; num)\n    &#123;\n        cout &lt;&lt; it-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; it-&gt;second.name &lt;&lt; &quot;,&quot; &lt;&lt; it-&gt;second.age &lt;&lt; endl;\n        it++;\n        c++;\n    &#125;\n\n    system(&quot;pause&quot;);\n&#125;8、深拷贝与浅拷贝#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Employee\n&#123;\npublic:\n    //构造函数\n    Employee(char* name, int age)\n    &#123;\n        this-&gt;name = new char[strlen(name) + 1];\n        strcpy(this-&gt;name, name);\n        this-&gt;age = age;\n    &#125;\n\n    //析构函数\n    ~Employee()\n    &#123;\n        if (this-&gt;name != NULL)\n        &#123;\n            delete[] this-&gt;name;\n            this-&gt;name = NULL;\n            this-&gt;age = 0;\n        &#125;\n    &#125;\n    //拷贝构造函数\n    //Employee e = \n    Employee(const Employee &amp;obj)\n    &#123;\n        this-&gt;name = new char[strlen(obj.name) + 1];\n        strcpy(this-&gt;name, obj.name);\n        this-&gt;age = obj.age;\n    &#125;\n\n    //重载=\n    //e1 = e2;\n    Employee&amp; operator=(const Employee &amp;obj)\n    &#123;\n        //释放旧的内存\n        if (this-&gt;name != NULL)\n        &#123;\n            delete[] this-&gt;name;\n            this-&gt;name = NULL;\n            this-&gt;age = 0;\n        &#125;\n\n        //重新分配\n        this-&gt;name = new char[strlen(obj.name) + 1];\n        strcpy(this-&gt;name, obj.name);\n        this-&gt;age = obj.age;\n\n        return *this;\n    &#125;\n\npublic:\n    char* name;\n    int age;\n&#125;;\n\nvoid func()\n&#123;\n    vector&lt;Employee&gt; v1;\n    Employee e1(const_cast&lt;char*&gt;(&quot;jack&quot;), 20);\n    v1.push_back(e1);\n&#125;\n\nvoid main()\n&#123;\n    //vector&lt;Employee&gt; v1;\n    //Employee e1(&quot;jack&quot;,20);\n    //将e1拷贝到vector中\n    //v1.push_back(e1);\n\n    func();\n\n    system(&quot;pause&quot;);\n&#125;","categories":["CPlusPlus"],"tags":["CPlusPlus"]},{"title":"（五）C++中的异常处理与模板类","url":"https://blog.onestravel.cn/20181103/e3b43d9662e7/","content":"C++中的异常处理与模板类一、C++ 中的异常处理1、异常处理在C++ 中可以抛出任何类型的异常，根据抛出的异常数据类型，进入到相应的 catch块中 ，未知类型可用 … 代替\nvoid main() &#123;\n    try &#123;\n        int a = 300;\n        if (a &gt; 200) &#123;\n            throw - 1;\n        &#125;\n    &#125;\n    catch (int a) &#123;\n        cout &lt;&lt; a &lt;&lt; endl;\n    &#125;\n    try &#123;\n        int b = 0;\n        if (b == 0) &#123;\n            throw &quot;不能为0&quot;;\n        &#125;\n    &#125;\n    catch (const char* b) &#123;\n        cout &lt;&lt; b &lt;&lt; endl;\n    &#125;\n\n    try &#123;\n        int c = -1;\n        if (c &lt; 0 ) &#123;\n            throw 0.1;\n        &#125;\n    &#125;\n    catch (...) &#123;\n        cout &lt;&lt; &quot;未知异常&quot; &lt;&lt; endl;\n    &#125;\n    getchar();\n&#125;\n2、throw 抛出函数外float div2(float a, float b) &#123;\n    if (b == 0) &#123;\n        throw &quot;除数为零&quot;;\n    &#125;\n    return a / b;\n&#125;\n\nvoid main() &#123;\n    try &#123;\n        float c = div2(8, 0);\n    &#125;\n    catch (const char* e) &#123;\n        cout &lt;&lt; e &lt;&lt; endl;\n    &#125;\n\n    getchar();\n&#125;3、抛出异常对象抛出异常对象可以使用异常对象来捕获异常或者使用异常对象的引用来捕获异常,采用引用方式不会产生副本（可实现拷贝构造函数来验证）；尽量不要抛出异常指针（new 动态内存），需要delete动态内存\n//异常类\nclass MyException &#123;\npublic:\n    MyException() &#123;\n\n    &#125;\n&#125;;\n\nfloat div2(float a, float b) &#123;\n    if (b == 0) &#123;\n        //抛出对象\n        throw MyException();\n        //抛出异常指针\n        throw new MyException;\n    &#125;\n    return a / b;\n&#125;\n\nvoid main() &#123;\n    try &#123;\n        float c = div2(8, 0);\n    &#125;\n    //catch (MyException e) &#123;//对象，被拷贝了对象，产生对象副本\n    //    cout &lt;&lt; &quot;MyException&quot; &lt;&lt; endl;\n    //&#125;\n    catch (MyException &amp;e1) &#123;//对象的引用，效率更高\n        cout &lt;&lt; &quot;MyException引用&quot; &lt;&lt; endl;\n    &#125;\n    //catch (MyException* e2) &#123;//异常指针，需要delete\n    //    cout &lt;&lt; &quot;MyException指针&quot; &lt;&lt; endl;\n    //    delete e2;\n    //&#125;\n\n\n    getchar();\n&#125;4、声明抛出异常的类型throw 加载函数名称上，表示声明函数会抛出的异常类型\nfloat div2(float a, float b) throw(char*,int) &#123;\n    if (b == 0) &#123;\n        throw &quot;除数为零&quot;;\n    &#125;\n    return a / b;\n&#125;\n\nvoid main() &#123;\n    try &#123;\n        float c = div2(8, 0);\n    &#125;\n    catch (const char* e) &#123;\n        cout &lt;&lt; e &lt;&lt; endl;\n    &#125;\n    getchar();\n&#125;5、标准异常(类似于Java NullPointerException)需要引入 \n#define &lt;stdexcept&gt; \nclass NullPointerException : public exception&#123;\npublic:\n    NullPointerException(char* msg) : exception(msg)&#123;\n\n    &#125;\n&#125;;\n\nfloat div2(float a, float b) throw(char*,int) &#123;\n    if(b == NULL)&#123;\n        throw NullPointerException(&quot;is NULL&quot;);\n    &#125; else if (b &gt; 10000) &#123;\n        throw out_of_range(&quot;超出范围&quot;);\n    &#125;else if(b == 0)&#123;\n        throw invalid_argument(&quot;参数不合法&quot;);\n    &#125;\n    return a / b;\n&#125;\n\nvoid main() &#123;\n    try &#123;\n        float c = div2(8, 0);\n    &#125;\n    catch (out_of_range e) &#123;\n        cout &lt;&lt; e.what() &lt;&lt; endl;\n    &#125;\n    catch (NullPointerException&amp; e1) &#123;\n        cout &lt;&lt; e1.what() &lt;&lt; endl;\n    &#125;\n    catch (...) &#123;\n        cout &lt;&lt; &quot;未知异常&quot; &lt;&lt; endl;\n    &#125;\n    getchar();\n&#125;二、模板类属性或者构造函数中存在泛型参数的类叫模板类\n1、模板类示例template&lt;class T&gt;\nclass A&#123;\npublic:\n    A(T a)&#123;\n        this-&gt;a = a;\n    &#125;\nprotected:\n    T a;\n&#125;;\n2、普通类继承模板类class B : public A&lt;int&gt;&#123;\npublic:\n    B(int a,int b) : A&lt;int&gt;(a)&#123;\n        this-&gt;b = b;\n    &#125; \nprivate:\n    int b;\n&#125;3、模板类继承模板类template&lt;class T&gt;\nclass C : public A&lt;T&gt;&#123;\npublic:\n    C(T a,T c) : A&lt;T&gt;(a)&#123;\n        this-&gt;c = c;\n    &#125; \nprotected:\n    T c;\n&#125;4、模板类对象实例化void main()&#123;\n    //实例化模板类对象\n    A&lt;int&gt;(6);\n    getchar();\n&#125;","categories":["CPlusPlus"],"tags":["CPlusPlus"]},{"title":"（四）C++中的继承、多态和模板函数","url":"https://blog.onestravel.cn/20181025/85a4f7875086/","content":"C++中的继承、多态和模板函数一、继承1、属性和方法的继承继承可以更好的实现代码的重用性\n#include &lt;stdlib.h&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n//开发者\nclass Developer &#123;\nprotected:\n    char* language;\n    char* ide;\n    int age;\npublic:\n    void say() &#123;\n        cout &lt;&lt; &quot;我是开发者&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n//Android开发者\nclass AndroidDeveloper : public Developer &#123;\npublic:\n    AndroidDeveloper() &#123;\n        this-&gt;language = (char*)&quot;Android+Kotlin&quot;;\n        this-&gt;ide = (char*)&quot;Android Stuio&quot;;\n    &#125;\n    //开发Android Application\n    void createAndroidApp() &#123;\n        cout &lt;&lt; &quot;我使用&quot; &lt;&lt; this-&gt;ide &lt;&lt; &quot;开发了一款Android应用,使用了&quot; &lt;&lt; this-&gt;language &lt;&lt; &quot;语言&quot; &lt;&lt; endl;\n    &#125;\nprivate:\n    //Android 版本\n    char* androidVersion;\n\n&#125;;\n\n//所有开发者都有开发工作\nvoid work(Developer&amp; d) &#123;\n    d.say();\n&#125;\n\nvoid main() &#123;\n    AndroidDeveloper androidDev;\n    androidDev.say();\n    androidDev.createAndroidApp();\n    //子类对象初始化父类类型的对象\n    Developer d1 = androidDev;\n    work(d1);\n    //父类类型的指针\n    Developer* d_p = &amp;androidDev;\n    d_p-&gt;say();\n    //父类类型的引用\n    Developer d2 = androidDev;\n    d2.say();\n\n    getchar();\n&#125;2、通过子类给父类构造方法传参父类的构造函数先调用；子类的析构函数先调用\n//开发者\nclass Developer &#123;\nprotected:\n    char* language;\n    char* ide;\n    int age;\npublic:\n    Developer(char * language, char* ide, int age) &#123;\n        this-&gt;language = language;\n        this-&gt;ide = ide;\n        this-&gt;age = age;\n        cout &lt;&lt; &quot;Developer 构造函数&quot; &lt;&lt; endl;\n    &#125;\n    ~Developer() &#123;\n        cout &lt;&lt; &quot;Developer 析构函数&quot; &lt;&lt; endl;\n    &#125;\n    void say() &#123;\n        cout &lt;&lt; &quot;我是开发者&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\n//Android开发者\nclass AndroidDeveloper : public Developer &#123;\npublic:\n    AndroidDeveloper(char* language, char* ide, int age, char* androidVersion) : Developer(language, ide, age) &#123;\n        this-&gt;language = language;\n        this-&gt;ide = ide;\n        this-&gt;age = age;\n        cout &lt;&lt; &quot;AndroidDeveloper 构造函数&quot; &lt;&lt; endl;\n    &#125;\n    ~AndroidDeveloper()&#123;\n        cout &lt;&lt; &quot;AndroidDeveloper 析构函数&quot; &lt;&lt; endl;\n    &#125;\n    //开发Android Application\n    void createAndroidApp() &#123;\n        cout &lt;&lt; &quot;我使用&quot; &lt;&lt; this-&gt;ide &lt;&lt; &quot;开发了一款Android应用,使用了&quot; &lt;&lt; this-&gt;language &lt;&lt; &quot;语言&quot; &lt;&lt; endl;\n    &#125;\nprivate:\n    //Android 版本\n    char* androidVersion;\n\n&#125;;\n\nvoid work(Developer&amp; d) &#123;\n    d.say();\n&#125;\n\n//父类的构造函数先调用\n//子类的析构函数先调用\nvoid func() &#123;\n    AndroidDeveloper androidDev((char*)&quot;Kotlin&quot;, (char*)&quot;Android Studio&quot;, 5, (char*)&quot;5.0.1&quot;);\n    androidDev.say();\n    androidDev.createAndroidApp();\n&#125;\n\nvoid main() &#123;\n    func();\n    getchar();\n&#125;输出：\nDeveloper 构造函数\nAndroidDeveloper 构造函数\n我是开发者\n我使用Android Studio开发了一款Android应用,使用了Kotlin语言\nAndroidDeveloper 析构函数\nDeveloper 析构函数3、继承中父类和子类的权限继承关系\n\n\n基类中\n继承方式\n子类中\n\n\n\npublic\n＆ public继承\n=&gt; public\n\n\npublic\n＆ protected继承\n=&gt; protected\n\n\npublic\n＆ private继承\n=&gt; private\n\n\nprotected\n＆ public继承\n=&gt; protected\n\n\nprotected\n＆ protected继承\n=&gt; protected\n\n\nprotected\n＆ private继承\n=&gt; private\n\n\nprivate\n＆ public继承\n=&gt; 子类无权访问\n\n\nprivate\n＆ protected继承\n=&gt; 子类无权访问\n\n\nprivate\n＆ private继承\n=&gt; 子类无权访问\n\n\n4、继承的二义性4.1 继承的二义性定义在某个类B同时继承另一个类A的两个或多个子类时(A1和A2)，通过类B访问类A的成员时，会出现成员不明确的情况，即继承的二义性\nclass A &#123;\npublic:\n    char* name;\n&#125;;\n\nclass A1 : public A &#123;\n\n&#125;;\n\nclass A2 : public A &#123;\n\n&#125;;\n\nclass B : public A1, public A2 &#123;\n\n&#125;;\n\nvoid main() &#123;\n    B b;\n    //报错，提示B::name不明确\n    //b.name = (char*)&quot;Jack&quot;;\n\n    //指定父类显式调用\n    b.A1::name = (char*)&quot;Rose&quot;;\n    getchar();\n&#125;4.2 继承的二义性定义解决方案再遇到继承的二义性时，可使用虚继承来解决继承的二义性问题虚继承：不同路径继承来的同名成员只有一份拷贝\nclass A &#123;\npublic:\n    char* name;\n&#125;;\n\nclass A1 : virtual public A &#123;\n\n&#125;;\n\nclass A2 : virtual public A &#123;\n\n&#125;;\n\nclass B : public A1, public A2 &#123;\n\n&#125;;\n\nvoid main() &#123;\n    B b;\n    //报错，提示B::name不明确\n    //b.name = (char*)&quot;Jack&quot;;\n\n    //指定父类显式调用\n    b.A1::name = (char*)&quot;Rose&quot;;\n    getchar();\n&#125;二、多态\n多态是为了提高程序的扩展性\n动态多态：子类重写父类的函数，程序运行过程中，决定哪一个函数被调用\n静态多态：就是函数重载\n\n1、虚函数virtual 关键字修饰的函数叫虚函数，用来实现多态\n例如：\nPlane.h\n#pragma once\n\nclass Plane &#123;\npublic:\n    virtual void fly();\n    virtual void land();\n&#125;;\nPlane.cpp\n#include &quot;Plane.h&quot;\n#include &lt;stdlib.h&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\nvoid Plane::fly() &#123;\n    cout &lt;&lt; &quot;飞机起飞&quot; &lt;&lt; endl;\n&#125;\n\nvoid Plane::land() &#123;\n    cout &lt;&lt; &quot;飞机降落&quot; &lt;&lt; endl;\n&#125;Helicopter.h\n#pragma once\n#include &quot;Plane.h&quot;\n\nclass Helicopter : public Plane &#123;\npublic:\n    virtual void fly();\n    virtual void land();\n&#125;;\nHelicopter.cpp\n#include &quot;Helicopter.h&quot;\n#include &lt;stdlib.h&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\nvoid Helicopter::fly() &#123;\n    cout &lt;&lt; &quot;直升飞机在原地起飞&quot; &lt;&lt; endl;\n&#125;\n\nvoid Helicopter::land() &#123;\n    cout &lt;&lt; &quot;直升飞机降落在屋顶&quot; &lt;&lt; endl;\n&#125;\nTest.cpp\n#include &lt;stdlib.h&gt;\n#include &lt;iostream&gt;\n#include &quot;Plane.h&quot;\n#include &quot;Helicopter.h&quot;\nusing namespace std;\n\n//业务函数\n\nvoid runPlane(Plane &amp;p) &#123;\n    p.fly();\n    p.land();\n&#125;\n\nvoid main() &#123;\n    Plane p;\n\n    runPlane(p);\n    Helicopter h;\n    //在 Plane.h 和 Helicopter.h 中的函数上不使用 virtual 修饰时，打印“飞机起飞”和“飞机降落”\n    //使用 virtual 修饰时，打印“直升飞机在原地起飞”和“直升飞机降落在屋顶”，实现多态\n    runPlane(h);\n    getchar();\n&#125;\n2、发生动态多态的条件\n使用继承\n父类的引用或指针指向子类的对象\n函数的重写\n\n3、纯虚函数（抽象类）\n当一个类具有一个纯虚函数时，这个类就是抽象类\n抽象类不能被实例化\n子类继承抽象类，必须要实现纯虚函数，如果没有重新，子类也是抽象类\n\n//形状\nclass Shape &#123;\npublic:\n    virtual void sayArea() = 0;\n&#125;;\n\n//圆\nclass Circle : public Shape &#123;\nprivate:\n    int r;\npublic:\n    Circle(int r) &#123;\n        this-&gt;r = r;\n    &#125;\n    void sayArea() &#123;\n        cout &lt;&lt; &quot;圆的面积：&quot; &lt;&lt; 3.14 * r * r &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid main() &#123;\n    Circle c(5);\n    c.sayArea();\n    getchar();\n&#125;4、接口接口只是逻辑上的划分，语法上跟抽象类的写法没有区别\n//可以看作一个接口\nclass Drawable&#123;\n    virtual void draw() = 0;\n&#125;5、抽象类的作用为了继承约束，子类必须按照约束实现\n//可以看作一个接口\nclass Drawable&#123;\n    virtual void draw() = 0;\n&#125;二、模板函数（泛型）函数模板类似于泛型，用于在业务相同，参数类型不同时进行声明，在使用过程中，根据实际类型进行推导\ntemplate &lt;typename T,typename Z&gt;\n//交换两个变量的值\nvoid swap(T&amp; a, Z&amp; b)&#123;\n    T tmp = 0;\n    tmp = a;\n    a = b;\n    b = tmp;\n&#125;\n\nvoid main()&#123;\n    int a = 10;\n    int b = 25;\n    swap(a,b);\n    cout &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; endl;\n\n    char* x = (char*)&quot;abc&quot;;\n    char* y = (char*)&quot;def&quot;;\n    swap(x,y);\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl;\n\n    getchar();\n&#125;","categories":["CPlusPlus"],"tags":["CPlusPlus"]},{"title":"（三）C++中的静态成员与this指针","url":"https://blog.onestravel.cn/20181020/8b32f14109ac/","content":"C++中的静态成员与this指针一、静态成员1、static 关键字\n静态属性只能在全局范围内进行初始化赋值\n静态方法可以直接通过类名进行访问，也可以通过对象名进行访问\n\nclass Teacher &#123;\nprivate:\n    char* name;\npublic:\n    //计数器\n    static int total;\npublic:\n    Teacher(char* name) &#123;\n        this-&gt;name = name;\n        cout &lt;&lt; &quot;Teacher有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n    ~Teacher() &#123;\n        cout &lt;&lt; &quot;Teacher析构函数&quot; &lt;&lt; endl;\n    &#125;\n    void setName(char* name) &#123;\n        this-&gt;name = name;\n    &#125;\n    char* getName() &#123;\n        return this-&gt;name;\n    &#125;\n    //计数的静态函数\n    static void count()&#123;\n        total++;\n        cout &lt;&lt; &quot;total:&quot; &lt;&lt; total &lt;&lt; endl;\n    &#125;\n&#125;;\n\n//静态属性初始化赋值\nint Teacher::total = 10;\n\nvoid main() &#123;\n    Teacher::total++;\n    cout &lt;&lt; Teacher::total &lt;&lt; endl;\n    //直接通过类名访问\n    Teacher::count();\n    cout &lt;&lt; Teacher::total &lt;&lt; endl;\n    //通过对象名访问\n    Teacher t1((char*)&quot;JACK&quot;);\n    t1.count();\n    cout &lt;&lt; Teacher::total &lt;&lt; endl;\n    getchar();\n&#125;二、类的大小C/C++ 内存分区：栈、堆、全局（静态、全局）、常量区（字符串）、程序代码区普通属性与结构体具有相同的内存布局\nclass A &#123;\npublic:\n    int i;\n    int j;\n    int k;\n&#125;;\n\nclass B &#123;\npublic:\n    int i;\n    int j;\n    int k;\n    void myprint() &#123;\n        cout &lt;&lt; &quot;打印&quot; &lt;&lt; endl;\n    &#125;\n\n&#125;;\n\nvoid main() &#123;\n    cout &lt;&lt; sizeof(A) &lt;&lt; endl;\n    cout &lt;&lt; sizeof(B) &lt;&lt; endl;\n    getchar();\n&#125;\n三、this 指针1、this指针this 是当前对象的指针因为函数是共享的，所有使用this指针用来标识当前对象\nclass Teacher &#123;\nprivate:\n    char* name;\n    int age;\npublic:\n    Teacher(char* name,int age) &#123;\n        this-&gt;name = name;\n        this-&gt;age = age;\n        cout &lt;&lt; &quot;Teacher有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n    ~Teacher() &#123;\n        cout &lt;&lt; &quot;Teacher析构函数&quot; &lt;&lt; endl;\n    &#125;\n    void setName(char* name) &#123;\n        this-&gt;name = name;\n    &#125;\n    char* getName() &#123;\n        return this-&gt;name;\n    &#125;\n    void setAge(int age) &#123;\n        this-&gt;age = age;\n    &#125;\n    int getAge() &#123;\n        return this-&gt;age;\n    &#125;\n    void myprint() &#123;\n        cout &lt;&lt; this-&gt;getName() &lt;&lt; &quot;,&quot; &lt;&lt; this-&gt;getAge() &lt;&lt; endl;\n    &#125;\n&#125;;\n\n\nvoid main() &#123;\n    Teacher t1((char*)&quot;Jack&quot;, 20);\n    Teacher t2((char*)&quot;Rose&quot;, 18);\n    t1.myprint();\n    t2.myprint();\n    getchar();\n&#125;2、常函数（const修饰函数）常函数，修饰的是this；既不能改变指针的值，也不能改变指针指向的内容常量对象只能调用常量函数,不能调用非常量函数常函数当前对象不能被修改，防止数据成员被非法访问\nclass Teacher &#123;\nprivate:\n    char* name;\n    int age;\npublic:\n    Teacher(char* name,int age) &#123;\n        this-&gt;name = name;\n        this-&gt;age = age;\n        cout &lt;&lt; &quot;Teacher有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n    ~Teacher() &#123;\n        cout &lt;&lt; &quot;Teacher析构函数&quot; &lt;&lt; endl;\n    &#125;\n    void setName(char* name) &#123;\n        this-&gt;name = name;\n    &#125;\n    char* getName() &#123;\n        return this-&gt;name;\n    &#125;\n    void setAge(int age) &#123;\n        this-&gt;age = age;\n    &#125;\n    int getAge() &#123;\n        return this-&gt;age;\n    &#125;\n    void myprint() const &#123;\n        printf(&quot;%#x\\n&quot;,this);\n        //不能改变属性的值\n        //this-&gt;name = &quot;Jason&quot;;\n        //不能改变this指针的值\n        //this = (Teacher*)0x000090;\n        cout &lt;&lt; this-&gt;getName() &lt;&lt; &quot;,&quot; &lt;&lt; this-&gt;getAge() &lt;&lt; endl;\n    &#125;\n&#125;;四、友元函数与友元类1、友元函数在友元函数中可以访问私有的属性\nclass A &#123;\nprivate:\n    int i;\npublic:\n    A(int i) &#123;\n        this-&gt;i = i;\n    &#125;\n    void myprint() &#123;\n        cout &lt;&lt; i &lt;&lt; endl;\n    &#125;\n    //友元函数\n    friend void modify_i(A*p, int a);\n&#125;;\n\n//友元函数的实现,在友元函数中可以访问私有的属性\nvoid modify_i(A*p, int a) &#123;\n    p-&gt;i = a;\n&#125;\n\nvoid main() &#123;\n    A* a = new A(10);\n    a-&gt;myprint();\n    modify_i(a, 20);\n    a-&gt;myprint();\n    getchar();\n&#125;2、友元类友元类可以访问引用友元类的类的任何成员\nclass A &#123;\n    //友元类\n    friend class B;\nprivate:\n    int i;\npublic:\n    A(int i) &#123;\n        this-&gt;i = i;\n    &#125;\n    void myprint() &#123;\n        cout &lt;&lt; i &lt;&lt; endl;\n    &#125;\n    //友元函数\n    friend void modify_i(A*p, int a);\n&#125;;\n\n//友元函数的实现,在友元函数中可以访问私有的属性\nvoid modify_i(A*p, int a) &#123;\n    p-&gt;i = a;\n&#125;\n\nclass B &#123;\nprivate:\n    A a;\npublic:\n    B(int a_i):a(a_i) &#123;\n        this-&gt;a = a;\n    &#125;\n    //B这个友元类可以访问A类的任何成员\n    void accessAny() &#123;\n        a.i = 30;\n    &#125;\n    A getA() &#123;\n        return a;\n    &#125;\n&#125;;\n\nvoid main() &#123;\n    B* b = new B(10);\n    A a = b-&gt;getA();\n    a.myprint();\n    b-&gt;accessAny();\n    a = b-&gt;getA();\n    a.myprint();\n    getchar();\n&#125;五、运算符重载运算符的重载，本质上还是函数的调用\n1、单独进行运算符重载class Point &#123;\npublic:\n    int x;\n    int y;\npublic:\n    Point(int x = 0,int y = 0) &#123;\n        this-&gt;x = x;\n        this-&gt;y = y;\n    &#125;\n\n    void myprint() &#123;\n        cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl;\n    &#125;\n&#125;;\n//重载+号\nPoint operator+(Point &amp;p1, Point &amp;p2) &#123;\n    Point tmp(p1.x + p2.x, p1.y + p2.y);\n    return tmp;\n&#125;\n\n//重载-号\nPoint operator-(Point &amp;p1, Point &amp;p2) &#123;\n    Point tmp(p1.x - p2.x, p1.y - p2.y);\n    return tmp;\n&#125;\n\nvoid main() &#123;\n    Point p1(10,20);\n    Point p2(20,10);\n    Point p3 = p1 + p2;\n    p3.myprint();\n    getchar();\n&#125;2、类成员函数运算符重载class Point &#123;\npublic:\n    int x;\n    int y;\npublic:\n    Point(int x = 0, int y = 0) &#123;\n        this-&gt;x = x;\n        this-&gt;y = y;\n    &#125;\n\n    void myprint() &#123;\n        cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl;\n    &#125;\n    //成员函数运算符重载+号\n    Point operator+(Point &amp;p2) &#123;\n        Point tmp(this-&gt;x + p2.x, this-&gt;y + p2.y);\n        return tmp;\n    &#125;\n\n    //成员函数运算符重载-号\n    Point operator-(Point &amp;p2) &#123;\n        Point tmp(this-&gt;x - p2.x, this-&gt;y - p2.y);\n        return tmp;\n    &#125;\n&#125;;\n\n\nvoid main() &#123;\n    Point p1(10, 20);\n    Point p2(20, 10);\n    //p1.operator+(p1);\n    Point p3 = p1 + p2;\n    p3.myprint();\n    getchar();\n&#125;3、友元函数运算符重载当属性私有时，通过友元函数完成运算符重载\nclass Point &#123;\n    friend Point operator+(Point &amp;p1, Point &amp;p2);\n    friend Point operator-(Point &amp;p1, Point &amp;p2);\nprivate:\n    int x;\n    int y;\npublic:\n    Point(int x = 0, int y = 0) &#123;\n        this-&gt;x = x;\n        this-&gt;y = y;\n    &#125;\n\n    void myprint() &#123;\n        cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl;\n    &#125;\n\n&#125;;\n\n//友元函数运算符重载+号\nPoint operator+(Point &amp;p1, Point &amp;p2) &#123;\n    Point tmp(p1.x + p2.x, p1.y + p2.y);\n    return tmp;\n&#125;\n\n//友元函数运算符重载-号\nPoint operator-(Point &amp;p1, Point &amp;p2) &#123;\n    Point tmp(p1.x - p2.x, p1.y - p2.y);\n    return tmp;\n&#125;\n\nvoid main() &#123;\n    Point p1(10, 20);\n    Point p2(20, 10);\n    Point p3 = p1 + p2;\n    p3.myprint();\n    getchar();\n&#125;","categories":["CPlusPlus"],"tags":["CPlusPlus"]},{"title":"（二）C++中的类与构造函数","url":"https://blog.onestravel.cn/20181015/b2c71e88d40d/","content":"C++中的类与构造函数一、C++中类的常用写法1、在头文件中声明类的属性和方法如：MyTeacher.h\n//防止重复引入\n#pragma once\nclass MyTeacher&#123;\nprivate:\n    char* name;\n    int age;\npublic:\n    void setName(char* name);\n    char* getName();\n    void setAge(int age);\n    int getAge();\n&#125;;2、在源文件中（.cpp）实现对应的方法如：MyTeacher.cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include &quot;MyTeacher.h&quot;\n#include &lt;iostream&gt;\n\nvoid MyTeacher::setName(const char* name) &#123;\n    this-&gt;name = new char[100];\n    strcpy(this-&gt;name, name);\n&#125;\n\nchar* MyTeacher::getName() &#123;\n    return this-&gt;name;\n&#125;\n\nvoid MyTeacher::setAge(int age) &#123;\n    this-&gt;age = age;\n&#125;\n\nint MyTeacher::getAge() &#123;\n    return this-&gt;age;\n&#125;3、在具体C++代码中使用如：test.cpp\n#include &quot;MyTeacher.h&quot;\nusing namespace std;\n\nvoid main() &#123;\n    MyTeacher t;\n    t.setName(&quot;Jack&quot;);\n    t.setAge(25);\n    cout &lt;&lt; t.getName() &lt;&lt; &quot;,&quot; &lt;&lt; t.getAge() &lt;&lt; endl;\n    getchar();\n&#125;二、C++中类的构造函数、析构函数、拷贝构造函数1、构造函数\nC++类默认有无参构造函数，重写无参构造函数会覆盖默认的无参构造函数\n有参构造函数会覆盖默认无参构造函数\n\nclass Teacher&#123;\nprivate:\n    char* name;\n    int age;\npublic:\n    //无参构造函数\n    Teacher()&#123;\n        cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    //有参构造函数\n    Teacher(char *name,int age)&#123;\n        this-&gt;name = name;\n        this-&gt;age = age;\n        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid main()&#123;\n    Teacher t1;\n    Teacher t2(&quot;Rose&quot;,23);\n    //有参构造函数另一个调用方式\n    Teacher t3 = Teacher(&quot;jack&quot;,21);\n    getchar();\n&#125;\n2、析构函数 当对象要被系统释放时，析构函数会被调用，一般用作善后处理\nclass Teacher&#123;\nprivate:\n    char* name;\n    int age;\npublic:\n    //无参构造函数\n    Teacher()&#123;\n        this-&gt;name = (char*)malloc(100);\n        strcpy(name,&quot;Hello,Jack Teacher&quot;);\n        this-&gt;age = 25;\n        cout &lt;&lt; &quot;无参构造函数&quot; &lt;&lt; endl;\n    &#125;\n    //析构函数\n    ~Teacher()&#123;\n        cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;\n        free(this-&gt;name);\n    &#125;\n\n    //有参构造函数\n    Teacher(char *name,int age)&#123;\n        this-&gt;name = name;\n        this-&gt;age = age;\n        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid func()&#123;\n    Teacher t1;\n&#125;\n\nvoid main()&#123;\n    func();\n\n    getchar();\n&#125;\n3、拷贝构造函数3.1 浅拷贝\n默认拷贝构造函数，就是值拷贝（浅拷贝）\n浅拷贝拷贝的是指针的地址（同一块内存区域）\n\nusing namespace std;\nclass Teacher &#123;\nprivate:\n    char* name;\n    int age;\npublic:\n        //有参构造函数\n    Teacher(char *name, int age) &#123;\n        this-&gt;name = name;\n        this-&gt;age = age;\n        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n    //析构函数\n    ~Teacher() &#123;\n        cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;\n        free(this-&gt;name);\n    &#125;\n\n    //拷贝构造函数\n    Teacher(const Teacher &amp;obj) &#123;\n        this-&gt;name = obj.name;\n        this-&gt;age = obj.age;\n        cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    void myprint() &#123;\n        cout &lt;&lt; name &lt;&lt; &quot;,&quot; &lt;&lt; age &lt;&lt; endl;\n    &#125;\n&#125;;\n\n\nvoid main() &#123;\n    Teacher t1((char*)&quot;rose&quot;, 30);\n    Teacher t2 = t1;\n    t2.myprint();\n    getchar();\n&#125;输出\n有参构造函数\n拷贝构造函数\nrose,30\n浅拷贝有可能会出现第二次释放变量导致出现异常的情况\n\n例如：出现异常的情况\nusing namespace std;\nclass Teacher &#123;\nprivate:\n    char* name;\n    int age;\npublic:\n        //有参构造函数\n    Teacher(char *name, int age) &#123;\n        int len = strlen(obj.name);\n        this-&gt;name = (char*)malloc(len+1);\n        strcpy(this-&gt;name,name);\n        this-&gt;age = age;\n        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n    //析构函数\n    ~Teacher() &#123;\n        cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;\n        free(this-&gt;name);\n    &#125;\n\n\n\n    void myprint() &#123;\n        cout &lt;&lt; name &lt;&lt; &quot;,&quot; &lt;&lt; age &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid func()&#123;\n    Teacher t1((char*)&quot;rose&quot;, 30);\n    Teacher t2 = t1;\n    t2.myprint();\n&#125; \n\nvoid main() &#123;\n    func();\n    getchar();\n&#125;3.2 深拷贝深拷贝拷贝的是指针指向的数据内容（两块内存区域）\nusing namespace std;\nclass Teacher &#123;\nprivate:\n    char* name;\n    int age;\npublic:\n        //有参构造函数\n    Teacher(char *name, int age) &#123;\n        int len = strlen(obj.name);\n        this-&gt;name = (char*)malloc(len+1);\n        strcpy(this-&gt;name,name);\n        this-&gt;age = age;\n        cout &lt;&lt; &quot;有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n    //析构函数\n    ~Teacher() &#123;\n        cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;\n        free(this-&gt;name);\n    &#125;\n\n    //拷贝构造函数(深拷贝)\n    Teacher(const Teacher &amp;obj) &#123;\n        //复制name属性\n        int len = strlen(obj.name);\n        this-&gt;name = (char*)malloc(len+1);\n        strcpy(this-&gt;name,obj.name);\n        this-&gt;age = obj.age;\n        cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    void myprint() &#123;\n        cout &lt;&lt; name &lt;&lt; &quot;,&quot; &lt;&lt; age &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid func()&#123;\n    Teacher t1((char*)&quot;rose&quot;, 30);\n    //声明时会被调用\n    Teacher t2 = t1;\n    //下面这种方式不会被调用\n    //Teacher t1;\n    //Teacher t2;\n    //t1 = t2;\n    t2.myprint();\n&#125;\n\nvoid main() &#123;\n    func();\n    getchar();\n&#125;3.3 拷贝构造函数被被调用的场景\n声明时赋值\n作为参数传入，实参给形参赋值\n作为函数返回值返回，给变量初始化赋值\n\n4、构造函数属性初始化列表构造函数属性初始化列表的格式为:  \n[构造函数名称]([本类中属性列表],[第一个类对象的属性列表],[第二个类对象的属性列表]):[第一个类对象]([第一个类对象的属性列表]),[第二个类对象]([第二个类对象的属性列表])&#123;\n\n&#125;示例如下：\nclass Teacher&#123;\nprivate:\n    char* name;\npublic:\n    Teacher(char* name)&#123;\n        this-&gt;name = name;\n        cout &lt;&lt; &quot;Teacher有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n    ~Teacher()&#123;\n        cout &lt;&lt; &quot;Teacher析构函数&quot; &lt;&lt; endl;\n    &#125;\n    char* getName()&#123;\n        return this-&gt;name;\n    &#125;\n&#125;;\n\nclass Student&#123;\nprivate:\n    int id;\n    Teacher t1;\npublic:\n    Student(int id,char* t1_name) : t1(t1_name)&#123;\n        this-&gt;id = id;    \n        cout &lt;&lt; &quot;Student有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n    ~Student()&#123;\n        cout &lt;&lt; &quot;Student析构函数&quot; &lt;&lt; endl;\n    &#125;\n    void myprint()&#123;\n        cout &lt;&lt; this-&gt;id &lt;&lt; &quot;同学的老师是&quot; &lt;&lt; t1.getName() &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid func()&#123;\n    Student t1(16,(char*)&quot;Jack&quot;);\n    t1.myprint();\n&#125;\n\nvoid main()&#123;\n    func();\n\n    getchar();\n&#125;三、C++中的new 和 delete的使用C++中通过new和delete来进行动态内存分配,new 和delete成对出现C++中在使用new和delete会对应调用构造函数和析构参数，通过C中的malloc方式则不会调用构造函数和析构函数\nclass Teacher&#123;\nprivate:\n    char* name;\npublic:\n    Teacher(char* name)&#123;\n        this-&gt;name = name;\n        cout &lt;&lt; &quot;Teacher有参构造函数&quot; &lt;&lt; endl;\n    &#125;\n    ~Teacher()&#123;\n        cout &lt;&lt; &quot;Teacher析构函数&quot; &lt;&lt; endl;\n    &#125;\n    void setName(char* name)&#123;\n        this-&gt;name = name;\n    &#125;\n    char* getName()&#123;\n        return this-&gt;name;\n    &#125;\n&#125;;\n\nvoid func()&#123;\n    //初始化，返回指针地址\n    Teacher *t1 = new Teacher((char*)&quot;Jack&quot;);\n    //使用\n    //释放\n    delete t1;\n    int *p2 = new int[10];\n    p2[0] = 11;\n    //释放数组\n    delete p2;\n&#125;\n\nvoid main()&#123;\n    func();\n\n    getchar();\n&#125;\n","categories":["CPlusPlus"],"tags":["CPlusPlus"]},{"title":"（一）C++命名空间及引用","url":"https://blog.onestravel.cn/20180930/9823596bc207/","content":"C++命名空间及引用一、C 与 C++ 的关系\nC++ 可以与 C 代码进行混编\nC++ 是一个面向对象编程语言、C 语言是面向过程的编程语言\nC++ 是对 C 的一个增强\n\n二、C++ 命名空间\nC++ 标准的命名空间为 std ，包含很多标准的定义\n&lt;&lt; 为运算符重载\n命名空间类似于Java中的包\n命名空间可以先进行使用\n:: 为访问修饰符\n\n示例：\n#include &lt;stdlib.h&gt;\n#include &lt;iostream&gt;\n\n//使用标准命名空间\nusing namespace std;\n\n//自定义命名空间\nnamespace NSP_A&#123;\n    int a = 9;\n    struct Teacher&#123;\n        char name[20];\n        int age;\n    &#125;;\n    struct Student&#123;\n        char name[20];\n        int age;\n    &#125;;\n&#125;\n\nvoid main()&#123;\n    //std::cout &lt;&lt; &quot;this is c plus plus&quot; &lt;&lt; std::endl;\n    cout &lt;&lt; &quot;this is c plus plus&quot; &lt;&lt; endl;\n    cout &lt;&lt; &quot;访问自定义命名空间的属性a:&quot; &lt;&lt; NSP_A::a &lt;&lt; endl;\n\n    //使用命名空间中的结构体\n    using NSP_A::Student;\n    Student t;\n    t.age = 19;\n    cout &lt;&lt; &quot;学生的年龄为:&quot; &lt;&lt; t.age &lt;&lt; endl;\n    getchar();\n&#125;三、C++ 中的类C++ 中的类中的属性共享权限访问修饰符\n类的 } 后有分号;\nusing namespace std;\n#define PI 3.14\nclass MyCircle&#123;\n//属性\nprivate:\n    double r;\n    double s;\npublic:\n    double length;\npublic:\n    void setR(double r)&#123;\n        this-&gt;r = r;\n    &#125;\n    double getS()&#123;\n        return PI * r * r;\n    &#125;\n&#125;;\n\nvoid main()&#123;\n    MyCircle c1;\n    c1.setR(4);\n    cout &lt;&lt; &quot;圆的面积：&quot; &lt;&lt; c1.getS() &lt;&lt; endl;\n\n    getchar();\n&#125;输出：\n圆的面积：50.24四、C++ 中的结构体\nC++ 中的结构体中有权限访问修饰符\n\n结构体在C++ 中使用时可以省略 struct\n\n结构体不能被继承\n\n\nusing namespace std;\n\nstruct Teacher&#123;\n//属性\npublic:\n    char* name;\n    int age;\npublic:\n    void say()&#123;\n       cout &lt;&lt; &quot;My name is &quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;, I am &quot; &lt;&lt; this-&gt;age &lt;&lt; &quot; years old.&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nvoid main()&#123;\n    Teacher t1;\n    strcpy(t1.name, &quot;Jack&quot;);\n    t1.age = 25;\n    t1.say();\n    getchar();\n&#125;五、C++ 中的数据类型\nC++中有 bool 类型 ，大小为1字节\nC++中的三目运算可以成为左值，改变复合条件的属性的值\n\nusing namespace std;\nvoid main()&#123;\n    //bool isSingle = true;\n\n    bool isSingle = -1;\n\n    if(isSingle)&#123;\n        cout &lt;&lt; &quot;单身&quot; &lt;&lt; endl;\n    &#125;else&#123;\n        cout &lt;&lt; &quot;有对象&quot; &lt;&lt; endl;\n    &#125;\n\n    int a = 10, b = 20;\n    int c = (a &gt; b) ? a : b;\n    cout &lt;&lt; &quot;最大的数为&quot; &lt;&lt; ((a &gt; b) ? a : b) &lt;&lt; endl;\n\n    //三目运算可以成为左值\n    (a &gt; b) ? a : b = 30;\n     cout &lt;&lt; &quot;b 的值为&quot; &lt;&lt; b &lt;&lt; endl;\n    getchar();\n&#125;六、C++ 中的引用1、引用的定义\nC++ 中的引用就是在声明的变量名称前加&amp;符号,是为变量取别名，作为函数参数传递，能保证参数传递过程中不产生副本\n引用必须要有值，不能为NULL\n引用可以直接操作变量，指针要通过取值(*p),间接操作变量，指针的可读性差\n\nusing namespace std;\nvoid main()&#123;\n\n    int a = 10;\n    //b就是a的内存空间的另一个别名\n    int &amp;b = a;\n\n    cout &lt;&lt; b &lt;&lt; endl;\n    getchar();\n\n&#125;2、C++ 中的引用的作用\n在 C++ 代码中使用引用比使用指针写起来更加方便\n\nusing namespace std;\n\n//通过指针进行值交换\nvoid swap_1(int *a, int *b)&#123;\n    int c = 0;\n    c = *a;\n    *a = *b;\n    *b = c;\n&#125;\n\n//通过引用进行值交换\nvoid swap_2(int &amp;a, int &amp;b)&#123;\n    int c = 0;\n    c = a;\n    a = b;\n    b = c;\n&#125;\n\nvoid main()&#123;\n    int x = 30;\n    int y = 50;\n    swap_1(&amp;x, &amp;y);\n    cout &lt;&lt; &quot;指针交换：x的值为：&quot;&lt;&lt; x &lt;&lt; &quot;,y的值为&quot; &lt;&lt; y &lt;&lt; endl;\n\n    swap_2(x,y);\n    cout &lt;&lt; &quot;引用交换：x的值为：&quot;&lt;&lt; x &lt;&lt; &quot;,y的值为&quot; &lt;&lt; y &lt;&lt; endl;\n    getchar();\n\n&#125;3、C++中引用的主要功能\n在 C++ 中，引用的主要功能是作为函数的参数或返回值\n\nusing namespace std;\nstruct Teacher&#123;\n   const char* name;\n    int age\n&#125;;\nvoid myprint(Teacher &amp;t)&#123;\n    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; t.name &lt;&lt; &quot;,年龄：&quot; &lt;&lt; t.age &lt;&lt; endl;\n&#125;\n\nvoid main()&#123;\n    Teacher t;\n    t.name = &quot;jsaon&quot;;\n    t.age = 29;\n    myprint(t);\n    getchar();\n&#125;\n在 C++ 中，对指针的引用可以代替二级指针\n\nusing namespace std;\nstruct Teacher&#123;\n   const char* name;\n    int age\n&#125;;\nvoid getTeacher(Teacher **p)&#123;\n    Teacher *tmp = (Teacher*)malloc(sizeof(Teacher));\n    tmp-&gt;age = 20;\n    *p = tmp;\n&#125;\n\n//指针的引用，代替二级指针\nvoid getTeacher(Teacher* &amp;p)&#123;\n    p = (Teacher*)malloc(sizeof(Teacher));\n    p-&gt;age = 20;\n&#125;\n\nvoid main()&#123;\n    Teacher *t = NULL;\n    getTeacher(&amp;t);\n    getchar();\n&#125;4、指针常量和常量指针\n指针常量就是指针的常量，不改变地址的指针，但是可以修改它指向的内容\n\nvoid main()&#123;\n    int a = 2, b = 3;\n    int *const p1 = &amp;a;\n    //p1 = &amp;b; //失败的，不能改变地址\n    *p1 = 4; //可以改变a的值\n    getchar();\n&#125;\n\n常量指针就是指向常量的指针，不能修改内容，可以修改地址\n\nvoid main()&#123;\n    int a = 2, b = 3;\n    const int *p2 = &amp;a;\n    p1 = &amp;b; //可以改变地址\n    //*p2 = 9; //不可以改变a的值\n    getchar();\n&#125;\n5、常引用常引用类似于Java中的final，值不可修改\nvoid main()&#123;\n    int a = 10,b = 9;\n    const int &amp;c = a;\n    //c = b; //不能再次赋值\n\n    const int &amp;d = 66;\n&#125;七、C++ 中的函数1、函数参数的默认值\n在C++中，可以对函数的参数设置默认值\n有默认值的参数必须在无默认值参数的最后\n\nusing namespace std;\nint add(int x, int y = 13, int z = 20) &#123;\n    return (x + y + z);\n&#125;\nvoid main() &#123;\n    int x = 17;\n    int sum = add(10);\n    cout &lt;&lt; &quot;x+y+z=&quot; &lt;&lt; sum &lt;&lt; endl;\n    getchar();\n&#125;2、函数的可变参数\n在C++中，针对函数参数不确定的情况下，可使用可变参数\n\n#include &lt;stdarg.h&gt;\nusing namespace std;\nvoid func(int i,...)&#123;\n    //可变参数指针\n    va_list args_p;\n    //开始读取可变参数，i是最后一个固定参数\n    va_start(args_p,i);\n\n    int a = va_arg(args_p,int);\n    int b = va_arg(args_p,int);\n    char c = va_arg(args_p,char);\n    cout &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; b &lt;&lt; endl;\n    cout &lt;&lt; c &lt;&lt; endl;\n    //结束\n    va_end(args_p);\n&#125;\n\nvoid main() &#123;\n    func(9,10,32,&#39;C&#39;);\n    getchar();\n&#125;3、函数的可变参数(循环读取)\n在C++中，针对函数参数不确定的情况下，可使用可变参数\n**可变参数在循环遍历时，不能获取个数，只能通过约定来确定可变参数个数；如第一个值来表\n示可变参数个数**\n\n#include &lt;stdarg.h&gt;\nusing namespace std;\nvoid func(int count, ...) &#123;\n    //可变参数指针\n    va_list args_p;\n    //开始读取可变参数，i是最后一个固定参数\n    va_start(args_p, count);\n    char value;\n    int i = 0;\n    for (;i &lt; count; i++) &#123;\n        value = va_arg(args_p, char);\n        cout &lt;&lt; value &lt;&lt; endl;\n    &#125;\n    //结束\n    va_end(args_p);\n&#125;\n\nvoid main() &#123;\n    func(3, &#39;a&#39;, &#39;b&#39;, &#39;C&#39;);\n    getchar();\n&#125;","categories":["CPlusPlus"],"tags":["CPlusPlus"]},{"title":"JNI 引用、异常处理和缓存策略","url":"https://blog.onestravel.cn/20180925/e8fca33a94a3/","content":"JNI 引用、异常处理和缓存策略一、JNI 引用变量1、引用类型JNI 引用的类型分为局部引用和全局引用\n2、引用的作用在JNI中告知虚拟机何时回收一个 JNI 变量\n3、局部引用的使用通过DeleteLocalRef 手动释放\n\n访问一个很大的java对象，使用完成之后，还要进行复杂的耗时操作\n创建了大量的局部引用，占用了太多的内存，而且这些局部引用跟后面的操作没有关联性。\n\n例如：\n\n编写JNITest.java文件\n\npublic class JNITest &#123;\n\n    public native void localRef();\n\n    public static void main(String[] args)&#123;\n        JNITest t = new JNITest();\n        t.localRef();\n    &#125;\n\n\n    static &#123;\n        System.loadLibrary(&quot;JNIProject&quot;);\n    &#125;\n&#125;\n在com_example_jni_JNITest.h文件声明对应的方法；签名可通过下面的命令获取\n\njavap -s -p com.example.jni.JNITest产生的结果中有对应的属性和方法的签名\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include &quot;jni.h&quot;\n/* Header for class com_example_jni_JNITest */\n\n#ifndef _Included_com_example_jni_JNITest\n#define _Included_com_example_jni_JNITest\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n/*\n * Class:     com_example_jni_JNITest\n * Method:    localRef\n * Signature: \n */\nJNIEXPORT void JNICALL Java_com_example_jni_JNITest_localRef\n(JNIEnv *, jobject);\n#ifdef __cplusplus\n&#125;\n#endif\n#endif\n\n在JNITest.c文件实现com_example_jni_JNITest.h中声明的方法\n\n#include &quot;com_example_jni_JNITest.h&quot;\n#include &lt;stdlib.h&gt;\n\nint compare(int *a,int *b)&#123;\n    return (*a) - (*b);\n&#125;\n\n//模拟：循环创建数组 \nJNIEXPORT void JNICALL Java_com_example_jni_JNITest_localRef\n(JNIEnv *env, jobject jobj) &#123;\n    int i = 0;\n    for(; i &lt; 5; i++)&#123;\n        //创建Date对象\n        jclass cls = (*env)-&gt;FindClass(env,&quot;java.util.Date&quot;);\n        jmethodID constructor_mid = (*env)-&gt;GetMethodID(env,cls,&quot;&lt;init&gt;&quot;,&quot;()V&quot;);\n        jobject obj = (*env)-&gt;NewObject(env,cls,constructor_mid);\n        //此处省略100行代码\n        //不再使用obj对象了\n        //通知垃圾回收器回收这些对象\n        (*env)-&gt;DeleteLocalRef(env,obj);\n        //此处省略100行代码\n    &#125;\n&#125;\n4、全局引用的使用全局引用可以共享（跨多个方法，多个线程），手动控制内存使用（不再使用时通过 DeleteGlobalRef 手动释放）\n例如：\n\n编写JNITest.java文件\n\npublic class JNITest &#123;\n\n    public native void createGlobalRef();\n\n     public native String getGlobalRef();\n\n     public native void deleteGlobalRef();\n\n    public static void main(String[] args)&#123;\n        JNITest t = new JNITest();\n        t.createGlobalRef();\n        t.getGlobalRef();\n        t.deleteGlobalRef();\n    &#125;\n\n\n    static &#123;\n        System.loadLibrary(&quot;JNIProject&quot;);\n    &#125;\n&#125;\n在com_example_jni_JNITest.h文件声明对应的方法；签名可通过下面的命令获取\n\njavap -s -p com.example.jni.JNITest产生的结果中有对应的属性和方法的签名\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include &quot;jni.h&quot;\n/* Header for class com_example_jni_JNITest */\n\n#ifndef _Included_com_example_jni_JNITest\n#define _Included_com_example_jni_JNITest\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n/*\n * Class:     com_example_jni_JNITest\n * Method:    createGlobalRef\n * Signature: \n */\nJNIEXPORT void JNICALL Java_com_example_jni_JNITest_createGlobalRef\n(JNIEnv *, jobject);\n\n/*\n * Class:     com_example_jni_JNITest\n * Method:    getGlobalRef\n * Signature: \n */\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_getGlobalRef\n(JNIEnv *, jobject);\n\n/*\n * Class:     com_example_jni_JNITest\n * Method:    deleteGlobalRef\n * Signature: \n */\nJNIEXPORT void JNICALL Java_com_example_jni_JNITest_deleteGlobalRef\n(JNIEnv *, jobject);\n#ifdef __cplusplus\n&#125;\n#endif\n#endif\n\n在JNITest.c文件实现com_example_jni_JNITest.h中声明的方法\n\n#include &quot;com_example_jni_JNITest.h&quot;\n#include &lt;stdlib.h&gt;\n\n//全局引用\njstring global_str;\n\nJNIEXPORT void JNICALL Java_com_example_jni_JNITest_createGlobalRef\n(JNIEnv *env, jobject jobj) &#123;\n    jstring obj = (*env)-&gt;NewStringUTF(env,&quot;JNI development is powerful!&quot;);\n    global_str = (*env)-&gt;NewGlobalRef(env,obj);\n&#125;\n\n\n\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_getGlobalRef\n(JNIEnv *env, jobject jobj) &#123;\n    return global_str;\n&#125;\n\nJNIEXPORT void JNICALL Java_com_example_jni_JNITest_deleteGlobalRef\n(JNIEnv *env, jobject jobj) &#123;\n    (*env)-&gt;DeleteGlobalRef(env,global_str);\n&#125;\n5、弱全局引用的使用弱全局引用可以节省内存，在内存不足时可以释放所引用的对象，可以引用一个不常用的对象，如果为NULL，再临时创建\n创建：NewWeakGlobalRef\n销毁：DeleteGlobalWeakRef\n二、JNI 的异常处理JNI自己抛出的异常，在java层无法被捕获，只能在C层清空；用户通过ThrowNew抛出的异常，可以在Java层捕获\n\n保证java代码可以继续运行\n补救措施，保证 C 代码继续执行\n\n例如：\n\n编写JNITest.java文件\n\npublic class JNITest &#123;\n    private String key=&quot;World!&quot;;\n\n    public native void exception();\n\n    public static void main(String[] args)&#123;\n        JNITest t = new JNITest();\n        t.exception();\n    &#125;\n\n\n    static &#123;\n        System.loadLibrary(&quot;JNIProject&quot;);\n    &#125;\n&#125;\n在com_example_jni_JNITest.h文件声明对应的方法；签名可通过下面的命令获取\n\njavap -s -p com.example.jni.JNITest产生的结果中有对应的属性和方法的签名\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include &quot;jni.h&quot;\n/* Header for class com_example_jni_JNITest */\n\n#ifndef _Included_com_example_jni_JNITest\n#define _Included_com_example_jni_JNITest\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n/*\n * Class:     com_example_jni_JNITest\n * Method:    exception\n * Signature: \n */\nJNIEXPORT void JNICALL Java_com_example_jni_JNITest_exception\n(JNIEnv *, jobject);\n\n#ifdef __cplusplus\n&#125;\n#endif\n#endif\n\n在JNITest.c文件实现com_example_jni_JNITest.h中声明的方法\n\n#include &quot;com_example_jni_JNITest.h&quot;\n#include &lt;stdlib.h&gt;\n\n\nJNIEXPORT void JNICALL Java_com_example_jni_JNITest_exception\n(JNIEnv *env, jobject jobj) &#123;\n   jclass cls = (*env)-&gt;GetObjectClass(env,jobj);\n   jfieldID fid = (*env)-&gt;GetFieldID(env,cls,&quot;key2&quot;,&quot;Ljava/lang/String;&quot;);\n   //检测是否发生java异常\n   jthrowable exception = (*env)-&gt;ExceptionOccurred(env);\n   if(exception != NULL)&#123;\n       //让java代码可以继续运行\n       //清空异常信息\n       (*env)-&gt;ExceptionClear(env);\n       fid = (*env)-&gt;GetFieldID(env,cls,&quot;key&quot;,&quot;Ljava/lang/String;&quot;);\n   &#125;\n   jstring jstr = (*env)-&gt;GetObjectField(env,jobj,fid);\n   char *str = (*env)-&gt;GetStringUTFChars(env,jstr,NULL);\n   //比对属性值是否合法，i 忽略大小写\n   if(_stricmp(str,&quot;Hello World!&quot;)!=0)&#123;\n       //人为抛出异常，交给Java层处理\n       jclass newExCls = (*env)-&gt;FindClass(env,&quot;java/lang/IllegalArgumentException&quot;);\n       (*env)-&gt;ThrowNew(env,newExCls,&quot;Key&#39;s value is invalid!&quot;);\n   &#125;\n\n&#125;\n三、JNI 缓存策略1、局部的静态变量局部的静态变量，当程序运行结束之后，变量的值还会在内存中\n例如：\n\n编写JNITest.java文件\n\npublic class JNITest &#123;\n\n    private String key=&quot;Hello World!&quot;;\n    public native String cached();\n\n    public static void main(String[] args)&#123;\n        JNITest t = new JNITest();\n        for (int 1 = 0; i&lt;100; i++)&#123;\n           System.out.pringln(&quot;第&quot;+(i+1)+&quot;次执行，结果为：&quot;+t.cached()); \n        &#125;\n    &#125;\n\n\n    static &#123;\n        System.loadLibrary(&quot;JNIProject&quot;);\n    &#125;\n&#125;\n在com_example_jni_JNITest.h文件声明对应的方法；签名可通过下面的命令获取\n\njavap -s -p com.example.jni.JNITest产生的结果中有对应的属性和方法的签名\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include &quot;jni.h&quot;\n/* Header for class com_example_jni_JNITest */\n\n#ifndef _Included_com_example_jni_JNITest\n#define _Included_com_example_jni_JNITest\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n/*\n * Class:     com_example_jni_JNITest\n * Method:    cached\n * Signature: \n */\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_cached\n(JNIEnv *, jobject);\n\n#ifdef __cplusplus\n&#125;\n#endif\n#endif\n\n在JNITest.c文件实现com_example_jni_JNITest.h中声明的方法\n\n#include &quot;com_example_jni_JNITest.h&quot;\n#include &lt;stdlib.h&gt;\n\n\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_cached\n(JNIEnv *env, jobject jobj) &#123;\n   jclass cls = (*env)-&gt;GetObjectClass(env,jobj);\n   static jfieldID key_id = NULL;\n   //获取jfieldID只获取一次\n   if(key_id == NULL)&#123;\n       key_id = (*env)-&gt;GetFieldID(env,cls,&quot;key&quot;,&quot;Ljava/lang/String;&quot;);\n       printf(&quot;------------GetFieldID--------\\n&quot;)\n   &#125;\n&#125;\n2、全局变量全局变量在动态库加载完成之后，立刻缓存起来\n//初始化全局变量\njfieldID key_fid;\njmethodID random_mid;\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_initIds\n(JNIEnv *env, jclass jcls) &#123;\n    key_fid = (*env)-&gt;GetFieldID(env,jcls,&quot;key&quot;,&quot;Ljava/lang/String;&quot;);\n    random_mid = (*env)-&gt;GetMethodID(env,jcls,&quot;getRandomInt&quot;,&quot;(I)I&quot;);\n&#125;","categories":["JNI"],"tags":["Android","JNI"]},{"title":"JNI 的数据类型","url":"https://blog.onestravel.cn/20180920/b92bc69386ee/","content":"JNI 的数据类型一、JNI 数据类型Java基本数据类型与JNI数据类型的映射关系\n\n\n\nJava数据类型\nJNI数据类型\nC/C++数据类型\n\n\n\nboolean\njboolean\nunsigned char\n\n\nbyte\njbyte\nsigned char\n\n\nchar\njchar\nunsigned short\n\n\nshort\njshort\nshort\n\n\nint\njint\nint\n\n\nlong\njlong\nlong long\n\n\nfloat\njfloat\nfloat\n\n\ndouble\njdouble\ndouble\n\n\nvoid\nvoid\nvoid\n\n\nJava引用数据类型与JNI数据类型的映射关系\n\n\n\nJava数据类型\nJNI数据类型\n\n\n\nString\njstring\n\n\nObject\njobject\n\n\n基本数据类型数组如： byte[]\njbyteArray\n\n\n对象数组如： Object[],String[]\njobjectArray\n\n\n二、C通过JNI调用Java1、访问Java属性GETField\n\n编写JNITest.java文件\n\npublic class JNITest &#123;\n    public String key = &quot;World!&quot;;\n    //访问属性，返回修改之后的属性内容\n    public native String accessField();\n\n    public static void main(String[] args)&#123;\n        JNITest t = new JNITest();\n        System.out.println(&quot;key修改前：&quot;+t.key);\n        t.accessField();\n        System.out.println(&quot;key修改后：&quot;+t.key);\n    &#125;\n\n    static &#123;\n        System.loadLibrary(&quot;JNIProject&quot;);\n    &#125;\n&#125;\n在com_example_jni_JNITest.h文件声明对应的方法\n\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include &quot;jni.h&quot;\n/* Header for class com_example_jni_JNITest */\n\n#ifndef _Included_com_example_jni_JNITest\n#define _Included_com_example_jni_JNITest\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n/*\n * Class:     com_example_jni_JNITest\n * Method:    accessField\n * Signature: ()Ljava/lang/String;\n */\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_accessField\n(JNIEnv *, jobject);\n#ifdef __cplusplus\n&#125;\n#endif\n#endif\n\n在JNITest.c文件实现com_example_jni_JNITest.h中声明的方法\n\n#include &quot;com_example_jni_JNITest.h&quot;\n\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_accessField\n(JNIEnv *jEnv, jobject jobj) &#123;\n    //jobj是t对象，JniTest.class\n    jclass cls = (*jEnv)-&gt;GetObjectClass(jEnv, jobj);\n    //jfieldID\n    //属性名称，属性签名\n    jfieldID fid = (*jEnv)-&gt;GetFieldID(jEnv, cls, &quot;key&quot;, &quot;Ljava/lang/String;&quot;);\n\n    //World! &gt;&gt; Hello World!\n    //获取key属性的值\n    //Get&lt;Type&gt;Field\n    jstring jstr = (*jEnv)-&gt;GetObjectField(jEnv, jobj, fid);\n    printf(&quot;jstr:%#x\\n&quot;, &amp;jstr);\n\n    //jstring -&gt; c字符串\n    //isCopy 是否复制（true代表复制，false不复制）\n    char *c_str = (*jEnv)-&gt;GetStringUTFChars(jEnv, jstr, NULL);\n    //拼接得到新的字符串\n    char text[20] = &quot;Hello &quot;;\n    strcat(text, c_str);\n\n    //c字符串 -&gt;jstring\n    jstring new_jstr = (*jEnv)-&gt;NewStringUTF(jEnv, text);\n\n    //修改key\n    //Set&lt;Type&gt;Field\n    (*jEnv)-&gt;SetObjectField(jEnv, jobj, fid, new_jstr);\n\n    printf(&quot;new_jstr:%#x\\n&quot;, &amp;new_jstr);\n\n    return new_jstr;\n&#125;\n将c代码生成解决文件（动态库.dll）\n将动态库文件拷贝到java项目根路径下\n运行JNITest.java ，即可看到输出结果。\n\n2、访问Java静态属性GETField\n\n编写JNITest.java文件\n\npublic class JNITest &#123;\n    public static int count = 5;\n    //访问属性，返回修改之后的属性内容\n    public native int accessStaticField();\n\n    public static void main(String[] args)&#123;\n        JNITest t = new JNITest();\n        System.out.println(&quot;count 修改前：&quot;+t.count);\n        t.accessStaticField();\n        System.out.println(&quot;count 修改后：&quot;+t.count);\n    &#125;\n\n    static &#123;\n        System.loadLibrary(&quot;JNIProject&quot;);\n    &#125;\n&#125;\n在com_example_jni_JNITest.h文件声明对应的方法\n\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include &quot;jni.h&quot;\n/* Header for class com_example_jni_JNITest */\n\n#ifndef _Included_com_example_jni_JNITest\n#define _Included_com_example_jni_JNITest\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n/*\n * Class:     com_example_jni_JNITest\n * Method:    accessField\n * Signature: ()Ljava/lang/String;\n */\nJNIEXPORT jint JNICALL Java_com_example_jni_JNITest_accessStaticField\n(JNIEnv *, jobject);\n#ifdef __cplusplus\n&#125;\n#endif\n#endif\n\n在JNITest.c文件实现com_example_jni_JNITest.h中声明的方法\n\n#include &quot;com_example_jni_JNITest.h&quot;\n\nJNIEXPORT jint JNICALL Java_com_example_jni_JNITest_accessStaticField\n(JNIEnv *jEnv, jobject jobj) &#123;\n    //jobj是t对象，JniTest.class\n    jclass cls = (*jEnv)-&gt;GetObjectClass(jEnv, jobj);\n    //jfieldID\n    //属性名称，属性签名\n    jfieldID fid = (*jEnv)-&gt;GetStaticFieldID(jEnv, cls, &quot;count&quot;, &quot;I&quot;);\n\n    //获取 count 属性的值\n    //Get&lt;Type&gt;Field\n    jint count = (*jEnv)-&gt;GetStaticIntField(jEnv, jobj, fid);\n    printf(&quot;jstr:%#x\\n&quot;, &amp;jstr);\n    count++;\n    (*jEnv)-&gt;SetStaticIntField(jEnv, jobj, fid,count);\n    return count;\n&#125;\n将c代码生成解决文件（动态库.dll）\n将动态库文件拷贝到java项目根路径下\n运行JNITest.java ，即可看到输出结果。\n\n3、访问java方法CallMethod\n\n编写JNITest.java文件\n\npublic class JNITest &#123;\n\n    public native void accessMethod();\n\n    public static void main(String[] args)&#123;\n        JNITest t = new JNITest();\n        t.accessMethod();\n    &#125;\n\n    //产生指定范围的随机数\n    public int genRandomInt(int max)&#123;\n        System.out.println(&quot;genRandomInt 执行了...&quot;);\n        return new Random().nextInt(max); \n    &#125;\n\n    static &#123;\n        System.loadLibrary(&quot;JNIProject&quot;);\n    &#125;\n&#125;\n在com_example_jni_JNITest.h文件声明对应的方法；签名可通过下面的命令获取\n\njavap -s -p com.example.jni.JNITest产生的结果中有对应的属性和方法的签名\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include &quot;jni.h&quot;\n/* Header for class com_example_jni_JNITest */\n\n#ifndef _Included_com_example_jni_JNITest\n#define _Included_com_example_jni_JNITest\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n/*\n * Class:     com_example_jni_JNITest\n * Method:    accessMethod\n * Signature: (I)I;\n */\nJNIEXPORT void JNICALL Java_com_example_jni_JNITest_accessMethod\n(JNIEnv *, jobject);\n#ifdef __cplusplus\n&#125;\n#endif\n#endif\n\n在JNITest.c文件实现com_example_jni_JNITest.h中声明的方法\n\n#include &quot;com_example_jni_JNITest.h&quot;\n\nJNIEXPORT void JNICALL Java_com_example_jni_JNITest_accessMethod\n(JNIEnv *env, jobject jobj)&#123;\n    //jclass\n    jclass cls = (*env)-&gt;GetObjectClass(env, jobj);\n    //jmethodID\n    jmethodID mid = (*env)-&gt;GetMethodID(env, cls, &quot;genRandomInt&quot;, &quot;(I)I&quot;);\n    //调用\n    //Call&lt;Type&gt;Method\n    jint random = (*env)-&gt;CallIntMethod(env, jobj, mid, 200);\n    printf(&quot;random num:%ld&quot;,random);\n\n    //.....\n&#125;\n将c代码生成解决文件（动态库.dll）\n将动态库文件拷贝到java项目根路径下\n运行JNITest.java ，即可看到输出结果。\n\n4、访问静态方法CallStaticMethod\n\n编写JNITest.java文件\n\npublic class JNITest &#123;\n\n    public native void accessStaticMethod();\n\n    public static void main(String[] args)&#123;\n        JNITest t = new JNITest();\n        t.accessStaticMethod();\n    &#125;\n\n    //产生UUID字符串\n    public static String getUUID()&#123;\n        return UUID.randomUUID().toString();\n    &#125;\n\n    static &#123;\n        System.loadLibrary(&quot;JNIProject&quot;);\n    &#125;\n&#125;\n在com_example_jni_JNITest.h文件声明对应的方法；签名可通过下面的命令获取\n\njavap -s -p com.example.jni.JNITest产生的结果中有对应的属性和方法的签名\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include &quot;jni.h&quot;\n/* Header for class com_example_jni_JNITest */\n\n#ifndef _Included_com_example_jni_JNITest\n#define _Included_com_example_jni_JNITest\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n/*\n * Class:     com_example_jni_JNITest\n * Method:    accessStaticMethod\n * Signature: ()Ljava/lang/String;;\n */\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_accessStaticMethod\n(JNIEnv *, jobject);\n#ifdef __cplusplus\n&#125;\n#endif\n#endif\n\n在JNITest.c文件实现com_example_jni_JNITest.h中声明的方法\n\n#include &quot;com_example_jni_JNITest.h&quot;\n\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_accessStaticMethod\n(JNIEnv *env, jobject jobj)&#123;\n    //jclass\n    jclass cls = (*env)-&gt;GetObjectClass(env, jobj);\n    //jmethodID    \n    jmethodID mid = (*env)-&gt;GetStaticMethodID(env, cls, &quot;getUUID&quot;, &quot;()Ljava/lang/String;&quot;);\n\n    //调用\n    //CallStatic&lt;Type&gt;Method\n    jstring uuid = (*env)-&gt;CallStaticObjectMethod(env, cls, mid);\n\n    //随机文件名称 uuid.txt\n    //jstring -&gt; char*\n    //isCopy ，代表java和c操作的是同一个字符串\n    char *uuid_str = (*env)-&gt;GetStringUTFChars(env, uuid, NULL);\n    //拼接\n    char filename[100];\n    sprintf(filename, &quot;D://%s.txt&quot;,uuid_str);\n    FILE *fp = fopen(filename,&quot;w&quot;);\n    fputs(&quot;How are you?&quot;, fp);\n    fclose(fp);\n&#125;\n\n将c代码生成解决文件（动态库.dll）\n将动态库文件拷贝到java项目根路径下\n运行JNITest.java ，即可看到输出结果。\n\n5、访问构造方法通过FindClass找到对应的类\n\n编写JNITest.java文件\n\npublic class JNITest &#123;\n    //java.util.Date\n    public native Date accessConstructor();\n\n    public static void main(String[] args)&#123;\n        JNITest t = new JNITest();\n        t.accessConstructor();\n    &#125;\n\n\n    static &#123;\n        System.loadLibrary(&quot;JNIProject&quot;);\n    &#125;\n&#125;\n在com_example_jni_JNITest.h文件声明对应的方法；签名可通过下面的命令获取\n\njavap -s -p com.example.jni.JNITest产生的结果中有对应的属性和方法的签名\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include &quot;jni.h&quot;\n/* Header for class com_example_jni_JNITest */\n\n#ifndef _Included_com_example_jni_JNITest\n#define _Included_com_example_jni_JNITest\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n/*\n * Class:     com_example_jni_JNITest\n * Method:    accessConstructor\n * Signature: \n */\nJNIEXPORT jobject JNICALL Java_com_example_jni_JNITest_accessConstructor\n(JNIEnv *, jobject);\n#ifdef __cplusplus\n&#125;\n#endif\n#endif\n\n在JNITest.c文件实现com_example_jni_JNITest.h中声明的方法\n\n#include &quot;com_example_jni_JNITest.h&quot;\n\n//使用java.util.Date产生一个当前的时间戳\nJNIEXPORT jobject JNICALL Java_com_example_jni_JNITest_accessConstructor\n(JNIEnv *env, jobject jobj)&#123;\n    jclass cla = (*env)-&gt;FindClass(env,&quot;java/util/Date&quot;);\n    //jmethodID,构造方法的方法名称固定为&quot;&lt;init&gt;&quot;\n    jmethodID constructor_mid = (*env)-&gt;GetMethodID(env,cls,&quot;&lt;init&gt;&quot;,&quot;()V&quot;);\n    //实例化一个Date对象\n    jobject date_obj = (*env)-&gt;NewObject(env,cls,constructor_mid);\n    //调用getTime方法\n    jmehoodID mid = (*env)-&gt;GetMethodID(env,cls,&quot;getTime&quot;,&quot;()J&quot;);\n    //调用\n    jlong time = \n    (*env)-&gt;CallLongMethod(env,date_obj,mid);\n    //time 为long long类型\n    printf(&quot;time: %lld\\n&quot;,time);\n    return date_obj;\n&#125;\n\n将c代码生成解决文件（动态库.dll）\n将动态库文件拷贝到java项目根路径下\n运行JNITest.java ，即可看到输出结果。\n\n6、访问父类的方法\n\n编写父类文件\n\npublic class Human &#123;\n    public void sayHi()&#123;\n        System.out.println(&quot;Human say Hi...&quot;);\n    &#125;\n&#125;\n\n\npublic class man extends Human&#123;\n    @override\n    public void sayHi()&#123;\n        System.out.println(&quot;Man say Hi,How are you?&quot;);\n    &#125;\n&#125;\n编写JNITest.java文件\n\npublic class JNITest &#123;\n    public Human human = new Man();\n    public native void accessNonvirtualMethod();\n\n    public static void main(String[] args)&#123;\n        JNITest t = new JNITest();\n        t.accessNonvirtualMethod();\n    &#125;\n\n\n    static &#123;\n        System.loadLibrary(&quot;JNIProject&quot;);\n    &#125;\n&#125;\n在com_example_jni_JNITest.h文件声明对应的方法；签名可通过下面的命令获取\n\njavap -s -p com.example.jni.JNITest产生的结果中有对应的属性和方法的签名\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include &quot;jni.h&quot;\n/* Header for class com_example_jni_JNITest */\n\n#ifndef _Included_com_example_jni_JNITest\n#define _Included_com_example_jni_JNITest\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n/*\n * Class:     com_example_jni_JNITest\n * Method:    accessNonvirtualMethod\n * Signature: \n */\nJNIEXPORT jobject JNICALL Java_com_example_jni_JNITest_accessNonvirtualMethod\n(JNIEnv *, jobject);\n#ifdef __cplusplus\n&#125;\n#endif\n#endif\n\n在JNITest.c文件实现com_example_jni_JNITest.h中声明的方法\n\n#include &quot;com_example_jni_JNITest.h&quot;\n\n//调用父类的方法 \nJNIEXPORT jobject JNICALL Java_com_example_jni_JNITest_accessNonvirtualMethod\n(JNIEnv *env, jobject jobj)&#123;\n    jclass cls = (*env)-&gt;GetObjectClass(env,jobj);\n    //获取Man属性\n    jfieldID fid =    (*env)-&gt;GetFieldID(env,cls,&quot;human&quot;,&quot;Lcom/example/jni/Human;&quot;);\n    jobject human_obj = (*env)-&gt;GetObjectField(env,jobj,fid);\n    //执行sayHi方法\n    //传父类的父类\n    jclass human_cls = (*env)-&gt;FindClass(env,&quot;com/example/jni/Human&quot;);\n    jmethodID  mid = (*env)-&gt;GetMethodID(env,human_cls,&quot;sayHi&quot;,&quot;()V&quot;);\n    //执行子类方法\n    (*env)-&gt;CallObjectMethod(env,human_obj,mid);\n\n    //执行父类方法\n    (*env)-&gt;CallNonvirtualObjectMethod(env,human_obj,human_cls,mid);\n\n&#125;\n\n将c代码生成解决文件（动态库.dll）\n将动态库文件拷贝到java项目根路径下\n运行JNITest.java ，即可看到输出结果。\n\n三、JNI字符串乱码问题\n编写JNITest.java文件\n\npublic class JNITest &#123;\n\n    public native String chineseChars(String in);\n\n    public static void main(String[] args)&#123;\n        JNITest t = new JNITest();\n        String outStr = t.chineseChars(&quot;传入一串中文&quot;);\n        System.out.println(outStr);\n    &#125;\n\n\n    static &#123;\n        System.loadLibrary(&quot;JNIProject&quot;);\n    &#125;\n&#125;\n在com_example_jni_JNITest.h文件声明对应的方法；签名可通过下面的命令获取\n\njavap -s -p com.example.jni.JNITest产生的结果中有对应的属性和方法的签名\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include &quot;jni.h&quot;\n/* Header for class com_example_jni_JNITest */\n\n#ifndef _Included_com_example_jni_JNITest\n#define _Included_com_example_jni_JNITest\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n/*\n * Class:     com_example_jni_JNITest\n * Method:    chineseChars\n * Signature: \n */\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_chineseChars\n(JNIEnv *, jobject,jstring);\n#ifdef __cplusplus\n&#125;\n#endif\n#endif\n\n在JNITest.c文件实现com_example_jni_JNITest.h中声明的方法\n\n#include &quot;com_example_jni_JNITest.h&quot;\n\n//中文问题\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_chineseChars\n(JNIEnv *env, jobject jobj, jstring in) &#123;\n    char *c_str = (*env)-&gt;GetStringUTFChars(env, in, NULL);\n    printf(&quot;%s\\n&quot;, c_str);\n    char *c_str_out = &quot;传出一段文字&quot;;\n    //NewStringUTF 是utf-16编码\n    jstring j_str = (*env)-&gt;NewStringUTF(env, c_str_out);\n    //使用Java处理乱码问题\n    jclass jcls = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);\n    //jmethodID\n    jmethodID c_mid = (*env)-&gt;GetMethodID(env, jcls, &quot;&lt;init&gt;&quot;, &quot;([BLjava/lang/String;)V&quot;);\n    //byte[]数组\n    //jbyteArray -&gt; char[]\n    jbyteArray bytes = (*env)-&gt;NewByteArray(env, strlen(c_str_out));\n    //byte数组赋值\n    (*env)-&gt;SetByteArrayRegion(env, bytes, 0, strlen(c_str_out), c_str_out);\n    //字符编码\n    jstring charsetName = (*env)-&gt;NewStringUTF(env, &quot;GB2312&quot;);\n    //调用构造函数，返回编码之后的字符串\n\n    return (*env)-&gt;NewObject(env, jcls, c_mid, bytes, charsetName);\n&#125;\n\n将c代码生成解决文件（动态库.dll）\n将动态库文件拷贝到java项目根路径下\n运行JNITest.java ，即可看到输出结果。\n\n四、JNI数组处理，传入一个数组，返回另一个数组\n编写JNITest.java文件\n\npublic class JNITest &#123;\n\n    public native int[] sortArray(int[] array);\n\n    public static void main(String[] args)&#123;\n        JNITest t = new JNITest();\n        int[] arr = new int[]&#123;6,8,1,17,23,12,65,32&#125;;\n        int newArr = t.sortArray();\n        for (int i : arr) &#123;\n            System.out.println(i);\n        &#125;\n        System.out.println(&quot;返回的新数组为：&quot;);\n         for (int i : newArr) &#123;\n            System.out.println(i);\n        &#125;\n    &#125;\n\n\n    static &#123;\n        System.loadLibrary(&quot;JNIProject&quot;);\n    &#125;\n&#125;\n在com_example_jni_JNITest.h文件声明对应的方法；签名可通过下面的命令获取\n\njavap -s -p com.example.jni.JNITest产生的结果中有对应的属性和方法的签名\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include &quot;jni.h&quot;\n/* Header for class com_example_jni_JNITest */\n\n#ifndef _Included_com_example_jni_JNITest\n#define _Included_com_example_jni_JNITest\n#ifdef __cplusplus\nextern &quot;C&quot; &#123;\n#endif\n/*\n * Class:     com_example_jni_JNITest\n * Method:    sortArray\n * Signature: \n */\nJNIEXPORT jintArray JNICALL Java_com_example_jni_JNITest_sortArray\n(JNIEnv *, jobject,jintArray);\n#ifdef __cplusplus\n&#125;\n#endif\n#endif\n\n在JNITest.c文件实现com_example_jni_JNITest.h中声明的方法\n\n#include &quot;com_example_jni_JNITest.h&quot;\n#include &lt;stdlib.h&gt;\n\nint compare(int *a,int *b)&#123;\n    return (*a) - (*b);\n&#125;\n\n//数组处理\nJNIEXPORT jintArray JNICALL Java_com_example_jni_JNITest_sortArray\n(JNIEnv *env, jobject jobj, jintArray arr) &#123;\n    //拿到 jintArray 的指针 -&gt; 得到 c int 数组\n    jint *elems = (*env)-&gt;GetIntArrayElements(env,arr,NULL);\n    //数组的长度\n    int len = (*env)-&gt;GetArrayLength(env,arr);\n\n    //排序\n    qsort(elems, len, sizeof(jint), compare);\n    //同步,第4个参数：\n    //JNI_OK(0)：Java数组进行更新，并且释放C/C++数组\n    //JNI_COMMIT(1):Java数组进行更新，不释放C/C++数组（函数执行完数组会释放）\n    //JNI_ABOUT：Java数组不进行更新，但释放C/C++数组\n    (*env)-&gt;ReleaseIntArrayElements(env, arr, elems,JNI_COMMIT);\n\n\n    //将原数组倒序生成一个新的数组\n    jintArray jint_new_arr = (*env)-&gt;NewIntArray(env,len);\n    jint *new_elems = (*env)-&gt;GetIntArrayElements(env,jint_new_arr,NULL);\n    int i = len-1;\n    for(; i &gt;= 0; i--)&#123;\n        int j = len-1-i;\n        new_elems[j] = elems[i];\n    &#125;\n    //同步\n    (*env)-&gt;ReleaseIntArrayElements(env, jint_new_arr, new_elems, JNI_COMMIT);\n    return jint_new_arr;\n&#125;\n\n将c代码生成解决文件（动态库.dll）\n将动态库文件拷贝到java项目根路径下\n运行JNITest.java ，即可看到输出结果。\n\n","categories":["JNI"],"tags":["Android","JNI"]},{"title":"JNI 开发流程","url":"https://blog.onestravel.cn/20180915/bbdac1278a35/","content":"JNI 开发流程一、C 语言执行的流程\n编辑：编写代码的过程。\n预编译（预处理）：为编译做准备工作，完成代码文本的替换工作。\n编译：形成目标代码(.obj)。\n连接：将目标代码与C 函数库连接合并，形成最终的可执行文件。\n执行：执行可执行文件。\n\n二、头文件1、头文件的作用头文件告诉编译器有这样一个函数，连接器负责找到这个函数的实现\n2、自定义头文件*注：开发工具为 Visual Studio 2017\n1、创建 .h 文件，对相应方法进行声明。例如：创建 math.h\n#ifndef _MATH_H  //如果没有定义 _MATH_H 标识\n#define _MATH_H  //定义 _MATH_H 标识\nint add(int, int, int);\n#endif或\n//该头文件只被包含一次，让编译器自己处理好循环包含问题\n#pragma once \nint add(int, int, int);2、在 .h 文件同级目录下创建对应的 .c 文件，对 .h 文件中声明的方法进行实现。例如：创建 head.c \n#define _CRT_SECURE_NO_WARNINGS\n#include &quot;math.h&quot;\n#include &lt;stdio.h&gt;\n\nint add(int a, int b, int c)&#123;\n   int result = 0;\n   result = a + b + c;\n   return result;\n&#125;\n3、创建一个C文件，进行验证头文件是否编写成功。例如：创建 test.c\n#include&lt;stdio.h&gt;\n#include &quot;math.h&quot;\n\n\nvoid main()&#123;\n    int a = 3, b = 4, c = 5, result = 0;\n    result = add(a, b, c);\n    printf(&quot;The result is %d!\\n&quot;, result);\n    system(&quot;pause&quot;);\n&#125;三、define 指令1、define 指令的作用\ndefine 指令用来定义标识； 如：** #ifdef __cplusplus 标识支持C++语法；防止文件重复引入**\ndefine 指令用来定义常数；如：#define MAX 100\ndefine 指令用来定义“宏函数”。如：\n\nvoid jni_read()&#123;\n    printf(&quot;read\\n&quot;);\n&#125;\n\nvoid jni_write()&#123;\n    printf(&quot;write\\n&quot;);\n&#125;\n\n/**\n * 宏函数\n */\n#define jin(NAME) jni_##NAME();\n\nvoid main()&#123;\n    jni(read);\n    jni(write);\n    getchar();\n&#125;日志输出示例：\n/**\n *__VA_ARGS__    可变参数\n */\n#define LOG(FOTMAT,...) printf(##FOTMAT,__VA_ARGS__);printf(&quot;\\n&quot;);\n\nvoid main()&#123;\n    LOG(&quot;%s: %d&quot;,&quot;size&quot;,99);\n    getchar();\n&#125;四、JNI (Java Native Interface)1、定义*Java 调用C/C++或者C/C++调用 Java 的一套 API *\n2、Java调用C/C++项目开发步骤（Windows系统下）\n编写native方法\npackage com.example.jni;\npublic class JNITest &#123;\n\n  public native static String getStringFromC();\n\n  public static void main(String[] args)&#123;\n\n  &#125;\n&#125;\njavah命令，生成.h文件\njavah com.example.jni.JNITest\n//生成 com_example_jni_JNITest.h 文件\n复制.h头文件到CPP工程中\n\n复制jni.h和jni_md.h文件到CPP工程中\n\n实现.h头文件中声明的函数；C函数名称：Java_完整类名_函数名\n\n\n//JNITest.c\n#include &quot;com_example_jni_JNITest.h&quot;\n\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_getStringFromC\n(JNIEnv *jEnv, jclass jcls) &#123;\n    //简单实现，将C的字符传转成Java的字符串\n    return (*jEnv)-&gt;NewStringUTF(jEnv, &quot;C String&quot;);\n\n&#125;\n生成动态库.dll文件(Windows环境下默认dll，Linux环境下默认为so)\n配置D:\\dll 目录到环境变量，并将刚刚生成的 .dll 文件复制到D:\\dll 目录下；或者复制到项目根目录下；\n重启Eclipse，使用IDEA的需要在项目运行配置中的 VM options 中增加配置：```// VM options:\nDjava.library.path=D:\\dll\n\n\n五、JNIEnv1、JNIEnv 是什么\n在C语言中JNIEnv是一个结构体指针，代表Java运行环境，主要是调用Java中的代码，在上面JNITest.c中实现函数声明的时候，jEnv 是一个二级指针\n\n//JNITest.c\n#include &quot;com_example_jni_JNITest.h&quot;\n\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_getStringFromC\n(JNIEnv *jEnv, jclass jcls) &#123;\n    //简单实现，将C的字符传转成Java的字符串\n    return (*jEnv)-&gt;NewStringUTF(jEnv, &quot;C String&quot;);\n\n&#125;\n在C++中JNIEnv是一个结构体的别名，代表Java运行环境，主要是调用Java中的代码，jEnv 是一个结构体的一级指针\n\n//JNITest.cpp\n#include &quot;com_example_jni_JNITest.h&quot;\n\nJNIEXPORT jstring JNICALL Java_com_example_jni_JNITest_getStringFromC\n(JNIEnv *jEnv, jclass jcls) &#123;\n    //简单实现，将C的字符传转成Java的字符串\n    return jEnv-&gt;NewStringUTF(&quot;C String&quot;);\n\n&#125;模拟C 的实现\n//JNIEnv 是结构体指针的别名\ntypedef struct JNINativeInferface_* JNIEnv;\n//结构体\nstruct JNINativeInferface_&#123;\n    char* (*NewStringUTF)(JNIEnv*,char*);\n&#125;;\n\n//函数实现\nchar* NewStringUTF(JNIEnv* env,char* str)&#123;\n    return str;\n&#125;\n\nvoid main()&#123;\n    //实例化结构体\n    struct JNINativeInferface_ struct_env;\n    struct_env.NewStringUTF = NewStringUTF;\n\n    //结构体指针\n    JNIEnv e = &amp;struct_env;\n    //结构体的二级指针\n    JNIEnv *env = &amp;e;\n    //通过二级指针调用函数\n    char* str = (*env)-&gt;NewStringUTF(env,&quot;Hello&quot;);\n    printf(&quot;str = %s\\n&quot;,str);\n    getchar();\n&#125;\n2、JNIEnv 调用函数时C和C++的区别\nC 中需要传入 JNIEnv ，因为函数执行过程中需要 JNIEnv\nC++ 中不需要传入 JNIEnv ，是因为C++中有 this，相当与JNIEnv\nC++只是针对C的那一套进行分装，给一个变量赋值为指针，这个变量是二级指针\n\n六、jclass每个native函数（C中的函数），都至少有两个参数(JNIEnv* jclass或者jobject)。\n\n当native方法为静态方法时：jclass代表native 方法所属类的class对象（JNITest.class）；\n当 native 方法为非静态方法时：jobject 代表 native 方法所属的对象。\n\n","categories":["JNI"],"tags":["Android","JNI"]},{"title":"（五）C语言之联合体，枚举与IO","url":"https://blog.onestravel.cn/20180910/7154f47a7dde/","content":"（五）C语言之联合体，枚举与IO一、联合体（共用体）1、定义 不同类型的变量共同占用一段内存（相互覆盖），联合变量任何时刻只有一个成员存在，节省内存\n2、大小 联合体变量的大小=最大的成员所占的字节数\n union MyValue&#123;\n     int x;\n     int y;\n     double z;\n &#125;;\n\n void main()&#123;\n     union MyValue d1;\n     d1.x = 90;\n     d1.y = 100;\n     printf(&quot;%d,%d,%lf\\n&quot;,d1.x,d1.y,d1.z);\n     d1.z = 25.8;\n     printf(&quot;%d,%d,%lf\\n&quot;,d1.x,d1.y,d1.z);\n     getchar();\n &#125;输出结果为：\n100,100,-92559592117433135502616407313071917486139351398276445610442752.000000\n-858993459,-858993459,25.800000根据上面代码可得出结论：在联合体中，最后一次赋值有效\n二、枚举1、定义“枚举”就是把可能的值（固定的数据）一一的列举出来，变量的值只限于列举出来的值的范围\n例如：\nenum Day&#123;\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday,\n    Sunday\n&#125;;\n\nvoid main()&#123;\n    enum Day d = Wednesday;\n    printf(&quot;Today is %d,%#x\\n&quot;,d,&amp;d);\n    getchar();\n&#125;三、IO操作1、读取文本文件参考文档\n读取文件的方法为:\nFILE * fopen(char * path,char * model)\nvoid main()&#123;\n    char path[] = &quot;D:\\\\test.txt&quot;;\n    //打开 \n    FILE *fp = fopen(path,&quot;r&quot;);\n    if(fp == NULL)&#123;\n        printf(&quot;文件打开失败...\\n&quot;);\n        return;\n    &#125;\n    //读取\n    char buff[50];//缓冲\n    while(fgets(buff,50,fp))&#123;\n        printf(&quot;%s&quot;,buff);\n    &#125;\n    //关闭\n    fclose(fp);\n    getchar();\n&#125;2、写入文本文件参考文档\n写入文件的方法为:\nfputs(char * text,FILE * _file)\nvoid main()&#123;\n    char path[] = &quot;D:\\\\test_new.txt&quot;;\n    //打开 \n    FILE *fp = fopen(path,&quot;w&quot;);\n    if(fp == NULL)&#123;\n        printf(&quot;文件打开失败...\\n&quot;);\n        return;\n    &#125;\n    //写入\n    char *text = &quot;How are you?\\nI am fine,Thank You!&quot;;\n    fputs(text,fp);\n    //关闭\n    fclose(fp);\n    getchar();\n&#125;3、操作二进制文件\n计算机的文件存储在物理上都是二进制；文本文件和二进制之分，其实是一个逻辑之分\n\nC读写文本文件与二进制文件的差别仅仅体现在回车换行符\n\n写文本时，每遇到一个’\\n’,会将其转换成’\\r\\n’,(回车换行)\n\n读文本时，每遇到一个’\\r\\n’,会将其转换成’\\n’\n\n\nsize_t fread ( void * ptr, size_t size, size_t count, FILE * stream );参考文档参数：\n\nptr :指向大小至少为（size * count）个字节的内存块的指针，转换为void *。\nsize :要读取的每个元素的大小（以字节为单位）。size_t是无符号整数类型。\ncount :元素数量，每个元素的大小为字节大小。size_t是无符号整数类型。\nstream:指向指定输入流的FILE对象的指针。\n\nsize_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );参考文档参数：\n\nptr :指向大小至少为（size * count）个字节的内存块的指针，转换为void *。\n\nsize :要读取的每个元素的大小（以字节为单位）。size_t是无符号整数类型。\n\ncount :元素数量，每个元素的大小为字节大小。size_t是无符号整数类型。\n\nstream:指向指定输入流的FILE对象的指针。\nvoid main()&#123;\n  char read_path[] = &quot;D:\\\\avatar.jpg&quot;;\n  char write_path[] = &quot;D:\\\\avatar_new.jpg&quot;;\n  //读的文件,b字符表示操作二进制文件（binary）\n  FILE *read_fp = fopen(read_path,&quot;rb&quot;);\n\n  //写的文件\n  FILE *write_fp = fopen(write_path,&quot;wb&quot;);;\n  //复制\n  int buff[50];//缓冲区域\n  int len = 0;//每次读到的内容的长度\n  while((len = fread(buff,sizeof(int),50,read_fp))!=0)&#123;\n      //将读取到的内容写入新文件\n      fwrite(buff,sizeof(int),50,write_fp);\n  &#125;\n  //关闭\n  fclose(read_fp);\n   fclose(write_fp);\n  getchar();\n&#125;\n\n4、获取文件的大小重新定位文件指针：\nint fseek ( FILE * stream, long int offset, int origin );\n参数：\n\nstream：指向标识流的FILE对象的指针。\noffset：二进制文件：从原点偏移的字节数。文本文件：零或ftell返回的值\norigin：位置用作偏移的参考。 它由中定义的以下常量之一指定，专门用作此函数的参数：\n\n\n\n\nConstant\nReference position\n\n\n\nSEEK_SET\n文件开头\n\n\nSEEK_CUR\n文件指针的当前位置\n\n\nSEEK_END\n文件结束\n\n\n*允许库实现无意义地支持SEEK_END（因此，使用它的代码没有真正的标准可移植性）。\n\n\n\n返回当前的文件指针，相对于文件开头的位移量：\nlong ftell ( FILE * stream);\nvoid main()&#123;\n    char read_path[] = &quot;D:\\\\avatar.jpg&quot;;\n    FILE *fp = fopen(read_path,&quot;r&quot;);\n    //重新定位文件指针\n    fseek(fp,0,SEEK_END);\n    //返回当前的文件指针，相对于文件开头的位移量\n    long filesize = ftell(fp);\n    printf(&quot;filesize = %d\\n&quot;,filesize);\n    getchar();\n&#125;5、文本文件的加密解密//加密\nvoid crpypt(char normal_path[], char crypt_path[]) &#123;\n    //打开文件\n    FILE *normal_fp = fopen(normal_path, &quot;r&quot;);\n    FILE *crypt_fp = fopen(crypt_path, &quot;w&quot;);\n    //一次读取一个字符\n    int ch;\n    while ((ch = fgetc(normal_fp)) != EOF) &#123;//End of FILE\n        //加密\n        fputc(ch ^ 9, crypt_fp);\n    &#125;\n    fclose(normal_fp);\n    fclose(crypt_fp);\n&#125;\n\n//解密\nvoid decrpypt(char crypt_path[], char decrpypt_path[]) &#123;\n    //打开文件\n    FILE *crypt_fp = fopen(crypt_path, &quot;r&quot;);\n    FILE *decrpypt_fp = fopen(decrpypt_path, &quot;w&quot;);\n    //一次读取一个字符\n    int ch;\n    while ((ch = fgetc(crypt_fp)) != EOF) &#123;//End of FILE\n        //加密\n        fputc(ch ^ 9, decrpypt_fp);\n    &#125;\n    fclose(crypt_fp);\n    fclose(decrpypt_fp);\n&#125;\n\nvoid main() &#123;\n    char normal_path[] = &quot;D:\\\\test.txt&quot;;\n    char crypt_path[] = &quot;D:\\\\test_crypt.txt&quot;;\n    char decrypt_path[] = &quot;D:\\\\test_decrypt.txt&quot;;\n    crpypt(normal_path, crypt_path);\n    decrpypt(crypt_path, decrypt_path);\n    getchar();\n&#125;6、二进制文件的加密解密读取二进制文件中的数据时，一个一个字符读取密码：qazwsx\n//加密\nvoid crpypt(char normal_path[], char crypt_path[], char password[]) &#123;\n    //打开文件\n    FILE *normal_fp = fopen(normal_path, &quot;rb&quot;);\n    FILE *crypt_fp = fopen(crypt_path, &quot;wb&quot;);\n    //一次读取一个字符\n    int ch;\n    int i = 0;\n    int pwd_len = strlen(password);\n    while ((ch = fgetc(normal_fp)) != EOF) &#123;//End of FILE\n        //加密\n        fputc(ch ^ password[i % pwd_len], crypt_fp);\n        i++;\n    &#125;\n    fclose(normal_fp);\n    fclose(crypt_fp);\n&#125;\n\n//解密\nvoid decrpypt(char crypt_path[], char decrpypt_path[], char password[]) &#123;\n    //打开文件\n    FILE *crypt_fp = fopen(crypt_path, &quot;rb&quot;);\n    FILE *decrpypt_fp = fopen(decrpypt_path, &quot;wb&quot;);\n    //一次读取一个字符\n    int ch;\n    int i = 0;\n    int pwd_len = strlen(password);\n    while ((ch = fgetc(crypt_fp)) != EOF) &#123;//End of FILE\n        //加密\n        fputc(ch ^ password[i % pwd_len], decrpypt_fp);\n        i++;\n    &#125;\n    fclose(crypt_fp);\n    fclose(decrpypt_fp);\n&#125;\n\nvoid main() &#123;\n    char password[] =&quot;qazwsx&quot;;\n    char normal_path[] = &quot;D:\\\\avatar.jpg&quot;;\n    char crypt_path[] = &quot;D:\\\\avatar_crypt.jpg&quot;;\n    char decrypt_path[] = &quot;D:\\\\avatar_decrypt.jpg&quot;;\n    crpypt(normal_path, crypt_path,password);\n    decrpypt(crypt_path, decrypt_path,password);\n    getchar();\n&#125;","categories":["C"],"tags":["C"]},{"title":"（四）C语言之结构体","url":"https://blog.onestravel.cn/20180903/8617d8394082/","content":"（四）C语言之结构体一、什么是结构体结构体是一种构造数据类型，就是把不同的数据类型整合起来成为一个自定义的数据类型\n二、初始化结构体的变量1. 第一种初始化方式struct [结构体类型] [结构体变量名] = {[结构体内参数实例化值]\n2. 第二种初始化方式struct [结构体类型] [结构体变量名] ;\n[结构体变量名].[结构体参数名] = [实例化值];\n例如：\nstruct Man\n&#123;\n    char name[20];\n    int age;\n    char* mobile;\n\n&#125;;\nvoid main() &#123;\n    struct Man m1 = &#123; &quot;Jack&quot;,20 ,&quot;18800008888&quot;&#125;;\n    printf(&quot;%s,%d,%s\\n&quot;, m1.name, m1.age,m1.mobile);\n    //或\n    struct Man m2 ;\n    //m2.name 数组类型不能直接复制\n    strcpy(m2.name, &quot;Rose&quot;);\n    m2.age = 23;\n    m2.mobile = &quot;16600001111&quot;;\n    printf(&quot;%s,%d,%s\\n&quot;, m2.name, m2.age,m2.mobile);\n    getchar();\n&#125;输出：\nJack,20,18800008888\nRose,23,16600001111三、结构体的几种写法1、第一种写法例如：\nstruct Man&#123;\n    char name[20];\n    int age;\n&#125;;\nvoid main() &#123;\n    struct Man m1 = &#123; &quot;Jack&quot;,20&#125;;\n    printf(&quot;%s,%d\\n&quot;, m1.name, m1.age);\n    getchar();\n&#125;2、第二种写法，可以在结构体类型的}后，定义结构体变量名，也可以对结构体变量名进行初始化。例如：\nstruct Man &#123;\n    char* name;\n    int age;\n&#125; Man,m2=&#123;&quot;jack&quot;,20&#125;;\n\nvoid main() &#123;\n    Man.name = &quot;Tom&quot;;\n    Man.age = 19;\n    printf(&quot;%s,%d\\n&quot;, Man.name,Man\n    .age);\n    getchar();\n&#125;3、第三种写法:匿名结构体,控制结构体变量的个数（限量版），相当于单例例如：\nstruct  &#123;\n    char* name;\n    int age;\n&#125; Woman;\n\nvoid main() &#123;\n    Woman.name = &quot;Lili&quot;;\n    Woman.age = 19;\n    printf(&quot;%s,%d\\n&quot;, Woman.name,Woman\n    .age);\n    getchar();\n&#125;四、结构体嵌套结构体是可以进行嵌套使用的,可以分别定义使用，或者在一个结构体中定义另一个结构体\n1、分别定义结构体嵌套例如：\n// 老师的结构体\nstruct Teacher &#123;\n    char name[20];\n&#125;;\n\n// 学生的结构体\nstruct Student &#123;\n    char name[20];\n    int age;\n    struct Teacher t;\n&#125;;\n\nvoid main() &#123;\n    struct Student s1 = &#123; &quot;jack&quot;,21,&#123;&quot;Jason&quot;&#125; &#125;;\n    struct Student s2;\n    strcpy(s2.name, &quot;Tom&quot;);\n    s2.age = 23;\n    strcpy(s2.t.name, &quot;Jason&quot;);\n    getchar();\n&#125;\n2、结构体内定义结构体嵌套例如：\n// 学生的结构体\nstruct Student &#123;\n    char name[20];\n    int age;\n    // 老师的结构体\n    struct Teacher &#123;\n        char name[20];\n    &#125; t;\n&#125;;\n\nvoid main() &#123;\n    struct Student s1 = &#123; &quot;jack&quot;,21,&#123;&quot;Jason&quot;&#125; &#125;;\n    struct Student s2;\n    strcpy(s2.name, &quot;Tom&quot;);\n    s2.age = 23;\n    strcpy(s2.t.name, &quot;Jason&quot;);\n    getchar();\n&#125;\n五、结构体与指针结构体变量也可以使用指针进行操作，”p-&gt;”是”(*p).”的简写形式\n例如：\nstruct Man&#123;\n    char name[20];\n    int age;\n&#125;;\n\nvoid main()&#123;\n    struct Man m1 = &#123;&quot;Jack&quot;,30&#125;;\n    //结构体指针\n    struct Man *p = &amp;m1;\n    printf(&quot;%s,%d\\n&quot;,(*p).name,(*p).age);\n    //&quot;p-&gt;&quot;是&quot;(*p).&quot;的简写形式\n    printf(&quot;%s,%d\\n&quot;,p-&gt;name,p-&gt;age);\n    getchar();\n&#125;六、结构体数组与指针结构体变量也可以使用指针进行操作，”p-&gt;”是”(*p).”的简写形式\n例如：\nstruct Man &#123;\n    char name[20];\n    int age;\n&#125;;\n\nvoid main() &#123;\n    struct Man mans[] = &#123; &#123;&quot;Jack&quot;,30&#125;,&#123;&quot;Rose&quot;,19&#125; &#125;;\n    //遍历数组\n    struct Man *p = mans;\n    for (; p &lt; mans + 2; p++) &#123;\n        printf(&quot;%s,%d\\n&quot;, p-&gt;name, p-&gt;age);\n    &#125;\n\n    int i = 0;\n    for (; i &lt; sizeof(mans) / sizeof(struct Man); i++) &#123;\n        printf(&quot;%s,%d\\n&quot;, mans[i].name, mans[i].age);\n    &#125;\n    getchar();\n&#125;七、结构体的大小（字节对齐）结构体的大小必须是结构体中最宽基本数据类型的整数倍\n牺牲一定的存储空间（本需要12字节的空间，实际分配16字节，（最宽基本数据类型的整数倍）），提升读取的效率\n例如：\nstruct Man &#123;\n    int age;\n    double weight;\n&#125;;\n\nvoid main() &#123;\n    struct Man m1 = &#123; 20,80.9 &#125;;\n    printf(&quot;%#x,%d\\n&quot;, &amp;m1,sizeof(m1));\n    getchar();\n&#125;输出：\n0xcffcc4,16八、结构体与动态内存分配struct Man&#123;\n    char *name;\n    int age;\n&#125;;\n\nvoid main()&#123;\n    struct Man *man_p = (struct Man*)malloc(sizeof(struct Man)*10);\n    struct Man *p = man_p;\n    //赋值\n    p-&gt;name = &quot;Jack&quot;;\n    p-&gt;age = 20;\n    p++;\n    p-&gt;name = &quot;Rose&quot;;\n    p-&gt;age = 23;\n\n    struct Man *loop_p =man_p  ;\n    for(;loop_p &lt; man_p+2;loop_p++)&#123;\n        printf(&quot;%s,%d\\n&quot;,loop_p-&gt;name,loop_p-&gt;age);\n    &#125;\n    free(man_p);\n    getchar();\n&#125;九、typedef 类型取别名1、不同的名称代表在干不同的事情；typedef int jint;\n2、不同的情况下，使用不同的别名\nif(_cplusplus)&#123;\n    typedef _JNIEvn JNIEvn;\n    typedef _JavaVM JavaVM;\n\n&#125;3、书写简洁\nstruct Man&#123;\n    char *name;\n    int age;\n&#125;;\n\n\n//Age  int 类型的别名\ntypedef int Age;\n//Ap int 类型指针的别名\ntypedef int* Ap;\n\ntypedef struct Man JavaMan;\ntypedef struct Man* JM;\n//简写\ntypedef struct Woman&#123;\n    char name[20];\n    int age;\n&#125; W,*WP;// W 是Woman结构体的别名；WP 是Woman结构体指针的别名。\n\n\nvoid main()&#123;\n    int i = 5;\n    Ap p = &amp;i;\n    //结构体变量\n    W w1 = &#123;&quot;Rose&quot;,25&#125;;\n    //结构体指针\n    WP wp1 = &amp;w1;\n\n    printf(&quot;%s,%d\\n&quot;,wp1-&gt;name,wp1-&gt;age);\n    getchar(); \n&#125;十、结构体函数指针成员#include &lt;Windows.h&gt;\n//Girl 结构体类似于Java中的类，name和age类似于属性，sayHi类似于方法\nstruct Girl&#123;\n    char *name;\n    int age;\n    //函数指针\n    void(*sayHi) (char*);\n&#125;;\n\nvoid sayHi(char* text)&#123;\n    MessageBoxA(0,text,&quot;title&quot;,0);\n&#125;\n\nvoid main()&#123;\n   struct Girl g1;\n   g1.name = &quot;Lucy&quot;;\n   g1.age = 18;\n   g1.sayHi = sayHi;\n\n   g1.sayHi(&quot;Hello!&quot;);\n   getchar(); \n&#125;取别名的写法\n#include &lt;Windows.h&gt;\n//Girl 结构体类似于Java中的类，name和age类似于属性，sayHi类似于方法\ntypedef struct Girl&#123;\n    char *name;\n    int age;\n    //函数指针\n    void(*sayHi) (char*);\n&#125;Girl;\n\n//Girl结构体指针取别名\ntypedef Girl* GirlP;\n\nvoid sayHi(char* text)&#123;\n    MessageBoxA(0,text,&quot;title&quot;,0);\n&#125;\n\nvoid main()&#123;\n   struct Girl g1 = &#123;&quot;Lucy&quot;,19,sayHi&#125;;\n   GirlP gp1 = &amp;g1;\n   gp1-&gt;sayHi(&quot;Hello&quot;);\n   getchar(); \n&#125;","categories":["C"],"tags":["C"]},{"title":"（三）C语言之字符串与字符串函数","url":"https://blog.onestravel.cn/20180901/e2a7f021c8fb/","content":"（三）C语言之字符串与字符串函数字符串与字符串函数1. 字符串\n使用字符数组存储字符串,\\0 表示结束符，字符串可以被修改\n\nvoid main()&#123;\n    char str[] = &#123;&#39;c&#39;,&#39;h&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;,&#39;\\0&#39;&#125;;\n    //char str[6] = &#123;&#39;c&#39;,&#39;h&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;&#125;;\n    //char str[10] = &quot;china&quot;;\n    printf(&quot;%s\\n&quot;,str);\n    str[0] = &#39;s&#39;;\n    printf(&quot;%s\\n&quot;,str);\n    printf(&quot;%#x\\n&quot;,str);\n    getchar();\n&#125;输出结果为：\nchina\nshina\n0xd9fd64\n使用字符指针存储字符串，字符串不能被修改\n\nvoid main()&#123;\n    //内存连续排列\n    char *str = &quot;how are you?&quot;;\n    //字符串不能被修改\n    //str[0] = &quot;w&quot;;\n    //\n    // str += 1;\n    //*str = &#39;y&#39;;\n    printf(&quot;%s\\n&quot;,str);\n    printf(&quot;%#x\\n&quot;,str);\n    getchar();\n&#125;输出结果为：\nhow are you?\n0x967be4\n2. 字符串相关函数在线API文档\n\nstrcat 字符串拼接函数\nstrcpy 字符串复制函数\n\nvoid main()&#123;\n    char dest[50];\n    char *a = &quot;china&quot;;\n    char *b = &quot; is powerful!&quot;\n    //将数组a复制到数组dest中\n    strcpy(dest,a);\n    //将数组b拼接到数组dest上\n    strcat(dest,b);\n    printf(&quot;%s\\n&quot;,dest);\n\n    getchar();\n&#125;输出结果为：\nchina is powerful!\nstrchr 在一个字符串中查找给定字符的第1个匹配的之处\n\n void main(void)&#123;\n    char *haystack = &quot;I want go to USA!&quot;;\n    char *needle = &quot;to&quot;;\n    //U元素的指针\n\n    char* p = strstr(haystack, needle);\n    if (p)&#123;\n        printf(&quot;索引位置：%d\\n&quot;, p - haystack);\n    &#125;\n    else&#123;\n        printf(&quot;没有找到&quot;);\n    &#125;\n\n    system(&quot;pause&quot;);\n&#125;\nstrcmp 比较字符串  \nstrcmpi 比较字符串，忽略大小写\n\nvoid main(void)&#123;\n    char *str1 = &quot;abc&quot;;\n    char *str2 = &quot;ABC&quot;;\n    //int r = strcmpi(str1, str2);\n    int r = _strcmpi(str1, str2);\n    printf(&quot;%d\\n&quot;,r);\n    //str1 &gt; str2\n    if (r &gt; 0)&#123;\n        printf(&quot;str1 大于str2\\n&quot;);\n    &#125;\n    else if (r == 0)&#123;\n        printf(&quot;str1 等于str2\\n&quot;);\n    &#125;\n    //str1 &lt; str2\n    else if (r &lt; 0)&#123;\n        printf(&quot;str1 小于str2\\n&quot;);\n    &#125;\n\n    system(&quot;pause&quot;);\n&#125;\nstrset 把字符串s中的所有字符都设置成字符c\n\nvoid main(void)&#123;\n    char str[] = &quot;internet change the world!&quot;;\n    _strset(str,&#39;w&#39;);\n    printf(&quot;%s\\n&quot;,str);\n    system(&quot;pause&quot;);\n&#125;\nstrrev 把字符串s的所有字符的顺序颠倒过来\n\nvoid main(void)&#123;\n    char str[] = &quot;internet change the world!&quot;;\n    _strrev(str);\n    printf(&quot;%s\\n&quot;, str);\n    system(&quot;pause&quot;);\n&#125;\natoi 字符串转为int类型\natol()：将字符串转换为长整型值\n\nvoid main(void)&#123;\n    char* str = &quot;a78&quot;;\n    //int r = atoi(str);    \n    printf(&quot;%d\\n&quot;, r);\n\n    system(&quot;pause&quot;);\n&#125;\n\nstrtod:字符串转为double类型\n\nvoid main(void)&#123;\n    char* str = &quot;77b8b&quot;;\n    char** p = NULL;\n    //char* p = str + 2;\n    //参数说明：str为要转换的字符串，endstr 为第一个不能转换的字符的指针\n    double r = strtod(str,p);\n    printf(&quot;%lf\\n&quot;, r);\n    printf(&quot;%#x\\n&quot;, p);\n\n    system(&quot;pause&quot;);\n&#125;\nstrupr转换为大写\n\nvoid main(void)&#123;\n    char str[] = &quot;CHINA motherland!&quot;;\n    _strupr(str);\n    printf(&quot;%s\\n&quot;,str);\n    system(&quot;pause&quot;);\n&#125;\n转换为小写\n\nvoid mystrlwr(char str[],int len)&#123;\n    int i = 0;\n    for (; i &lt; len; i++)&#123;\n        //A-Z 字母 a-Z\n        if (str[i] &gt;= &#39;A&#39; &amp;&amp; str[i] &lt;= &#39;Z&#39;)&#123;\n            str[i] = str[i]-&#39;A&#39; + &#39;a&#39;;\n        &#125;\n    &#125;    \n\n&#125;\n","categories":["C"],"tags":["C"]},{"title":"（二）C语言之动态内存分配","url":"https://blog.onestravel.cn/20180828/1725ed3880a1/","content":"（二）C语言之动态内存分配一、静态内存分配定义是指定分配的内存长度就是静态内存分配，是在栈内存中分配int a[1024];二、C语言内存分配1、栈区（stack）\nwindows下，栈内存分配2M(确定的常数)，超出了限制，提示 stack overflow 错误；\n栈区中内存自动分配，自动释放\n\n2、堆区（heap）\n程序员手动分配内存，手动释放内存，占有操作系统80%的内存,通过malloc进行内存分配\n\n//在堆内存分配40M内存\n//malloc参数是字节\n//malloc 返回值是 void * ,是任意类型的指针\nint* p = malloc(1024 * 1024 * 10 * sizeof(int));\n//释放分配的内存\nfree(p);\n\ncalloc \nrealloc 重新分配内存\n创建一个数组，动态指定数组的大小（在程序运行过程中，可以随意的开辟指定大小的内存，以供使用；相对于Java中的集合）\n\nvoid main()&#123;\n    //静态内存分配创建数组，数组的大小是固定的\n    //int a[10];\n\n    int len;\n    printf(&quot;输入数组的长度：&quot;);\n    scanf(&quot;%d&quot;,&amp;len);\n    //开辟内存\n    int* p = malloc(len * sizeof(int));\n    //p是数组的首地址\n    //给数组元素赋值（使用这一块刚刚开辟出来的内存区域）\n    int i = 0;\n    for(;i &lt; len; i++)&#123;\n        p[i] = rand() % 100;\n        printf(&quot;%d,%#x\\n&quot;,p[i],&amp;p[i]);\n    &#125;\n    //扩大刚刚分配的内存空间\n    printf(&quot;重新输入数组的长度：&quot;);\n    scanf(&quot;%d&quot;,&amp;len);\n    //参数说明\n    //1：原来的内存的指针\n    //2：内存扩大之后的总大小\n    int* p2 = realloc(p,sizeof(int) * len);\n    //重新赋值\n    i = 0;\n    for(;i &lt; len; i++)&#123;\n        p2[i] = rand() % 200;\n        printf(&quot;%d,%#x\\n&quot;,p2[i],&amp;p2[i]);\n    &#125;\n    //手动释放内存\n    if(p != NULL)&#123;\n        free(p);\n        p = NULL;\n    &#125;\n     if(p2 != NULL)&#123;\n        free(p2);\n        p2 = NULL;\n    &#125;\n\n    getchar();\n&#125;输入结果为（参考）：\n输入数组的长度：6\n41,0x202330\n67,0x202334\n34,0x202338\n0,0x20233c\n69,0x202340\n24,0x2023443、全局区或静态区4、字符常量5、程序代码区三、静态内存分配与动态内存分配的区别静态内存分配，分配内存大小是固定的；容易出现以下问题：\n很容易超出栈内存的最大值\n为了防止内存不够用会开辟更多的内存，容易浪费\n\n动态内存分配，在程序运行过程中，动态指定需要使用的内存大小，手动释放，释放之后这些内存还可以被重新使用；容易出现以下问题：\n缩小，缩小的那部分数据会丢失\n扩大（连续的），如果当前内存段后面有需要的内存空间，直接扩展这段内存空间，realloc返回原指针；如果当前内存段后面的空闲字节不够，那么久使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据释放，返回新的内存地址；如果申请失败，返回NULL,原来的指针任然有效。\n\n四、内存分配的几个注意细节\n不能多次释放\n释放完之后，给指针置为NULL\n内存泄漏（p重载赋值之后，在free，并没有真正释放内存） \n\n","categories":["C"],"tags":["C"]},{"title":"（一）C语言之基本数据类型、输入输出、指针","url":"https://blog.onestravel.cn/20180825/f5d7f2233743/","content":"（一）C语言之基本数据类型、输入输出、指针一、基本数据类型1、头文件引入头文件,在头文件中只有函数的声明，在编译的时候会去找到函数的实现\n#include &lt;stdio.h&gt;2、基本数据类型(1)、基本数据类型所使用的输出占位符\n\n\n数据类型\n占位符\n\n\n\nshort\n%d\n\n\nint\n%d\n\n\nlong\n%d\n\n\nfloat\n%f\n\n\ndouble\n%lf\n\n\nchar\n%c\n\n\n十六进制\n%x\n\n\n八进制\n%o\n\n\n字符串\n%s\n\n\n##### (2)、基本数据类型所占字节数\n\n\n\n数据类型\n字节数\n\n\n—\n—\n\n\nshort\n2\n\n\nint\n4\n\n\nlong\n8\n\n\nfloat\n4\n\n\ndouble\n8\n\n\nchar\n1\n\n\n二、输入输出函数1、输入函数scanf(“%d”,&amp;i);控制台输入，&amp; 为取地址符\n2、输出函数printf(“i的值为：%d\\n”,i);控制台输输出函数\n#include &lt;stdio.h&gt;\n\nvoid main()&#123;\n    int i;\n    printf(&quot;请输入一个整数：&quot;);\n    //赋值\n    scanf(&quot;%d&quot;,&amp;i);\n    //打印\n    printf(&quot;i的值为：%d\\n&quot;,i);\n    system(&quot;pause&quot;);\n&#125;三、指针1、指针的定义指针存储的是变量的内存地址变量名就是对内存空间中一段数据的抽象内存地址就是系统给数据分配的编号#include &lt;stdio.h&gt;\nvoid main()&#123;\n    int i = 0;\n    //指针变量,p 的值就是 i 这个变量的内存地址\n    int* p = &amp;i;\n    printf(&quot;内存地址为：%#X\\n&quot;,p);\n    system(&quot;pause&quot;);\n&#125;控制台输出\n内存地址为：0X8FF764指针类型的定义：在基本数据类型后加*如：\n    float f = 88.6;\n    //创建一个float类型的指针\n    float* fp = &amp;f;    或\n    float f = 88.6;\n    //创建一个float类型的指针\n    float *fp = &amp;f;    通过指针修改变量的值void main()&#123;\n    int i = 90;\n    //创建一个int类型的指针变量\n    int *p = &amp;i;\n    printf(&quot;i的值为：%d\\n&quot;,i);\n    // p 代表变量 i 的内存地址\n    // *p 代表 p 这个内存地址上的数据\n    *p = 210;\n    printf(&quot;i的值为：%d\\n&quot;,i);\n    system(&quot;pause&quot;);\n&#125;控制台输出：\ni的值为：90\ni的值为：210指针变量的内存地址说明：\n2、指针的类型指针有类型，地址没有类型；地址只是开始的位置，类型是指明读取到什么位置结束\n3、NULL空指针指针为NULL的指针，默认值为0,默认内存地址访问0x000000操作系统不允许\nvoid main()&#123;\n    int i = 9;\n    int *p = NULL;\n\n    //空指针的默认值为0\n    printf(&quot;%#X\\n&quot;,p);\n    //访问内存地址0x000000操作系统不允许\n    printf(&quot;%d\\n&quot;,*p);\n    getchar();\n&#125;4、多级指针指针保存的是变量的地址，保存的这个变量还可以是一个指针变量void main()&#123;\n    int a = 50;\n    //p1上保存的是 a 的地址\n    int* p1 = &amp;a;\n    //p2上保存的是 p1 的地址\n    int** p2 = &amp;p1;\n    printf(&quot;p1d的值为：%#x,p2的值为：%#x\\n&quot;,p1,p2);\n    //通过p2 改变a的值\n    **p2 = 90;\n    printf(&quot;a的值为：%d\\n&quot;,a);\n    getchar();\n&#125;输出结果为：\np1d的值为：0xcffa9c,p2的值为：0xcffa90\na的值为：905、指针运算指针的运算，一般在数组遍历时才有意义，基于数据在内存中线性排列的方式void main()&#123;\n    //数组在内存中连续存储\n    int ids[] = &#123;78,90,23,65,19&#125;;\n    //数组的变量名：ids就是数组的首地址\n    printf(&quot;%#x\\n&quot;,ids);\n    printf(&quot;%#x\\n&quot;,&amp;ids);\n    printf(&quot;%#x\\n&quot;,&amp;ids[0]);\n    //指针变量\n    int *p = ids;\n    printf(&quot;%d\\n&quot;,*p);\n    //指针的加法\n    p++;//指针向前移动sizeof(数据类型)个字节\n    printf(&quot;%d\\n&quot;,*p);\n    getchar();\n&#125;输出结果为：\n0x7dfaa0\n0x7dfaa0\n0x7dfaa0\n78\n90通过指针给数组赋值void main()&#123;\n    int uids[5];\n    int* p = uids;\n    ////高级写法\n    //int i = 0;\n    //for (;i &lt; 5; i++)&#123;\n    //    uids[i] = i;\n    //&#125;\n    //早些版本的写法\n    int i = 0;\n    for(; p &lt; uids + 5 ; p++)&#123;\n        *p = i;\n        i++;\n    &#125;\n\n&#125;6、函数指针函数指针的定义：\n[函数返回值类型]([函数指针的名称])([函数的参数列表])#include &lt;Windows.h&gt;\nvoid msg(char* title,char* content)&#123;\n    MessageBox(0,content,title,0);\n&#125;\n\nvoid main()&#123;\n    //msg();\n    //函数指针\n    void(*fun_p)(char* title,char* content) = msg;\n    fun_p(&quot;消息标题&quot;,&quot;消息内容&quot;);\n    getchar();\n&#125;","categories":["C"],"tags":["C"]},{"title":"使用 Hexo 来优化管理自己的博客","url":"https://blog.onestravel.cn/20180620/761acc2958f8/","content":"前言上一篇博客Github+域名搭建个人主页（个人博客） 写了如何使用GitHub+域名搭建一个静态的个人主页，搭建好之后，就可以使用对应的域名来进行访问了，这篇博客主要是跟大家介绍使用Hexo对自己的个人博客进行优化，管理。\n准备工作Git客户端 ： 下载安装，一路默认安装即可NodeJs: 下载安装 ,一路默认安装即可验证NodeJs 是否安装成功Microsoft Windows [版本 10.0.17134.472]\n(c) 2018 Microsoft Corporation。保留所有权利。\n\nC:\\Users\\Administrator&gt;node -v\nv11.6.0\n\nC:\\Users\\Administrator&gt;npm -v\n6.5.0-next.0安装参考  Hexo官方文档 \n安装 Hexo如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\n$ npm install -g hexo-cli初始化 Hexo安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\n$ hexo init &lt;folder&gt;\n$ cd &lt;folder&gt;\n$ npm install新建完成后，指定文件夹的目录如下：\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes_config.yml网站的 配置 信息，您可以在此配置大部分的参数。\npackage.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。\npackage.json\n\n&#123;\n &quot;name&quot;: &quot;hexo-site&quot;,\n &quot;version&quot;: &quot;0.0.0&quot;,\n &quot;private&quot;: true,\n &quot;hexo&quot;: &#123;\n &quot;version&quot;: &quot;&quot;\n &#125;,\n &quot;dependencies&quot;: &#123;\n &quot;hexo&quot;: &quot;^3.0.0&quot;,\n &quot;hexo-generator-archive&quot;: &quot;^0.1.0&quot;,\n &quot;hexo-generator-category&quot;: &quot;^0.1.0&quot;,\n &quot;hexo-generator-index&quot;: &quot;^0.1.0&quot;,\n &quot;hexo-generator-tag&quot;: &quot;^0.1.0&quot;,\n &quot;hexo-renderer-ejs&quot;: &quot;^0.1.0&quot;,\n &quot;hexo-renderer-stylus&quot;: &quot;^0.2.0&quot;,\n &quot;hexo-renderer-marked&quot;: &quot;^0.2.4&quot;,\n &quot;hexo-server&quot;: &quot;^0.1.2&quot;\n &#125;\n&#125;\n\nscaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。\nHexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。\nsource资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\nthemes主题 文件夹。Hexo 会根据主题来生成静态页面。\n配置您可以在 _config.yml 中修改大部分的配置。\n网站\n\n\n参数\n描述\n\n\n\ntitle\n网站标题\n\n\nsubtitle\n网站副标题\n\n\ndescription\n网站描述\n\n\nauthor\n您的名字\n\n\nlanguage\n网站使用的语言\n\n\ntimezone\n网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。\n\n\n其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。\n网址\n\n\n参数\n描述\n默认值\n\n\n\nurl\n网址\n\n\n\nroot\n网站根目录\n\n\n\npermalink\n文章的 永久链接 格式\n:year/:month/:day/:title/\n\n\npermalink_defaults\n永久链接中各部分的默认值\n\n\n\n\n网站存放在子目录\n如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。\n\n目录\n\n\n参数\n描述\n默认值\n\n\n\nsource_dir\n资源文件夹，这个文件夹用来存放内容。\nsource\n\n\npublic_dir\n公共文件夹，这个文件夹用于存放生成的站点文件。\npublic\n\n\ntag_dir\n标签文件夹\ntags\n\n\narchive_dir\n归档文件夹\narchives\n\n\ncategory_dir\n分类文件夹\ncategories\n\n\ncode_dir\nInclude code 文件夹\ndownloads/code\n\n\ni18n_dir\n国际化（i18n）文件夹\n:lang\n\n\nskip_render\n跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\n\n\n\n提示\n如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。\n\n文章\n\n\n参数\n描述\n默认值\n\n\n\nnew_post_name\n新文章的文件名称\n:title.md\n\n\ndefault_layout\n预设布局\npost\n\n\nauto_spacing\n在中文和英文之间加入空格\nfalse\n\n\ntitlecase\n把标题转换为 title case\nfalse\n\n\nexternal_link\n在新标签中打开链接\ntrue\n\n\nfilename_case\n把文件名称转换为 (1) 小写或 (2) 大写\n0\n\n\nrender_drafts\n显示草稿\nfalse\n\n\npost_asset_folder\n启动 Asset 文件夹\nfalse\n\n\nrelative_link\n把链接改为与根目录的相对位址\nfalse\n\n\nfuture\n显示未来的文章\ntrue\n\n\nhighlight\n代码块的设置\n\n\n\n\n相对地址\n默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。\n\n分类 &amp; 标签\n\n\n参数\n描述\n默认值\n\n\n\ndefault_category\n默认分类\nuncategorized\n\n\ncategory_map\n分类别名\n\n\n\ntag_map\n标签别名\n\n\n\n日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。\n\n\n\n参数\n描述\n默认值\n\n\n\ndate_format\n日期格式\nYYYY-MM-DD\n\n\ntime_format\n时间格式\nH:mm:ss\n\n\n分页\n\n\n参数\n描述\n默认值\n\n\n\nper_page\n每页显示的文章量 (0 = 关闭分页功能)\n10\n\n\npagination_dir\n分页目录\npage\n\n\n扩展\n\n\n参数\n描述\n\n\n\ntheme\n当前主题名称。值为false时禁用主题\n\n\ndeploy\n部署部分的设置\n\n\n选择主题在Hexo 主题中选择自己喜欢的主题，下载下来，解压之后，将主题的文件夹复制到 hexo 文件夹中的 theme 文件夹下 ；然后再hexo 根目录下更改_config.yml 文件中的 theme 的值\n例如：\ntheme: hexo-theme-matery要修改主题中的样式，可根据主题的说明文档 在 主题文件夹中的 _config.yml 文件中修改 或者修改对应的样式文件\nHexo 操作命令init新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。\n$ hexo init [folder]New新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。\n$ hexo new [layout] &lt;title&gt;\ngenerate生成静态文件。\n$ hexo generate\n\n\n选项\n描述\n\n\n\n-d,--deploy\n文件生成后立即部署网站\n\n\n-w,--watch\n监视文件变动\n\n\n该命令可以简写为\n$ hexo gpublish发表草稿。\n$ hexo publish [layout] &lt;filename&gt;server启动服务器。默认情况下，访问网址为： http://localhost:4000/。| 选项 | 描述 || — | — || -p, --port | 重设端口 || -s, --static | 只使用静态文件 || -l, --log | 启动日记记录，使用覆盖记录格式 |\n$ hexo serverdeploy部署网站。\n\n\n\n参数\n描述\n\n\n\n-g, --generate\n部署之前预先生成静态文件\n\n\n$ hexo deploy该命令可以简写为：\n$ hexo drender渲染文件。\n\n\n\n参数\n描述\n\n\n\n-o, --output\n设置输出路径\n\n\n$ hexo render &lt;file1&gt; [file2] ...migrate从其他博客系统 迁移内容。\n$ hexo migrate &lt;type&gt;clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。\n在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n$ hexo cleanlist列出网站资料。\n$ hexo list &lt;type&gt;version显示 Hexo 版本。\n$ hexo version选项安全模式在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。\n$ hexo --safe调试模式在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。\n$ hexo --debug简洁模式隐藏终端信息。\n$ hexo --silent自定义配置文件的路径自定义配置文件的路径，执行后将不再使用 _config.yml。\n$ hexo --config custom.yml显示草稿显示 source/_drafts 文件夹中的草稿文章。\n$ hexo --draft自定义 CWD自定义当前工作目录（Current working directory）的路径。\n$ hexo --cwd /path/to/cwd服务器Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用。\n$ npm install hexo-server --save安装完成后，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。\n$ hexo server如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下：\n$ hexo server -p 5000静态模式在静态模式下，服务器只处理 public 文件夹内的文件，而不会处理文件变动，在执行时，您应该先自行执行 hexo generate，此模式通常用于生产环境（production mode）下。\n$ hexo server -s自定义 IP服务器默认运行在 0.0.0.0，您可以覆盖默认的 IP 设置，如下：\n$ hexo server -i 192.168.1.1指定这个参数后，您就只能通过该IP才能访问站点。例如，对于一台使用无线网络的笔记本电脑，除了指向本机的127.0.0.1外，通常还有一个192.168.*.*的局域网IP，如果像上面那样使用-i参数，就不能用127.0.0.1来访问站点了。对于有公网IP的主机，如果您指定一个局域网IP作为-i参数的值，那么就无法通过公网来访问站点。\nPowPow 是一个 Mac 系统上的零配置 Rack 服务器，它也可以作为一个简单易用的静态文件服务器来使用。\n安装$ curl get.pow.cx | sh设置在 ~/.pow 文件夹建立链接（symlink）。\n$ cd ~/.pow\n$ ln -s /path/to/myapp您的网站将会在 http://myapp.dev 下运行，网址根据链接名称而定。\n生成文件使用 Hexo 生成静态文件快速而且简单。\n$ hexo generate监视文件变动Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。\n$ hexo generate --watch完成后部署您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。\n$ hexo generate --deploy\n$ hexo deploy --generate 简写\n 上面两个命令可以简写为\n$ hexo g -d\n$ hexo d -g部署Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。\n$ hexo deploy在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：\ndeploy:\n type: git您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。\ndeploy:\n- type: git\n repo:\n- type: heroku\n repo:\n缩进\nYAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。\n\nGit安装 hexo-deployer-git。\n$ npm install hexo-deployer-git --save修改配置。\ndeploy:\n type: git\n repo: &lt;repository url&gt;\n branch: [branch]\n message: [message]\n\n\n参数\n描述\n\n\n\nrepo\n库（Repository）地址\n\n\nbranch\n分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。\n\n\nmessage\n自定义提交信息 (默认为 Site updated: &#123;&#123; ('YYYY-MM-DD HH:mm:ss') &#125;&#125;)\n\n\nHeroku安装 hexo-deployer-heroku。\n$ npm install hexo-deployer-heroku --save修改配置。\ndeploy:\n type: heroku\n repo: &lt;repository url&gt;\n message: [message]\n\n\n参数\n描述\n\n\n\nrepo\nHeroku 库（Repository）地址\n\n\nmessage\n自定提交信息 (默认为 Site updated: &#123;&#123; ('YYYY-MM-DD HH:mm:ss') &#125;&#125;)\n\n\nRsync安装 hexo-deployer-rsync。\n$ npm install hexo-deployer-rsync --save修改配置。\ndeploy:\n type: rsync\n host: &lt;host&gt;\n user: &lt;user&gt;\n root: &lt;root&gt;\n port: [port]\n delete: [true|false]\n verbose: [true|false]\n ignore_errors: [true|false]\n\n\n参数\n描述\n默认值\n\n\n\nhost\n远程主机的地址\n\n\n\nuser\n使用者名称\n\n\n\nroot\n远程主机的根目录\n\n\n\nport\n端口\n22\n\n\ndelete\n删除远程主机上的旧文件\ntrue\n\n\nverbose\n显示调试信息\ntrue\n\n\nignore_errors\n忽略错误\nfalse\n\n\n\nrsync部署模块的工作方式\n需要注意的是，要求您提供的实际上是一个能通过SSH登陆远程主机的Linux用户。Hexo会自动处理关于rsync使用的一切操作。因此，您需要在远程主机上为您的Hexo站点建立一个用户，并允许其通过SSH登陆。不过，这里的port，的确是指rsync监听的端口，请确保防火墙打开了该端口。\n\nOpenShift安装 hexo-deployer-openshift。\n$ npm install hexo-deployer-openshift --save修改配置。\ndeploy:\n type: openshift\n repo: &lt;repository url&gt;\n message: [message]\n\n\n参数\n描述\n\n\n\nrepo\nOpenShift 库（Repository）地址\n\n\nmessage\n自定提交信息 (默认为 Site updated: &#123;&#123; ('YYYY-MM-DD HH:mm:ss') &#125;&#125;)\n\n\nFTPSync安装 hexo-deployer-ftpsync。\n$ npm install hexo-deployer-ftpsync --save修改配置。\ndeploy:\n type: ftpsync\n host: &lt;host&gt;\n user: &lt;user&gt;\n pass: &lt;password&gt;\n remote: [remote]\n port: [port]\n ignore: [ignore]\n connections: [connections]\n verbose: [true|false]\n\n\n参数\n描述\n默认值\n\n\n\nhost\n远程主机的地址\n\n\n\nuser\n使用者名称\n\n\n\npass\n密码\n\n\n\nremote\n远程主机的根目录\n/\n\n\nport\n端口\n21\n\n\nignore\n忽略的文件或目录\n\n\n\nconnections\n使用的连接数\n1\n\n\nverbose\n显示调试信息\nfalse\n\n\n\nFTP部署可能出现的问题\n您可能需要预先通过其他方式将所有文件上传到远程主机中。否则初次使用ftpsync插件就可能出现报错。另外，由于FTP协议的特征，它每传送一个文件就需要一次握手，相对速度较慢。\n\n其他方法Hexo 生成的所有文件都放在 public 文件夹中，您可以将它们复制到您喜欢的地方。\n","categories":["前端H5"],"tags":["html","Github","Hexo"]},{"title":"CentOS 7 环境配置","url":"https://blog.onestravel.cn/20180619/d3a4b8217e2f/","content":"CentOS 7 环境配置一、Centos7如何修改ssh默认端口221. 修改 sshd_config 端口\n编辑sshd_config 配置文件\n$ vi /etc/ssh/sshd_config\n\n取消 #Port 22 的注释，在下一行添加你需要修改的新端口 Port 10022。（这里不删除 22 端口是为了防止修改后新端口无法访问，造成无法用 ssh 连接服务器。）\nPort 22  \nPort 10022  \n\n\n修改保存 sshd_config 文件按下esc 退出编辑模式，输入 :wq，保存修改并退出\n\n重启 sshd 服务\n$  systemctl restart sshd\n2. 配置防火墙 firewalld\n启用防火墙：\n$ systemctl enable firewalld\n$ systemctl start firewalld\n\n查看防火墙状态\n\n\n$ systemctl status firewalld\n● firewalld.service - firewalld - dynamic firewall daemon\n   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled)\n   Active: active (running) since 二 2016-12-20 02:12:59 CST; 1 day 13h ago\n Main PID: 10379 (firewalld)\n   CGroup: /system.slice/firewalld.service\n           └─10379 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid\n$ firewall-cmd --state\nrunning  \n\n查看防火墙当前「默认」和「激活」zone（区域）：\n\n$ firewall-cmd --get-default-zone\npublic  \n$ firewall-cmd --get-active-zones\npublic  \n  interfaces: eth0 eth1\n若没有激活区域的话，要执行下面的命令。\n\n激活 public 区域，增加网卡接口：\n\n$ firewall-cmd --set-default-zone=public\n$ firewall-cmd --zone=public --add-interface=eth0\nsuccess  \n$ firewall-cmd --zone=public --add-interface=eth1\nsuccess  \n *新增防火墙规则，开放 10022/TCP 端口：\n# 以防新端口不生效，先把 22 端口暴露\n$ firewall-cmd --permanent --zone=public --add-port=22/tcp\n$ firewall-cmd --permanent --zone=public --add-port=10022/tcp\nsuccess  \n# 重载防火墙\n$ firewall-cmd --reload\n# 查看暴露端口规则\n$ firewall-cmd --permanent --list-port\n\n443/tcp 80/tcp 22/tcp 10022/tcp  \n$ firewall-cmd --zone=public --list-all\npublic (default, active)  \n  interfaces: eth0 eth1\n  sources:\n  services: dhcpv6-client ssh\n  ports: 443/tcp 80/tcp 22/tcp 10022/tcp\n  masquerade: no\n  forward-ports:\n  icmp-blocks:\n  rich rules:\n\n退出 ssh 会话后，再用新的端口连接：\n\n$ ssh -p 10022 root@example.cn\n\n3.  打开 SELinux 端口 SELinux 全称 Security Enhanced Linux (安全强化 Linux)，是 MAC (Mandatory Access Control，强制访问控制系统)的一个实现，目的在于明确的指明某个进程可以访问哪些资源(文件、网络端口等)。\n对于 ssh，SELinux 默认只允许 22 端口，我们可以用 SELinux 管理配置工具 semanage，来修改 ssh 可访问的端口。\n安装 semanage 工具\n$ yum provides semanage\n$ yum -y install policycoreutils-python\n** 打开ssh 10022 端口**\n# 为 ssh 添加新的允许端口\n$ semanage port -a -t ssh_port_t -p tcp 10022\n# 查看当前 SELinux 允许的端口\n$ semanage port -l | grep ssh\nssh_port_t                     tcp      10022, 22  \n\n错误处理\n当 SELINUX 配置为禁用状态时，使用 semanage 会报错提示无法读取 policy 文件：\n\n修改 /etc/selinux/config 配置，启用 SELinux：\n$ vi /etc/selinux/config\nSELINUX=permissive  \n# 重启服务器\n$ init 6\n# 重启后查看 SELinux 状态\n$ sestatus\n# if it shows disable, you can run\n$ load_policy -qi\n检查SELINUX配置\n$ semanage port -a -t ssh_port_t -p tcp 10022\n$ semanage port -l | grep ssh\nssh_port_t                     tcp      10022, 22  \n# 重启 ssh 服务\nsystemctl restart sshd \n######*注：semange 不能禁用 ssh 的 22 端口：\n$ semanage port -d -t ssh_port_t -p tcp 22\nValueError: 在策略中定义了端口 tcp/22，无法删除。\n\n二、新建组和用户【组的操作】1、新建组 example\n使用groupadd 命令添加组用法：groupadd [选项] 组选项:\n-f, --force        如果组已经存在则成功退出\n          并且如果 GID 已经存在则取消 -g\n-g, --gid GID                 为新组使用 GID\n-h, --help                    显示此帮助信息并推出\n-K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值\n-o, --non-unique              允许创建有重复 GID 的组\n-p, --password PASSWORD       为新组使用此加密过的密码\n-r, --system                  创建一个系统账户\n-R, --root CHROOT_DIR         chroot 到的目录\n\n\nexample：\n# groupadd -g [组的ID] [组名]\n$ groupadd -g 10005 example\n2、删除组 example\n使用 groupdel 命令删除组用法：groupdel [选项] 组选项:\n-h, --help                    显示此帮助信息并推出\n-R, --root CHROOT_DIR         chroot 到的目录\n\n\nexample：\n# groupdel [组名]\n$ groupdel example\n\n删除组 example\n\n\n使用 groupdel 命令删除组用法：groupdel [选项] 组选项:\n-h, --help                    显示此帮助信息并推出\n-R, --root CHROOT_DIR         chroot 到的目录\n\n\nexample：\n# groupdel [组名]\n$ groupdel example\n3、修改组信息 example ，将组example 的id 更改为 10006 ，名称更改为 exampleGroup\n使用 groupmod 来修改组信息\n\n用法：groupmod [选项] 组\n选项:\n  -g, --gid GID                 将组 ID 改为 GID\n  -h, --help                    显示此帮助信息并推出\n  -n, --new-name NEW_GROUP      改名为 NEW_GROUP\n  -o, --non-unique              允许使用重复的 GID\n  -p, --password PASSWORD    将密码更改为(加密过的) PASSWORD\n  -R, --root CHROOT_DIR         chroot 到的目录\nexample:\n# groupmod -g [组ID] [组名]\n$ groupmod -g 10006 example\n\n# groupmod -n [新组名] [组名]\ngroupmod -n exampleGroup example\n【用户的操作】1、新建用户 example\n使用adduser 命令来新建用户用法：adduser [选项] 登录adduser -D\nadduser -D [选项]选项：\n-b, --base-dir BASE_DIR    新账户的主目录的基目录\n-c, --comment COMMENT         新账户的 GECOS 字段\n-d, --home-dir HOME_DIR       新账户的主目录\n-D, --defaults        显示或更改默认的 useradd 配置\n-e, --expiredate EXPIRE_DATE  新账户的过期日期\n-f, --inactive INACTIVE       新账户的密码不活动期\n-g, --gid GROUP        新账户主组的名称或 ID\n-G, --groups GROUPS    新账户的附加组列表\n-h, --help                    显示此帮助信息并推出\n-k, --skel SKEL_DIR    使用此目录作为骨架目录\n-K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值\n-l, --no-log-init    不要将此用户添加到最近登录和登录失败数据库\n-m, --create-home    创建用户的主目录\n-M, --no-create-home        不创建用户的主目录\n-N, --no-user-group    不创建同名的组\n-o, --non-unique        允许使用重复的 UID 创建用户\n-p, --password PASSWORD        加密后的新账户密码\n-r, --system                  创建一个系统账户\n-R, --root CHROOT_DIR         chroot 到的目录\n-s, --shell SHELL        新账户的登录 shell\n-u, --uid UID            新账户的用户 ID\n-U, --user-group        创建与用户同名的组\n-Z, --selinux-user SEUSER        为 SELinux 用户映射使用指定 SEUSER\n\n\nexample: 新建用户 example  ,指定用户id 为10010\n# adduser -u [用户ID] [用户名]\n$ adduser -u 10010 example\n\n# 查看新创建的用户\n$ id example\nuid=10010(example) gid=10010(example) 组=10010(example)\n\n2、为新建的用户设置密码 passwd [新建用户名]\n使用passwd [新建用户名] 命令来设置新用户密码\n\n直接输入passwd，回车，修改的是当前用户的密码\nexample:\n$ passwd example\n更改用户 example 的密码 。\n新的 密码：\n无效的密码： 密码包含用户名在某些地方\n重新输入新的 密码：\npasswd：所有的身份验证令牌已经成功更新。\n在设置密码的时候，会进行验证密码是否包含用户名，是否含有特殊字符，大小写字母和数字，会有相应的提示，但是继续输入，也是可以设置成功的。\n3、删除用户 example\n使用 userdel 命令来删除用户用法：userdel [选项] 登录\n\n选项：\n  -f, --force                   force some actions that would fail otherwise\n                                e.g. removal of user still logged in\n                                or files, even if not owned by the user\n  -h, --help                    显示此帮助信息并推出\n  -r, --remove                  删除主目录和邮件池\n  -R, --root CHROOT_DIR         chroot 到的目录\n  -Z, --selinux-user            为用户删除所有的 SELinux 用户映射\n\nexample: 删除用户 example  \n# userdel [用户名]\n$ userdel  example\n\n# 查看用户example\n$ id example\nid: example: no such user\n\n4、修改用户 example 为 exampleUser\n使用 usermod 命令来修改用户信息用法：usermod [选项] 登录\n\n选项：\n  -c, --comment 注释            GECOS 字段的新值\n  -d, --home HOME_DIR           用户的新主目录\n  -e, --expiredate EXPIRE_DATE  设定帐户过期的日期为 EXPIRE_DATE\n  -f, --inactive INACTIVE       过期 INACTIVE 天数后，设定密码为失效状态\n  -g, --gid GROUP               强制使用 GROUP 为新主组\n  -G, --groups GROUPS           新的附加组列表 GROUPS\n  -a, --append GROUP            将用户追加至上边 -G 中提到的附加组中，\n                                并不从其它组中删除此用户\n  -h, --help                    显示此帮助信息并推出\n  -l, --login LOGIN             新的登录名称\n  -L, --lock                    锁定用户帐号\n  -m, --move-home               将家目录内容移至新位置 (仅于 -d 一起使用)\n  -o, --non-unique              允许使用重复的(非唯一的) UID\n  -p, --password PASSWORD       将加密过的密码 (PASSWORD) 设为新密码\n  -R, --root CHROOT_DIR         chroot 到的目录\n  -s, --shell SHELL             该用户帐号的新登录 shell\n  -u, --uid UID                 用户帐号的新 UID\n  -U, --unlock                  解锁用户帐号\n  -Z, --selinux-user  SEUSER       用户账户的新 SELinux 用户映射\n\n\nexample: 修改用户 example 为 exampleUser  ,更改组为 exampleGroup\n# usermod -u  [用户ID] [用户名]\n$ usermod -u 10006 example\n\n# 查看用户example\n$ id example\nuid=10006(example) gid=10010(example) 组=10010(example)\n\n# usermod -g  [组ID] [用户名]\n$ usermod -u 10006 example\n\n# 查看用户example\n$ id example\nuid=10006(example) gid=10006(exampleGroup) 组=10006(exampleGroup)\n\n# usermod -l  [新用户名] [用户名]\n$ usermod -l exampleUser example\n\n# 查看用户exampleUser\n$ id exampleUser\nuid=10006(exampleUser) gid=10006(exampleGroup) 组=10006(exampleGroup)\n\n","categories":["Linux"],"tags":["Linux","centos"]},{"title":"在Linux上配置Jenkins自动化构建Android项目的环境 ---- Jenkins自动化部署学习笔记（五）","url":"https://blog.onestravel.cn/20180615/2ffd39bdffc1/","content":"在Linux上配置Jenkins自动化构建Android项目的环境前言&emsp;&emsp;之前写了一些在 Windows 系统上安装配置 Jenkins 环境，创建自动化构建项目的一些博客，今天来跟大家介绍一下在 Linux 系统下配置Jenkins自动化构建Android项目的环境，下面就来具体操作一下吧：\n一 、sdk安装1. 下载sdk for linux$ wget https://dl.google.com/android/android-sdk_r24.4.1-linux.tgz2. 解压Android SDK$ tar -zvxf android-sdk_r24.4.1-linux.tgz3. 配置环境变量在文件/etc/profile末端添加如下两行：\nexport ANDROID_HOME=/usr/local/android-sdk-linux\nexport PATH=$ANDROID_HOME/tools:$PATHandroid-sdk-linux是你解压后的文件名，tools一定要这样写，是里面文件夹的名称\n执行命令文件立马生效\n$ source /etc/profile4.安装所有包$ android update sdk --no-ui或者查看序列号\n$ android list sdk --all结果:\n   1- Android SDK Tools, revision 24.1.2\n   2- Android SDK Platform-tools, revision 22\n   3- Android SDK Build-tools, revision 22.0.1\n   4- Android SDK Build-tools, revision 22 (Obsolete)\n   5- Android SDK Build-tools, revision 21.1.2\n   6- Android SDK Build-tools, revision 21.1.1 (Obsolete)\n   7- Android SDK Build-tools, revision 21.1 (Obsolete)\n   8- Android SDK Build-tools, revision 21.0.2 (Obsolete)\n   9- Android SDK Build-tools, revision 21.0.1 (Obsolete)\n  10- Android SDK Build-tools, revision 21 (Obsolete)\n  11- Android SDK Build-tools, revision 20\n  12- Android SDK Build-tools, revision 19.1\n  13- Android SDK Build-tools, revision 19.0.3 (Obsolete)\n  14- Android SDK Build-tools, revision 19.0.2 (Obsolete)\n  15- Android SDK Build-tools, revision 19.0.1 (Obsolete)\n  16- Android SDK Build-tools, revision 19 (Obsolete)\n  17- Android SDK Build-tools, revision 18.1.1 (Obsolete)\n  18- Android SDK Build-tools, revision 18.1 (Obsolete)\n  19- Android SDK Build-tools, revision 18.0.1 (Obsolete)\n  20- Android SDK Build-tools, revision 17 (Obsolete)\n  21- Documentation for Android SDK, API 22, revision 1\n  22- SDK Platform Android 5.1.1, API 22, revision 2\n  23- SDK Platform Android 5.0.1, API 21, revision 2\n  24- SDK Platform Android 4.4W.2, API 20, revision 2\n  25- SDK Platform Android 4.4.2, API 19, revision 4\n  26- SDK Platform Android 4.3.1, API 18, revision 3\n  27- SDK Platform Android 4.2.2, API 17, revision 3按序列号安装\n$ android update sdk -u --all --filter 1,2,3,5,11,12,22,23,24,25,26,27,28,29,88,89二 、gradle安装1. 下载gradle$ wget https://downloads.gradle.org/distributions/gradle-4.4.1-all.zip2. 解压gradle$ unzp gradle-4.4.1-all.zip3. 设置环境变量3.1.简要配置export GRADLE_HOME=/usr/gradle/gradle-4.4.1\nexport PATH=$PATH:$GRADLE_HOME$ echo $GRADLE_HOME输出：\n/usr/gradle/gradle-4.4.1$ echo $PATH输出：\n/usr/lib64/qt-3.3/bin:/usr/java/jdk1.8.0_151/bin:/usr/gradle/gradle-4.4.1/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin这种设置环境变量虽方便，但安装路径会在机器重启以后会消失。需进行以下步骤设置：\n3.2.持久配置3.2.1.添加执行配置文件$ vi /etc/profile.d/gradle.sh添加以下内容：\nGRADLE_HOME=/usr/gradle/gradle-4.4.1\nPATH=$GRADLE_HOME/bin:$PATH\nexport PATH GRADLE_HOME3.2.2.添加权限$ chmod +x /etc/profile.d/gradle.sh3.2.3.设置环境变量永久有效$ source /etc/profile.d/gradle.sh检测版本：\n$ gradle -v输出：\n\n------------------------------------------------------------\nGradle 4.4.1\n------------------------------------------------------------\n\nBuild time:   2017-12-20 15:45:23 UTC\nRevision:     10ed9dc355dc39f6307cc98fbd8cea314bdd381c\n\nGroovy:       2.4.12\nAnt:          Apache Ant(TM) version 1.9.9 compiled on February 2 2017\nJVM:          1.8.0_151 (Oracle Corporation 25.151-b12)\nOS:           Linux 2.6.32-573.el6.x86_64 amd64\n三 、新建项目 在Linux上新建项目与在windows系统上搭建的Jenkins 创建项目的方法是一样的，只需要将对应的 windows 系统路径更改为 Linux 系统路径即可。\n附：Linux 系统下移动文件命令 # 定义当前时间\n# today=`date &quot;+%Y%m%d%H%M%S&quot;` \ntoday=`date +&quot;%Y%m%d&quot;`\n# 工作空间目录\nspace=/opt/datas/android/newEcoClinic\n# apk文件目录\napkDir=$space/app/build/outputs/apk\n# 共享文件夹挂载的文件目录\nshareDir=./windows\n# apk要放置的目标文件夹\ntargetDir=AndroidApk/jenkinsBuildApks/newEcoClinic\n# 定义开发apk文件路径\ndevPath=$shareDir/$targetDir/dev/$today\n# 定义测试apk文件路径\ntestPath=$shareDir/$targetDir/test/$today\n# 定义正式apk文件路径\nreleasePath=$shareDir/$targetDir/release/$today\n# 创建文件夹\nmkdir -p $shareDir\n# 将共享文件夹挂载到创建好的文件夹上\nsudo mount -t cifs -o username=&#39;tech&#39;,password=&#39;!qaz2wsx3edc&#39; //192.168.22.156/tech $shareDir\n# 创建开发APK文件夹\nmkdir -p  $devPath\n# 创建测试APK文件夹\nmkdir -p  $testPath\n# 创建正式APK文件夹\nmkdir -p  $releasePath\n# 复制开发apk到开发APK文件夹\ncp $apkDir/*dev*.apk $devPath\n# 复制测试apk到测试APK文件夹\ncp $apkDir/*test*.apk $testPath\n# 复制正式apk到正式APK文件夹\ncp $apkDir/*release*.apk $releasePath\n# 取消挂载\nsudo umount $shareDir\n# 删除源目录的jar文件\n# find $space/app/build/outputs/apk/* -name &#39;*.jar&#39;|xargs rm -rf\n# 删除无用的文件\nrm -rf  $space/app/build四 、邮件通知邮件通知配置与Windows 环境下的Jenkins系统配置方法一样。\n请参考 :  配置项目构建完成后邮件通知—- Jenkins自动化部署学习笔记（四）\n","categories":["Jenkins"],"tags":["Jenkins","自动化部署"]},{"title":"IDEA创建类注释模板和方法注释模板","url":"https://blog.onestravel.cn/20180615/b72ede3db7b8/","content":"IDEA 创建类注释模板和方法注释模板前言&emsp;&emsp;在使用Idea的时候，它的注释模板很简单，不够详细；所有大多数开发者都想设置一个比较详细的注释模板，我现在把我了解的创建类注释模板和方法注释模板的操作记录下来，分享给大家我们需要定义的注释模板如下：类注释模板：\n\n方法注释模板：\n\n一、设置IDEA 中的类注释模板1、找到File Header.java文件File -&gt; Settings -&gt; Editor -&gt; File and Code Templates -&gt; Files选择Class , Interface ，Enum 等等，我们都可以看到，在右侧区域中，在public class 上面，都有一行 #parse(“File Header.java”) ，\n这句代码是引入了File Header.java文件，作为我们创建的Class Interface ,Enum 等文件的注释，那么这个类在哪呢，我们可以看到，在 Files 右侧，有一个 Includes 选项，在这里，我们可以定义各种的模板，在需要的地方去引入这个模板，这里已经在类文件中引入了File Header.java 模板，那我们就更改这个模板成为我们想设置成的样子\n2、定义类文件注释模板\n/**\n * @ClassName $&#123;NAME&#125;.java\n * @author admin\n * @version 1.0.0\n * @Description TODO\n * @createTime $&#123;YEAR&#125;年$&#123;MONTH&#125;月$&#123;DAY&#125;日 $&#123;HOUR&#125;:$&#123;MINUTE&#125;:00\n */3、类文件变量说明*注： ${PACKAGE_NAME} :  包路径 ${NAME} :  文件名${USER} ： 主机用户名${DATE} ： 系统当前日期，格式为：yyyy/mm/dd${TIME} ： 系统当前时间 格式为：HH:mm${YEAR}：当前年${MONTH}：当前月${MONTH_NAME_SHORT} ： 月份名称简写；如：Jan, Feb, etc.${MONTH_NAME_FULL} ： 月份名称全拼；如：January, February.${DAY} ：当前天${DAY_NAME_SHORT} ：星期简写；如：Mon, Tue, etc.${DAY_NAME_FULL}：星期全写；如：Mon, Tue, etc.${HOUR} ： 当前小时${MINUTE} ：当前分钟${PROJECT_NAME} ： 项目名称\n二、定义方法注释模板1、创建自定义方法模板组File -&gt; Settings -&gt; Editor -&gt; Live Templates\n在Live Templates 右侧点击+号，添加一个Templates Group，命名为 methodTemplates\n\n2、在刚刚创建的 methodTemplates 下创建一个 Live Templates ，如下\n\n1）、在位置1处： 输入模板的简写码\n 在位置2处：输入模板的描述\n 在位置3处： 输入方法注释模板样式，可变变量要用 **$变量名$** 来表示，如：$param$；   若不设置成如此的变量名，位置4不可点击，模板如下：\n/**\n* @title $title$\n* @description $description$\n* @author admin $param$\n* @updateTime $date$ $TIME$ $return$\n* @throws $throws$\n*/    点击位置4处：可编辑定义的变量的值，如下：\n\n\n变量param 为方法的参数变量，需要根据方法的参数多少进行变化；变量 return 为返回值类型，也要根据方法的返回值进行变化，所一要自行设置该方法，设置的代码如下，复制粘贴即可：\nparam  :\ngroovyScript(&quot;def result=&#39;&#39;; def stop=false; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#39;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#39;, &#39;&#39;).split(&#39;,&#39;).toList(); if (params.size()==1 &amp;&amp; (params[0]==null || params[0]==&#39;null&#39; || params[0]==&#39;&#39;)) &#123; stop=true; &#125;; if(!stop) &#123; for(i=0; i &lt; params.size(); i++) &#123;result +=((i==0) ? &#39;\\\\r\\\\n&#39; : &#39;&#39;) + ((i &lt; params.size() - 1) ? &#39; * @param: &#39; + params[i] + &#39;\\\\r\\\\n&#39; : &#39; * @param: &#39; + params[i] + &#39;&#39;)&#125;; &#125;; return result;&quot;, methodParameters())return  :\ngroovyScript(&quot;def result=&#39;&#39;; def data=\\&quot;$&#123;_1&#125;\\&quot;; def stop=false; if(data==null || data==&#39;null&#39; || data==&#39;&#39; || data==&#39;void&#39; ) &#123; stop=true; &#125;; if(!stop) &#123; result += &#39;\\\\r\\\\n&#39; + &#39; * @return: &#39; + data; &#125;; return result;&quot;, methodReturnType())\n2）、在位置3下方，点击选择该模板应用的范围，可选Everywhere 表示任何位置都可添加该注释\n\n改位置首次为 define\n修改时为change\n\n3）、点击options 中的 Expand with 可选择该模板配合使用的快捷键，如 Tab键，Space 空格键 ， Enter 回车键 等等；\n\n如在这里设置的模板关键词为 *  ，配合使用快捷键为Tab键\n3、方法模板使用说明则在方法中输入 * ，在按下Tab 键，即可按照模板生成注释。\n\n大功告成，仅供参考！\n","categories":["DevTools"],"tags":["DevTools","Intellij IDEA","Android studio"]},{"title":"配置项目构建完成后邮件通知---- Jenkins自动化部署学习笔记（四）","url":"https://blog.onestravel.cn/20180612/c91460048783/","content":"配置项目构建完成后邮件通知—- Jenkins自动化部署学习笔记（四）前言&emsp;&emsp;在之前的文章中，跟大家介绍了配置Jenkins程序， 使用Jenkins 进行自动化构建，构建成功后的文件移动，这篇文章，我们来说说构建任务失败怎么邮件通知相关人员。\n一、全局邮件配置\n在Jenkins 的主视图下点击系统管理 -&gt; 系统设置 ，在系统设置中找到 Jenkins Location 区块，这这一区块中，有两个需要配置的\n\n\nA：Jenkins URL   值为自己Jenkins所在主机IP或者有效域名+Jenkins端口号\nB：系统管理员邮件地址 值为Jenkins系统的邮件地址，用于发送邮件，进行通知，必须填写，否则无法发送邮件\n\n\n在系统设置下方找到邮件通知区块，填写邮件配置信息 \n\nSMPT 服务器：你的邮箱服务器的SMTP服务地址如：阿里云企业邮箱，为：smtp@[你的域名]        腾讯企业邮箱为：smtp.exmail.qq.com默认邮件后缀，写自己企业邮箱的后缀，qq邮箱写@qq.com，163邮箱写@163.com勾选使用SMTP验证：用户名：输入Jenkins系统邮件地址，如service@***.com密码：输入 Jenkins系统邮件用户对应的密码\n然后我们可以勾选  “通过发送测试邮件测试配置”来验证邮件配置是否正确输入测试需要接受通知邮件的地址，点击右下侧的 Test configuration，若邮件地址下方出现 Email was successfuly sent 表示邮件配置成功。点击保存，我们去进行项目配置\n二 、 在任务列表中，点击需要配置的构建任务，进入构建任务中，点击左侧的配置，进行邮件的配置在页面最底处，我们看到有一个区块，叫构建后操作，点击 添加构建后操作步骤 ，选择Email-Notifiction,在Recipients 中输入收件人地址\nJenkins会在发生某个重要事件时向指定的收件人发送电子邮件。\n\n每一次失败的构建触发一个新的电子邮件。\n失败（或不稳定）构建后的成功构建会触发新电子邮件，表明危机已经结束。\n成功构建后的不稳定构建会触发新电子邮件，表明存在回归。\n除非进行配置，否则每个不稳定的构建都会触发新的电子邮件，表明回归仍然存在。\n\n对于那些不稳定构建是常态的懒惰项目，请取消选中“每次不稳定构建都发送电子邮件”。至此，构建失败发送邮件通知配置完成。可自行验证\n","categories":["Jenkins"],"tags":["Jenkins","自动化部署","邮件通知"]},{"title":"配置项目构建完成后文件移动---- Jenkins自动化部署学习笔记（三）","url":"https://blog.onestravel.cn/20180530/c46d9cf90557/","content":"配置项目构建完成后文件移动—- Jenkins自动化部署学习笔记（三）前言&emsp;&emsp;在前两篇文章中，跟大家分享了在 Windows 系统上安装 Jenkins 和使用 Jenkins 进行 Android 项目的编译打包；相信可能会有人疑问，打包完成之后，我需要将 apk 文件放入指定位置怎么办。\n&emsp;&emsp;其实，Jenkins 功能很强大，它可以配置在打包完成之后将你所需的文件拷贝至目标路径，亦可配置在打包完成后（成功/失败），邮件通知相关人员。下面详细介绍：\n一、将打好的包移动至指定目录\n我在自己的电脑上安装 Jenkins ，进行项目构建，并且想要将每次构建的包存入到E盘的AndroidApk目录下： 在上篇文章中，我们说到了，在配置构建任务时，有一个构建的选项，我们可以增加相应的操作来实现；\n（1）、在构建选项区域下方，点击 增加构建步骤 ，选择Execete Windows batch commond添加一个构建任务（务必在Invoke Gradle script 任务下方）\n\n\n\n\n（2）、在增加的 Windows 命令框中，需要配置相应的操作命令来实现移动的功能\n\n其实移动的功能，我们可以看作是将源文件复制到目标目录，然后将源文件删除。在打包时我们可以根据不同的环境配置不同的包，比如debug.apk ，release.apk；我们也可以使用命令，将不同环境的包，移动至不同的目录下：\n复制文件，我们需要源文件目录和目标文件目录：此项目中：源文件目录：D:\\jenkinsSpace\\example\\app\\build\\outputs\\apk\\目标文件目录：E:\\AndroidApk在AndroidApk下，我们再创建不同的文件夹，如：devApk 和 releaseApk故，命令如下：  \n\ncopy D:\\jenkinsSpace\\example\\app\\build\\outputs\\apk\\*debug*.apk E:\\AndroidApk\\devApk\ncopy D:\\jenkinsSpace\\example\\app\\build\\outputs\\apk\\*release*.apk E:\\AndroidApk\\releaseApk\nrmdir /s /q D:\\jenkinsSpace\\example\\可以看到，这个总共有三条命令\n第一条命令：是将源文件目录下的名称包含 debug ，后缀名为  .apk  的文件复制到 E:\\AndroidApk\\devApk  目录下\n第二条命令：是将源文件目录下的名称包含 release ，后缀名为  .apk  的文件复制到 E:\\AndroidApk\\releaseApk  目录下\n第三条命令：是将 Jenkins 构建该项目的工作空间进行清空（删除工作空间目录及子文件）\n\n（3）、配置好之后，我们点击保存， 进行立即构建，构建结果如下：\n\n\n我们可以看到，在位置 1 处：项目构建成功，耗时 1分56秒\n位置 2 处 ：执行了复制名称包含 debug ，后缀名为 .apk 的文件的命令，成功\n位置 3 处 ：执行了复制名称包含 release ，后缀名为 .apk 的文件的命令，失败\n位置 4 处：执行了删除工作空间的命令，成功\n位置 5 处：退出执行命令，exit\n位置 3 出执行失败的原因是，我们再配置项目构建任务的时候，只是写了 clean assembleDebug 这两个命令，进行项目clean 和debug构建，我们将这个命令更改为clean build，就会构建所有配置的渠道包。\n\n我们有时候需要将打好的apk 移动至共享文件夹，方便大家使用获取安装，这时候，我们只需要在执行复制命令前增加一行命令，将共享文件夹目录映射到本地盘符：\n\n命令如下：net use [盘符] \\[ip][共享文件夹] “[password]” /user:”[userName]”\n% 将共享文件夹映射为盘符 Y:%\nnet use Y: \\\\192.168.22.156\\tech  &quot;!qaz2wsx3edc&quot; /user:&quot;tech&quot;在此命令下，我们更改上面的命令中的盘符为共享文件夹盘符，就可将apk移动至共享文件夹了\ncopy D:\\jenkinsSpace\\example\\app\\build\\outputs\\apk\\*debug*.apk Y:\\AndroidApk\\devApk\ncopy D:\\jenkinsSpace\\example\\app\\build\\outputs\\apk\\*release*.apk Y:\\AndroidApk\\releaseApk\nrmdir /s /q D:\\jenkinsSpace\\example\\\n我们也可以定义一个bat文件，放在主机上，让Jenkins任务去调用执行这个bat文件，来复制/移动文件 bat文件内容如下：% 将共享文件夹映射为盘符 Y:%\nnet use Y: \\\\192.168.22.156\\tech  &quot;!qaz2wsx3edc&quot; /user:&quot;tech&quot;\n\n\n% 配置工作空间目录变量%set “spaceDir=D:\\jenkinsSpace\\example”\n% 配置目标文件夹目录变量%set “targetDir=Y:\\AndroidApk\\jekinsBuildApks”\n% 定义当前日期字符串的变量如 20180505%set “dateStr=%date:0,4%%date:5,2%%date:~8,2%”\n% 定义Apk源文件目录%set “resourceDir=%spaceDir%\\app\\build\\outputs\\apk”\n% 根据日期分别定义在dev,test , release 下需要创建的文件夹目录%set “devPath=%targetDir%\\dev%dateStr%”set “testPath=%targetDir%\\test%dateStr%”set “releasePath=%targetDir%\\release%dateStr%”\n% 创建文件夹%md %devPath%md %testPath%md %releasePath%\n% 复制apk到目标文件夹%copy %resourceDir%*dev.apk %devPath%copy %resourceDir%*test.apk %testPath%copy %resourceDir%*release*.apk %releasePath%\n% 强制删除工作空间目录%rd/s/q %spaceDir%\\\n该文件中 **%%** 之间的内容为**注释内容**\n然后我们将该bat文件命名为copyApp.bat ,放置在D:\\bat\\目录下，\n我们再Jenkins 任务中做如下配置call D:\\bat\\copyApp.batexit 0```\ncall D:\\bat\\copyApp.bat 是调用执行bat文件，exit 0 是用来处理上面出现的因windows 命令执行错误导致Build FAILURE，Jenkins 任务根据cmd命令行返回是否为0来判断是否Build 成功，故只要exit 0,每次返回0，无论windows 命令执行成功与否，只要项目Build 成功了，整个任务就是成功的。至此项目移动至其他目录完成！\n上一篇：自动化构建Android项目 —- Jenkins自动化部署学习笔记（二）\n","categories":["Jenkins"],"tags":["Jenkins","自动化部署","文件移动"]},{"title":"自动化构建Android项目 ---- Jenkins自动化部署学习笔记（二）","url":"https://blog.onestravel.cn/20180522/06ca6f81dd4b/","content":"自动化构建Android项目 —- Jenkins自动化部署学习笔记（二）前言&emsp;&emsp;上篇文章跟大家分享了在Windows上安装Jenkins的方法，这篇文章来跟大家分享一下利用Jenkins自动化构建Android项目：\n一、所需准备：\nAndroid项目上传至版本管理平台，这里我准备了Github上的Android项目https://github.com/onestravel/WebView404Example.git\n配置Android SDK环境变量 参考上篇文章，我们进入   系统管理 -&gt; 系统设置  ，选择环境变量，进行增加 输入 键：ANDROID_HOME 输入 值：D:\\android\\sdk  SDK环境变量配置完成，点击保存。\n\n二、自动化构建配置1.我们再Jenkins网站，新建一个任务\n2.我们在新建任务界面，输入任务名称，选择任务类型，我们来选择构建一个自由风格的软件项目\n\n3.点击确定，进入任务配置界面，进行自动化构建的一些配置，包括任务设置，源码管理，构建触发器，构建环境，构建和构建后操作。\n\n(1)、配置自定义工作空间Jenkins构建默认使用的是Jenkins安装目录下的workspace，我们也可以更改为自定义的workspace，如下，在 General  板块右下方，点击高级 ，勾选使用自定义的工作空间，设置工作空间目录和显示名称。\n\n(2)、配置源码管理，这里我们选择Git，在Repository URL    输入框中输入Android项目存放的Git路径，Credentials，需要配置Git仓库访问的用户名和密码或者SSH验证，点击Add进行添加用户验证口令\n\n\n\n添加完用户验证口令后，我们在Credentials中选择这个验证口令，在Branches to build中更改需要自动打包的分支，这里采用默认分支master\n\n(3)、构建触发器，这里我们一般选择 Poll SCM 可以自定义构建触发，如：每日定时触发构建，提交时触发构建，这里采用每两分钟检查构建\n\n\n\n\n构建时间\n命令\n\n\n\n每 15分钟构建一次\nH/15 * * * *   或*/5 * * * *\n\n\n每天8点构建一次\n0 8 * * *\n\n\n每天8点~17点，两小时构建一次\n0 8-17/2 * * *\n\n\n周一到周五，8点~17点，两小时构建一次\n0 8-17/2 * * 1-5\n\n\n每月1号、15号各构建一次，除12月\nH H 1,15 1-11 *\n\n\n\n\n\n\n\n(4)、构建环境我们这里不用设置\n\n(5)、构建设置，点击增加构建步骤，选择Invoke Gradle Script，我们采用Gradle进行编译，选择完成之后，在增加的内容中，点击高级，展开构建配置界面\n\n\n在Invoke Gradle 的Gradle Version中选择我们上篇文章配置好的本地Gradle环境，采用本地环境进行编译在Task中，我们输入编译的命令，多命令用空格隔开，如果有配置渠道，我们可以设置打对应的渠道包，如：clean assembleDebug，或者 clean buildRoot build script 中输入我们的工作空间路径Build File 写项目的build.gradle文件名\n至此，我们自动化构建配置完成，点击保存按钮，保存配置。我们来点击立即构建，即可查看项目正在构建，点击Build History 中本次构建的时间上的小箭头（鼠标移上就会出现），点击控制台输出，即可实时查看编译日志\n\n三、项目构建中遇到的一些问题\nError: Some file crunching failed, see logs for details :app:mergeCeshiDebugResources** FAILED\n\n* What went wrong:\nExecution failed for task &#39;:app:mergeCeshiDebugResources&#39;.\n&gt; Error: Some file crunching failed, see logs for details\n\n* Try:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\n\n出现该问题主要是gradle 编译时的 build-cache 目录路径太长，导致 jenkins 无法识别该路径，才会出现此错误。\n如图所示，现在build-cache 目录是在 C:\\Windows\\System32\\config\\systemprofile.android\\build-cache 下，目录太长（深），导致运行时找不到文件\nC:\\Windows\\System32\\config\\systemprofile\\.android\\build-cache\\63e2e64e89749266e10d6160c2536dd981719789\\output\\res\\drawable-xhdpi-v4\\abc_ab_share_pack_mtrl_alpha.9.png解决此错误的方法，是在项目的gradle.properties 文件中增加 build-cache 目录，设置一个较短的目录\nandroid.buildCacheDir=D:/android-studio/build-cache\n\n如果我们的项目中有使用 google 服务，如：下图一\n\n\n这时候使用jenkins 自动化构建时，有可能会编译出错，找不到google()的服务，这是因为我们的gradle版本太低的缘故，在本文中，我们的gradle 版本使用的是3.3 的，页使用的google的服务，在编译时，出现了错误，错误信息如下：\n\n我们在Jenkins 中的  系统管理 -&gt; 全局系统设置中，重新添加高版本的Gradle 这里使用的是4.1 版本（本地）；\n配置完成之后，我们再本次构建任务中选用Gradle4.1进行编译该项目，则会编译通过。\n\n\n上一篇：在Windows系统上安装Jenkins —- Jenkins自动化部署学习笔记（一）\n下一篇：配置项目构建完成后文件移动—- Jenkins自动化部署学习笔记（三）\n","categories":["Jenkins"],"tags":["Jenkins","自动化部署","构建Android项目"]},{"title":"在Windows系统上安装Jenkins ---- Jenkins自动化部署学习笔记（一）","url":"https://blog.onestravel.cn/20180509/a6065fafcad9/","content":"在Windows系统上安装Jenkins —- Jenkins自动化部署学习笔记（一）前言&emsp;&emsp;之前一直想着学习一下Jenkins自动化部署，最近刚好有点时间，就利用这点时间来学习一下Jenkins自动化部署，做个笔记，既可以巩固自己的学习，也可以帮助更多的人了解Jenkins自动化部署。\n &emsp;&emsp;先从简单的开始，我们先用Windows系统来安装Jenkins，当然以后肯定会在Ubuntu上进行Jenkins安装配置的。\n一、安装前准备：1、JDK1.7，或者JDK1.8：​    Jdk下载地址如下：​        Windows  X86:  jdk-8u171-windows-i586.exe​        Windows  X64:  jdk-8u171-windows-x64.exe​        Linux X64：jdk-8u171-linux-x64.tar.gz\n2、Jenkins安装包：​        Jenkins for windows ：Jenkins-for-windows-installer\n二、安装Jdk，配置环境变量1、安装jdk&emsp;&emsp;上面准备好的Jdk安装包，选择自己电脑系统适合的进行下载，一直默认安装就可以，也可以更改安装路径，最好jdk和jre路径一起改。\n\n\n2、配置环境变量&emsp;&emsp;安装好jdk之后，我们进行环境变量的配置：\n\n在「计算机」右键，选择「属性」，在弹出页面，选择「高级系统设置」，「环境变量」\n \n\n\n\n在环境变量弹出窗中点击「系统变量」下方的新建按钮，新建JAVA_HOME变量，值为刚安装的JDK路径，如我的JDK路径为：D:\\Program Files\\Java\\jdk1.8.0_162\n\n\n找到 Path 变量，没有的话就新建一个，不过一般都会有的 ，点击编辑，在path变量的最前面添加Jdk的路径为“ %JAVA_HOME%\\bin; ”\n\n\n\n\n找到classpath变量，没有的话，新建，增加classpath变量：%JAVA_HOME%\\lib;\n\n\n\n环境变量这就配置完成了，我们打开命令窗口，输入命令来验证是否配置合适：命令为：  java -version  //查看java版本号或  javac   \n\n\n\n三、安装Jenkins\nwindows双击下载的Jenkins安装包 Jenkins.msi ，进入安装模式，选择默认配置，安装完成之后，就会默认打开浏览器 http://localhost:8080,显示   Jenkins正在启动，请稍后… 这个过程需要一段时间，耐心等待启动完成 \n\n在安装过程中对自动生成密码，存储在Jenkins安装位置下的一个文件里，启动完成之后会到登录界面 \n\n在界面所示路径下，打开文件，复制密码，在管理员密码框输入密码，点击继续，等待系统初始化，出现自定义Jenkins界面，可以选择安装推荐的插件，括者选择需要的插件来安装，也可以不选择安装，直接点击右上角的X号关闭界面，以后可以通过插件管理器安装插件 \n\n\n4.这里选择插件来安装，选择之后点击下一步，进入如下安装界面，等待安装完成\n\n插件安装完成之后，进入创建第一个管理员用户界面，输入信息，点击保存并完成，添加第一个管理员 \n\n安装完成 ，点击开始使用Jenkins \n\n在Jenkins主界面点击系统管理，进入系统设置页面，选择全局工具配置 \n\n配置本地JDK全局环境，若有Git，Gradle，Ant ，Maven环境都可以在此配置，目前只配置JDK环境和Git环境如下： \n\n我们可以看到，目前Jenkins的访问路径还是http://localhost:8080/，如果想要更改Jenkins访问端口号，在Jenkins安装目录下打开jenkins.xml文件，更改端口号，然后再电脑的服务中找到Jenkins服务，进行重启，然后就可以使用新的端口访问Jenkins了 \n\n\n\n至此，Jenkins安装完成，若要使用Jenkins进行项目构建，请参考下面文章\n下一篇：自动化构建Android项目 —- Jenkins自动化部署学习笔记（二）\n","categories":["Jenkins"],"tags":["Jenkins","自动化部署"]},{"title":"从零开始-使用IntelliJ IDEA创建SpringBoot项目","url":"https://blog.onestravel.cn/20180509/1f4a362e23f9/","content":"从零开始-使用IntelliJ IDEA创建SpringBoot项目前言*注：此文章谨以记录学习过程，分享学习心得！\n刚刚开始了解SpringBoot框架，觉得很好用，觉得很有必要深入学习一下该框架，现在就来创建一个SpringBoot项目：\n新建项目1、在IDEA上新建一个Project​    在IDEA上新建一个Project，选择Spring Initializr,​      Project SDK 选择安装的JDK；​      Choose Initializr Service URL  选择默认（Default：https://start.spring.io）\n\n点击Next\n2、进行项目配置设置项目数组（group），项目标识（Artifact），Type选择一个Maven Project 表示是一个maven项目Version：项目版本号Name：项目名称Description：项目描述Package：项目包名\n\n点击Next 下一步\n3、选择项目模板我们来选择创建一个Web项目选择Spring Boot版本\n\n4、设置项目名称和项目路径设置完项目路径，和项目名称后，点击FInish，创建项目完成，需要进行项目构建，等一小会即可完成。\n5、创建完成，我们删除.mvn文件夹，mvnw文件和 mvnw.cmd文件\n6、maven配置的pom.xml文件我们来看一下maven配置的pom.xml文件，里面包含了SpringBoot项目运行所需的版本库\n\nSpringBoot运行所需库为：\n&lt;!-- SpringBoot项目的基础库文件--&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;&lt;!-- SpringBoot项目的基础库文件--&gt;\n    &lt;dependencies&gt;\n&lt;!-- web项目库--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n&lt;!-- 测试所需库--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;7、创建一个HelloServicepackage com.example.springbootdemo.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic interface HelloService &#123;\n    String sayHello();\n&#125;\n8、创建HelloService的实现类HelloServiceImpl，实现sayHello()方法，返回”Hello World!”package com.example.springbootdemo.service.impl;\n\nimport com.example.springbootdemo.service.HelloService;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class HelloServiceImpl implements HelloService &#123;\n    @Override\n    public String sayHello() &#123;\n        return &quot;Hello World!&quot;;\n    &#125;\n&#125;\n\n9、创建HelloController，调用HelloService实现类，打印”Hello World!”到浏览器package com.example.springbootdemo.controller;\n\nimport com.example.springbootdemo.service.HelloService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\n@RequestMapping(&quot;/&quot;)\npublic class HelloController &#123;\n    @Autowired\n    private HelloService helloService;\n\n    @RequestMapping(&quot;/hello&quot;)\n    @ResponseBody\n    public String helloWorld()&#123;\n        return helloService.sayHello();\n    &#125;\n&#125;\n10、见证奇迹的时刻，我们来运行一下所建项目，看能不能跟我们预期一样，在浏览器输入访问地址http://localhost:8080/hello就可以看到Hello World!至此，学习创建一个SpringBoot项目就完成了。\n源码查看源码\n","categories":["SpringBoot"],"tags":["Intellij IDEA","Java","SpringBoot"]},{"title":"最全IDEA快捷键总结，大幅度提高工作效率","url":"https://blog.onestravel.cn/20180506/d52aed55d60c/","content":"最全IDEA快捷键总结，大幅度提高工作效率前言[](#刚开始使用 IDEA 的同学可能不熟悉 IDEA 的快捷键方式觉得没有eclipse的好用但是不建议把 IDEA 的keymap改成eclipse因为 IDEA 的快捷键设计有它独到的一面刚开始使用不习惯但是用多了就会觉得这些快捷键非常好用大幅度提高工作效率听说大神们合理使用IDEA快捷键可以实现全键盘操作呢-so不要固步自封尝试新事物吧你会发现一片新的天空海阔天空)刚开始使用 IDEA 的同学可能不熟悉idea的快捷键方式，觉得没有eclipse的好用，但是不建议把 IDEA 的keymap改成eclipse，因为 IDEA 的快捷键设计有它独到的一面，刚开始使用不习惯，但是用多了就会觉得这些快捷键非常好用，大幅度提高工作效率，听说大神们合理使用IDEA快捷键可以实现全键盘操作呢。so，不要固步自封，尝试新事物吧，你会发现一片新的天空（海阔天空）系统默认的快捷键1. 代码操作相关的快捷键\n\n\n快捷键\n功能\n\n\n\nCtrl+Y\n删除一行\n\n\nCtrl+W\n选择光标所在行或者代码片（光标在大括号上），连续按会有其他效果\n\n\nCtrl+Z\n撤销操作\n\n\nCtrl+Shift+Z\n恢复Ctrl+Z撤销的操作\n\n\nAlt+Enter\n引入类或提供给你选择的处理方法\n\n\nAlt+Shift+上下\n代码向上/下移动一行\n\n\nAlt+/\n复制上一个单词\n\n\nCtrl+Shift+Enter\n自动补全分号\n\n\nCtrl+Shift+V\n粘贴板历史\n\n\nCtrl+Alt+M\n将代码片段提取成为一个方法\n\n\nCtrl+G\n按行号和列号来查找\n\n\nCtrl+Alt+L\n格式化代码(和QQ快捷键冲突)\n\n\nCtrl+Shift+Space\n自动补全代码\n\n\nCtrl+空格\n代码提示\n\n\nCtrl+Alt+Space\n类名或接口名提示\n\n\n2. 查找相关的快捷键\n\n\n快捷键\n功能\n\n\n\nCtrl+F\n在本文件查找，可通过方向键移动选择，按Esc消失\n\n\nCtrl+R\n在本文件内查找/替换 ，可选择 replace 和 replaceAll，按Esc消失\n\n\nCtrl+Shift+F\n在制定路径/模块/工程内查找(全局查找)\n\n\nCtrl+N\n在本工程类查询某个类\n\n\nCtrl+Shift+N\n查询某个类(不限本工程)看源码很实用，比如我想看看jdk里面TreeMap这个类的代码，就可以用这个功能\n\n\n3.查看代码相关的快捷键\n\n\n快捷键\n功能\n\n\n\nCtrl+H\n查看一个类的继承关系\n\n\nCtrl+B\n查看一个类或者变量的申明\n\n\nAlt+F7\n查找一个属性或方法被谁调用\n\n\nAlt+上下\n跳到上/下一个方法(或属性)\n\n\nCtrl+上下\n上下滑屏但是不移动光标\n\n\nAlt+左右\n同时打开多个文件时切换代码视图，切换到另一个文件视图\n\n\nCtrl+Alt+ 左右\n返回至上次浏览的位置 非常实用，在多个文件代码中遨游的时候能够快速回到想去的位置\n\n\nCtrl+HOME/END\n光标跳转到第一行或最后一行\n\n\nALT+SHIFT+C\n最近修改的代码\n\n\n4.提示类的快捷键\n\n\n快捷键\n功能\n\n\n\nCtrl+Q\n显示注释文档\n\n\nCtrl+P\n查看函数参数（光标在方法参数的括号内）\n\n\nCtrl+J\n代码模板\n\n\n5.重构类快捷键\n\n\n快捷键\n功能\n\n\n\nAlt+Delete\n安全删除字段或方法\n\n\nCtrl+Alt+N\n去除一些多余的赋值过程或者函数 下面会单独演示\n\n\nShift+F6\n重命名类或者变量\n\n\n6.编译器相关快捷键\n\n\n快捷键\n功能\n\n\n\nAlt+F12\n打开命令行终端\n\n\nAlt+1\n打开工程结构\n\n\nAlt+7\n打开类结构\n\n\nAlt+9\n打开change\n\n\n7.debug快捷键\n\n\n快捷键\n介绍\n\n\n\nF7\n在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中\n\n\nF8\n在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内\n\n\nF9\n在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上\n\n\nAlt + F8\n在 Debug的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果\n\n\nCtrl + F8\n在 Debug模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点\n\n\nShift + F7\n在 Debug模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法\n\n\nShift + F8\n在 Debug 模式下，跳出，表现出来的效果跟 F9 一样\n\n\nCtrl + Shift + F8\n在 Debug 模式下，指定断点进入条件\n\n\nAlt + Shift + F7\n在Debug模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入\n\n\n8.启动相关\n\n\n快捷键\n介绍\n\n\n\nCtrl + F9\nBuild Project build整个项目\n\n\nShift + F9\n项目以Debug模式进行启动当前项目\n\n\nShift + F10\n项目以Run模式进行启动当前项目\n\n\nAlt + Shift + F10\n以Run模式进行启动某个项目 ，项目可选\n\n\nAlt + Shift + F10\n以Run模式进行启动某个项目 ，项目可选\n\n\nCtrl + F2\n停止当前运行的项目\n\n\nCtrl + Shift + F2\n停止后台进程\n\n\n9.版本控制操作相关\n\n\n快捷键\n介绍\n\n\n\nCtrl + ALT + A\n添加文件到版本控制\n\n\nCtrl + T\nupdate当前项目\n\n\nCtrl + K\n提交当前项目的文件改动\n\n\nCtrl + Shift + K\n将已经提交的版本push到远程服务器\n\n\nCtrl + ALT + Z\n撤销本地更改\n\n\nCtrl + ALT + Shift + D\n查看本地文件更改内容\n\n\n","categories":["DevTools"],"tags":["DevTools","Intellij IDEA","Android studio"]},{"title":"Github+域名搭建个人主页（个人博客）","url":"https://blog.onestravel.cn/20171020/220328c816aa/","content":"一、工作准备搭建个人主页需要做的准备工作有两个：\n1）、注册Github账号，注册Github账号是免费的，Github网站地址：https://github.com/github点击Sign up进入注册页面，总共有三步，按照步骤填入相应的信息即可。第一步：第二步：第三步：注册步骤完成之后点击邮箱验证后，就注册成功了。\n2）、注册（购买）域名二、创建个人主页的项目登录 GitHub 之后，在页面右上角点击 + 加号按钮，点击 New repository。由于是个人网站的项目，那么项目名就要按照规定来写规则是：\n*YOUR-GITHUB-USERNAME.github.io *\n比如我的Github用户名为onestravel1，那么项目名则应该是：onestravel1.github.io点击create Repository 就可以成功创建个人主页项目了。(http://upload-images.jianshu.io/upload_images/3236417-7249a4d0fabda949.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)点击Settings进入项目设置界面然后再 GitHub Pages 选项中点击 choose a theme 按钮，选择一个初始的个人主页样式选择一个样式的主页模板点击 select theme 按钮之后，就会自动生成初始化的页面主题，进入代码提交界面，填入提交日志，点击commit changes 提交代码。提交完成之后，就可以通过刚才创建时的项目名称进行访问了\n例如：https://onestravel1.github.io\n到此，利用Github创建个人主页的第一步就完成了。后面可以通过git工具把该项目clone到本地，然后进行页面的更改和优化后，提交到该仓库中。则编写的代码会立即生效。\n三、将域名映射到个人主页项目先在阿里云上进行域名的申请，域名申请过程就不在这里详述了。比如，我申请的域名为:onestravel.win，打开阿里云官网，找到控制台-&gt;域名管理\n在域名管理页面，可以看到域名列表，刚申请的域名，要记得进行实名认证，因为我申请的是.win的域名，这两天不能进行实名认证，所以显示未实名认证。在右侧可以看到 【续费|解析|管理】 的按钮，点击 解析 按钮，看到下面的界面点击添加解析\n可以看到，这里添加解析需要填写的信息，\n记录类型：默认选择 A主机记录：主机记录需要添加两个，分两次添加解析，分别为 www 和 @ ，不分先后，这次填 www解析线路：选择 默认TTL值：默认 10分钟，不需要改动记录值：这里需要个人主页项目的IP，那么问题来了，怎么拿到个人主页项目的IP呢，其实很简单，打开电脑终端（Mac）或者命令行（Windows），在命令行中输入命令 ping [个人主页项目原域名]，比如：ping onestravel1.github.io即可得到该项目对应的IP地址\n将得到的IP地址填入到记录值中\n然后点击确定，再添加一个解析，主机记录值填写 @ ，其他值都和上面一样，点击添加，即可得到两条解析记录如下：然后再个人主页项目中创建名为CNAME的文件，在文件中写入你申请的域名，点击保存到你的github的个人主页项目中，就可以通过域名来访问你的个人主页了！\n注：域名映射需要一定的时间，请等待10分钟左右的时间后，在访问你的个人主页！","categories":["前端H5"],"tags":["html","Github"]},{"title":"（源码）解决Android的WebView加载失败（404，500），显示的自定义视图","url":"https://blog.onestravel.cn/20170328/1c2e82f91ad4/","content":"（源码）解决Android的WebView加载失败（404，500），显示的自定义视图好多朋友会在Android开发过程中遇到使用WebView加载html页面出现404,500等错误页面，也有好多人想自定义这个错误页面，但是在6.0之前，大家觉得自定义错误页面就不好处理了；之前一直使用在WebView加载时，根据onReceivedError() 判断网页是否加载成功，然后做相应的操作，但是最后发现，在一些情况下，html页面加载失败了，onReceivedError()方法却并没有执行。最后进过努力，想出了一个比较笨，但是我又觉得比较有效的方法。下面来给大家简单说一说：不知道大家发现没有，在所有的加载错误的html页面中，html的标题title可能都会包含错误信息，比如说“error”，这样的话我们就可以在这个html的标题title上做文章了。 \n#1.先给大家说说怎么获取这个html的标题title \n###(1).Android应用开发的时候使用WebView这个组件的过程中可能会接触到WebViewClient与WebChromeClient，那么这两个类到底有什么不同呢WebViewClient主要帮助WebView处理各种通知、请求事件的，比如：\n    onLoadResource\n    onPageStart\n    onPageFinish\n    onReceiveError\n    onReceivedHttpAuthRequest\n\nWebChromeClient主要辅助WebView处理Javascript的对话框、网站图标、网站title、加载进度等比如\n    onCloseWindow(关闭WebView)\n    onCreateWindow()\n    onJsAlert (WebView上alert无效，需要定制WebChromeClient处理弹出)\n    onJsPrompt\n    onJsConfirm\n    onProgressChanged\n    onReceivedIcon\n    onReceivedTitle看上去他们有很多不同，实际使用的话，如果你的WebView只是用来处理一些html的页面内容，只用WebViewClient就行了，如果需要更丰富的处理效果，比如JS、进度条等，就要用到WebChromeClient。\n###(2).我们可以看到在 WebChromeClient 中有一个方法 onReceivedTitle() ，这个方法就是用来获取html页面的标题title的回调。\n#2.我们在 WebChromeClient 中的 onReceivedTitle() 方法里判断html页面的标题中是否含有 “error” ，如果有，则证明html加载失败，设置加载失败的标记，让在 WebViewClient 的完成是回调的 onPageFinish() 方法里显示自定义的加载失败的页面**\n代码如下：\nWebSettings webSettings = webView.getSettings();\n    //设置WebView属性，能够执行Javascript脚本\n    webSettings.setJavaScriptEnabled(true);\n    //设置可以访问文件\n    webSettings.setAllowFileAccess(true);\n    webSettings.setCacheMode(WebSettings.LOAD_NO_CACHE);\n\n\n    webView.setWebViewClient(new WebViewClient() &#123;\n        @Override\n        public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;\n            view.loadUrl(url);\n            return true;\n        &#125;\n\n        /**\n         * 网页页面开始加载的时候，执行的回调方法\n         * @param view\n         * @param url\n         * @param favicon\n         */\n        @Override\n        public void onPageStarted(WebView view, String url, Bitmap favicon) &#123;//网页页面开始加载的时候\n            emptyView.setEmptyView(EmptyView.EMPTY_LOADING);//初始化一个显示正在加载的视图\n            rl_detail.setVisibility(View.VISIBLE);\n            rl_detail.removeAllViews();\n            rl_detail.addView(emptyView);//在加载页面开始的时候显示一个正在加载的视图，\n            webView.setEnabled(false);// 当加载网页的时候将网页进行隐藏\n            ll_container_btn.setVisibility(View.GONE);\n            btn_collect.setVisibility(View.GONE);\n            super.onPageStarted(view, url, favicon);\n        &#125;\n\n        /**\n         * 网页加载结束的时候执行的回调方法\n         * @param view\n         * @param url\n         */\n        @Override\n        public void onPageFinished(WebView view, String url) &#123;//网页加载结束的时候\n            if (!loadError) &#123;//当网页加载成功的时候判断是否加载成功\n                rl_detail.setVisibility(View.GONE);//加载成功的话，则隐藏掉显示正在加载的视图，显示加载了网页内容的WebView\n                webView.setEnabled(true);\n                ll_container_btn.setVisibility(View.VISIBLE);\n                btn_collect.setVisibility(View.VISIBLE);\n            &#125; else &#123; //加载失败的话，初始化页面加载失败的图，然后替换正在加载的视图页面\n                rl_detail.removeAllViews();\n                emptyView.setEmptyView(EmptyView.EMPTY_EMPTY, &quot;您找的页面暂时走丢了...&quot;);\n                rl_detail.addView(emptyView);\n            &#125;\n\n        &#125;\n\n\n        /**\n         * 页面加载错误时执行的方法，但是在6.0以下，有时候会不执行这个方法\n         * @param view\n         * @param errorCode\n         * @param description\n         * @param failingUrl\n         */\n        @Override\n        public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) &#123;\n            super.onReceivedError(view, errorCode, description, failingUrl);\n            loadError = true;\n        &#125;\n\n\n    &#125;);\n\n    webView.setWebChromeClient(new WebChromeClient()&#123;\n        /**\n         * 当WebView加载之后，返回 HTML 页面的标题 Title\n         * @param view\n         * @param title\n         */\n        @Override\n        public void onReceivedTitle(WebView view, String title) &#123;\n            //判断标题 title 中是否包含有“error”字段，如果包含“error”字段，则设置加载失败，显示加载失败的视图\n          if(!TextUtils.isEmpty(title)&amp;&amp;title.toLowerCase().contains(&quot;error&quot;))&#123;\n              loadError = true;\n          &#125;\n        &#125;\n    &#125;);\n    webView.loadUrl(url);\n源码下载  源码下载\n","categories":["Android"],"tags":["Android","WebView","404"]},{"title":"Git的简单使用方法","url":"https://blog.onestravel.cn/20170328/8163f0d61598/","content":"Git的使用一、认识 Git1. Git 和替他版本控制系统的差异\n直接记录快照，非差异比较\n\ngit 和其他版本控制系统主要差别在于对 Git 对待数据的方法。其他版本控制系统（CVS、Subversion等等）大部分都是一文件变更列表的方式存储信息，将保存信息看做一组基本文件和每个文件跟随时间逐步积累的差异。\n\n\n\n\nGit 对待数据更像是快照流：将数据看做是对小型文件的一组快照。每次提交之后/保存项目状态时，对当时的全部文件制作一个快照，并保存这个快照的索引。如果文件没有修改，Git 就不再重新存储，只保留一个链接指向之前存的文件（更高效）。\n\n\n\n本地执行，更安全，更便捷\n\nGit 在克隆代码时，会将项目的完整历史保存在本地磁盘，与服务器形成分布式系统，增加项目的安全性。\nGit 在本地磁盘有完整的历史，则Git绝大多数操作都只需要访问本地文件和资源，不会需要网络上的项目信息，使用起来更加便捷（如在离线环境可以进行除了向远程提交修改的操作外的其他操作，等有网络后，在推送到远程服务器）。\n\n\n保证完整性\nGit 中所有数据在存储前都计算检验和（SHA-1散列机制，由40个十六进制字符组成的字符串），然后以检验和来引用，这意味着 Git 对更改文件任何内容或目录都可知。保证文件不会在不知情情况下损坏或丢失信息。\n\nGit 一般只添加数据\nGit 操作几乎只往数据库中增加数据。很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据（未提交的本地修改可能会丢失或弄乱修改内容）。\n\n\n2. Git 的工作区​    Git 有三种状态：已提交（committed）、已修改（modified）、和已暂存（staged）。已提交表示数据已安全保存在本地数据库中。已修改表示修改了文件，但还没保存到数据库中。已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n由此可引入 Git 的三个工作区域：\n\nGit 仓库：Git 用来保存项目的元数据和对象数据库的地方。\n工作目录：对项目的某个版本独立提起出来的内容。在磁盘上公使用或修改。\n暂存区域：\u0010时一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中，也被称作“索引”。\n\nGit 在三个区域的工作流程如下：\n\n在工作牡蛎中修改文件\n暂存文件，将文件的快照放入暂存区域\n提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。\n\n二、Git的配置1. Git 的下载安装Git下载地址：https://git-scm.com/download\n选择自己合适的版本进行下载\n下载之后选择路径，默认安装就好。\n2. 初次运行 Git 前的配置Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量，这些变量存储在三个不同的位置：\n\n/etc/gitconfig文件：包含系统上每一个用户及他们仓库的通用配置。如果使用带有--system选项的 git config 时，它会从此文件读写配置变量。\n\n~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。可以传递 --global 选项让 Git 读写此文件。\n\n当前使用仓库的 Git 目录中的 config 文件（``.git/config）：针对该仓库\n\n\n每一个级别覆盖上一个级别的配置，所以 ./git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量\n3. 用户信息配置安装完 Git 需要设置用户名和右键地址。这些信息会写入到后面的每一次提交中，不可更改：\n$ git config --global user.name \"Your UserName\"\n$ git config --global user.email \"Your Email Address\"\n\u0010&gt; 如果使用了 --global 选项，改命令只需要运行一次，之后在改系统上进行任何 Git 操作，都会使用这些信息。如果想针对特定项目使用不同的用户名和邮箱信息，则可以在那个项目目录下运行没有 --global 选项的命令来配置。\n4. 检查配置信息可以使用 git config --list 命令来列出所有 Git 当前能找到的配置。\n$ git config --list\ncolor.status=auto\ncolor.branch=auto\ncolor.interactive=auto\ncolor.diff=auto\n...\nuser.name=Your UserName\nuser.email=Your Email Address\n可以通过 git config &lt;key&gt; 来检查 Git 的某一项配置\n$ git config user.name\nYour UserName\n三、Git的使用1、获取 Git 仓库1.1 从服务器克隆一个现有的 Git 仓库​    如果已经在服务器存在了 Git 仓库，则使用 git clone 命令。这里和其他 VCS 系统不同的时 Git 克隆是将菜 Git 仓库服务器上的几乎所有数据复制到本地磁盘，而不是仅仅复制完成工作所需的文件。可以使用任何一个克隆下来的用户端来重建服务器上的仓库。\nGit 支持多种传输协议：https://协议， git:// 协议，SSH 传输协议（如：user@server:path/to/repo.git）。 \n*克隆仓库的命令格式是git clonr [url] *:\n$ git clone https://github.com/libgit2/libgit2\n\u0010\u0010\u0010这会在当前目录下创建一个名为”libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取的所有数据都会放入 .git 文件夹，然后从中读取最新版本的文件拷贝。进入这个新建的 “libgit2” 文件夹，会看到所有的项目文件已经在里面了，可以开始后续的开发和使用。\n如果想在克隆仓库的时候自定义本地仓库的名字，可以使用如下命令：\n$ git clone https://github.com/libgit2/libgit2 mylibgit\n这个上一个命令执行相同的操作，只是在本地创建的文件夹名字变为“mylibgit”\n1.2 在现有目录中初始化仓库如果打算在新的目录中使用 Git 进行项目管理，可有在改牡蛎下进行初始化仓库\n$ git init\n该命令将创建一个名为 .git 的文件夹，这个文件夹含有初始化的 Git 仓库中所有的必须文件。\n如果在一个已经存在的文件夹中初始化 Git 仓库，则应该跟踪这些文件并提交。\nGit 通过 git add 命令来实现对指定文件的跟踪，通过执行 git commit 命令来提交文件。\n$ git add test.txt\n$ git commit -m \"init project\"\n2. 仓库更新相关仓库文件在修改后，有两种状态：已跟踪（被纳入版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区）或未跟踪（除已跟踪文件外的所有文件，既不存在于上次快照记录中，也没放入暂存区）。\n2.1 检测当前文件状态使用 git status 命令来查看文件处于什么状态\n$ echo 'My Project' > README\n$ git status\nOn branch master\nUntracked files:\n  (use \"git add &lt;file>...\" to include in what will be committed)\n    README\nnothing added to commit but untracked files present (use \"git add\" to\ntrack)\n可以看到当前分支处于 master 分支，在当前仓库中发现一个未跟踪文件 “README”\n2.2 跟踪新文件使用git add 命令跟踪一个文件\n$ git add README \n此时在运行 git status 命令，可以看到 README 文件一杯跟踪，并处于暂存状态\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD &lt;file>...\" to unstage)\n    new file: README\n只要在 Changes to be committed 这行下面的，就说明是已暂存状态。\n\ngit add 命令使用文件或目录的路径作为参数，如果参数是目录路径，则改命令将递归跟踪改目录下所有文件。\n\n2.3 暂存已修改文件修改一个已经被跟踪的文件，如 test.txt ，然后运行git status 命令，会看到一下内容\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD &lt;file>...\" to unstage)\n\n    new file:   README\n\nChanges not staged for commit:\n  (use \"git add &lt;file>...\" to update what will be committed)\n  (use \"git checkout -- &lt;file>...\" to discard changes in working directory)\n\n    modified:   test.txt\n\n文件 test.txt 出现在 Changes not staged for commit 下面，说明已跟踪文件发生变化，但还没有放到暂存区，要暂存这次更新，需要运行git add命令。\n\ngit add是个多功能命令，可以用它开始跟踪文件；或者把已跟踪的文件放到暂存区；还能用于合并时将有冲突的文件标记位已解决状态等。\n\n接下来运行 git add 命令将 test.txt 文件放到暂存区，然后在看看 git status 的输出\n$ git add test.txt\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD &lt;file>...\" to unstage)\n\n    new file:   README\n    modified:   test.txt\n再次修改 test.txt 文件，然后运行 git status 命令查看文件状态：\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD &lt;file>...\" to unstage)\n\n    new file:   README\n    modified:   test.txt\n\nChanges not staged for commit:\n  (use \"git add &lt;file>...\" to update what will be committed)\n  (use \"git checkout -- &lt;file>...\" to discard changes in working directory)\n\n    modified:   test.txt\n\n可以看到 test.txt 文件同时出现在了暂存区和非暂存区。如果此时进行提交，test.txt 文件的版本是最后一次运行git add 命令时的那个版本，而不是运行git commit时，工作目录中的版本。所以在运行了git add 之后有做了修订的文件，需要重新运行git add把最新版本重新 暂存起来。\n2.4 文件状态预览git status 命令输出非常详细，如果使用git status -s命令或git status --short 命令，将得到一种更为紧凑的格式输出。\n$ git status -s           \nA  README\nMM test.txt\nA  version\n?? LICENSE.txt\n\n\n新添加的未跟踪文件前有 ??标记\n新添加到暂存区中的问价前有 A标记\n修改或的文件前面有 M标记\n出现在右边的 M 表示该问家被修改了但还没有放入暂存区\n出现在左边的 M 表示改文件被修改了并放入了暂存区。\n\n2.4 忽略文件我们总会有写文件无需纳入 Git 管理，也不希望它们总出现在未跟踪文件列表，通常都是些自动生成的文件，比如日志文件，或者在编译过程中创建的临时文件等。这种情况下，我们可以创建一个名为.gitignore的文件，列出要忽略的文件模式。\n$ cat .gitignore \n*.iml\n*.log\n*.tmp\n/build/\n\n第一,二，三行告诉 Git 忽略所有以 .iml，以.log,以.tmp结尾的文件\n第四行告诉Git 忽略build文件夹中的所有文件\n\n文件.gitignore的格式规范如下：\n\n所有空行或者以#开头的行都会被 Git 忽略\n可以使用标准的 glob 模式匹配\n匹配模式可以以 / 开头房子递归\n匹配模式可以以 / 结尾指定目录\n要忽略指定模式以外的文件或目录，可以在模式前加上 ! 取反。\n\n\n所谓 glob 模式是指 shell 所使用的简化了的正则表达式。\n\n* 匹配零个或多个任意字符\n[abc] 匹配任何一个列在方括号中的字符（要么匹配一个a，要么匹配一个 b,要么匹配一个 c）\n[0-9] 在方括号中使用短划线分隔两个字符，表示在这两个字符范围内的都可以匹配。\n? 只匹配一个任意字符\na/**/z 使用两个 型号表示匹配任意中间目录\n\n\n2.5 查看已暂存和未暂存的修改如果git status命令输出过于模糊，想知道具体修改了深地方，可以用git diff 命令。\n$ git diff\ndiff --git a/test.txt b/test.txt\nindex 9c9852f..bb08ffe 100644\n--- a/test.txt\n+++ b/test.txt\n@@ -1,3 +1,6 @@\n This is test file\n\n modified\n+\n+\n+modefied  two\n此命令比较的是工作目录中当前暂存文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。\n若要查看已暂存的将要添加到下移提交的内容里，可以用git diff --cached命令。（Git 1.6.1及更高版本允许使用git diff --staged,效果相同。）\n$ git diff --staged\ndiff --git a/README b/README\nnew file mode 100644\nindex 0000000..cd19876\n--- /dev/null\n+++ b/README\n@@ -0,0 +1 @@\n+My Project-\ndiff --git a/test.txt b/test.txt\nindex 9915fa7..9c9852f 100644\n--- a/test.txt\n+++ b/test.txt\n@@ -1 +1,3 @@\n-This is test file-\n+This is test file\n+\n+modified\ndiff --git a/version b/version\nnew file mode 100644\nindex 0000000..6029d7f\n--- /dev/null\n+++ b/version\n@@ -0,0 +1,2 @@\n+version: 1.0.0\n+code: 100\n2.6 提交更新在提交更新之前，需要确认一下是否还有什么修改过的文件或者新建的文件没有git add 过，否则提交的时候不会记录这些没暂存起来的变化。这些修改过的文件只保留在本地磁盘。\n$ git commit\n这种方式会启动文本编辑器以便输入本次提交的说明。\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# On branch master\n# Changes to be committed:\n#       new file:   README\n#       modified:   test.txt\n#       new file:   version\n#\n# Changes not staged for commit:\n#       modified:   test.txt\n#\n# Untracked files:\n#       .gitignore\n#       LICENSE.txt\n#\n~\".git/COMMIT_EDITMSG\" 17L, 358C\n可以看到，默认的提交消息包含最后一次运行git status 的输出，放在注释行里。另外开头还有一空行，用于输入提交说明。退出编辑器时，Git 会丢掉注释行，用输入的提交福袋信息生成一次提交。\n也可以在 commit 命令后添加 -m选项，将提交信息语命令放在同一行。\n$ git commit -m\"update text.txt; add README,version File\"\n[master ba93592] update text.txt; add README,version File\n 3 files changed, 6 insertions(+), 1 deletion(-)\n create mode 100644 README\n create mode 100644 version\n可以看到，在提交的信息中会告诉当前是在哪个分支（master）提交的，本次提交的完整 SHA-1校验和（ba93592），以及本次提交中，有多少文件修订过，多少行添加和删改过。\n\n提交时记录的是放在暂存区域的快照。任何还未暂存的文件仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对项目做一次快照，以后可以回到这个状态，或者进行比较。\n\n2.7 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git提供了一个跳过使用暂存区域的方式，只要在提交的时候，给git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过git add 步骤：\n$  git commit -a -m 'added .gitignore'    \n[master 57e60ca] added .gitignore\n 1 file changed, 3 insertions(+)\n2.8 移除文件要从 Git 中移除某个文件，就必须要从已跟踪的文件清单中移除（从暂存区域移除），然后提交。可以用git rm命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。\n\u0010如果只是简单的从工作目录中手工删除文件，运行git  status时就会在“Changes not staged for\ncommit” （未暂存清单）部分看到\n$ rm test.txt \n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add/rm &lt;file>...\" to update what will be committed)\n  (use \"git checkout -- &lt;file>...\" to discard changes in working directory)\n\n    deleted:    test.txt\n\nUntracked files:\n  (use \"git add &lt;file>...\" to include in what will be committed)\n\n    .gitignore\n    LICENSE.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n然后在运行git rm 记录此次移除文件的操作：\n$ git rm test.txt\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD &lt;file>...\" to unstage)\n\n    deleted:    test.txt\n\nUntracked files:\n  (use \"git add &lt;file>...\" to include in what will be committed)\n\n    .gitignore\n    LICENSE.txt\n\n下一次提交时，改文件就不再纳入版本管理了。如果删除之前修改过并切已经放到暂存区域的话，则必须要用强制删除选项 -f(force 首字母)。用于防止巫山还没有添加到快照的数据，这样的数据不能被 Git 恢复。\n另外一种情况是：我们想把文件从 Git 仓库中删除（亦从暂存区玉移除），但仍然希望保留在当前工作目录中。换句话说，你想让文件保留在磁盘，但是不想让 Git 继续跟踪。当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆编译生成的文件添加到暂存区时，可以使用这一做法。使用--cached 选项。\n$ git rm --cached test.txt\ngit rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：\n$ git rm log/\\*.log\n注意到星号 * 之前的反斜杠 \\，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。\n此命令删除 log/ 目录下扩展名为 .log 的所有文件。\n2.9 移动文件Git 并不显示跟踪文件移动操作。如果在 Git 中重名了了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。\n要在 Git 中对文件改名，可以这么做：\n$ git mv file_from file_to\n此时查看状态信息，也可以看到重命名操作的说明\n$ git mv README README.md\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD &lt;file>...\" to unstage)\n\n    renamed:    README -> README.md\n    deleted:    test.txt\n\n其实，运行git mv 就相当于运行了下面三条命令：\n$ mv README README.md\n$ git rm README\n$ git add README.md\n\n3. 查看提交历史git log命令可以在提交了若干更新或者克隆了某个项目之后，回顾提交历史。\n$ git log\ncommit f974236b7551a860b5c31c184cff66a66970603d (HEAD -> master)\nAuthor: TestUserName &lt;test@example.com>\nDate:   Thu Oct 22 19:50:29 2020 +0800\n\n    add .gitignore LICENSE.txt\n\ncommit 29fb9b4a159899da5675c132b64f1bcf0170c7a5\nAuthor: TestUserName &lt;test@example.com>\nDate:   Thu Oct 22 19:17:14 2020 +0800\n\n    added .gitignore\n\ncommit ba935920d4afc2121b674f933bada9d1c9791fa0\nAuthor: TestUserName &lt;test@example.com>\nDate:   Thu Oct 22 17:56:01 2020 +0800\n\n    update text.txt; add README,version File\n\ncommit 4ee1d4d20421d9276bc80808276207940695bbff\nAuthor: TestUserName &lt;test@example.com>\nDate:   Thu Oct 22 10:51:17 2020 +0800\n\n    init\n默认不用任何参数的话，git log 会按照提交时间列出所有的更新，最近的更新排在最上面。这个命令会列出每个提交的 SHA-1校验和、作者的名字和电子邮件地址、提交时间以及提交说明。\ngit log 有许多选项可以用来搜寻索要找的提交，下面列出一下最常用的：\n-p 用来显示每次提交的内容差异，也可以加上 -2来仅显示最近两次提交\n$ git log -p -2\ncommit f974236b7551a860b5c31c184cff66a66970603d (HEAD -> master)\nAuthor: TestUserName &lt;test@example.com>\nDate:   Thu Oct 22 19:50:29 2020 +0800\n\n    add .gitignore LICENSE.txt\n\ndiff --git a/.gitignore b/.gitignore\nnew file mode 100644\nindex 0000000..40c74dc\n--- /dev/null\n+++ b/.gitignore\n@@ -0,0 +1,5 @@\n+*.iml\n+*.log\n+*~\n+*.tmp\n+\ndiff --git a/LICENSE.txt b/LICENSE.txt\nnew file mode 100644\nindex 0000000..6b1d0bf\n--- /dev/null\n+++ b/LICENSE.txt\n@@ -0,0 +1 @@\n+LICENSE\ndiff --git a/README b/README.md\nsimilarity index 100%\nrename from README\nrename to README.md\ndiff --git a/test.txt b/test.txt\ndeleted file mode 100644\nindex bb08ffe..0000000\n--- a/test.txt\n+++ /dev/null\n@@ -1,6 +0,0 @@\n-This is test file\n-\n-modified\n-\n-\n-modefied  two\ncommit 29fb9b4a159899da5675c132b64f1bcf0170c7a5\nAuthor: TestUserName &lt;test@example.com>\nDate:   Thu Oct 22 19:17:14 2020 +0800\n\n    added .gitignore\n\ndiff --git a/test.txt b/test.txt\nindex 9c9852f..bb08ffe 100644\n--- a/test.txt\n+++ b/test.txt\n@@ -1,3 +1,6 @@\n This is test file\n\n modified\n+\n+\n+modefied  two\n如果想看到每次提交的简略的统计信息，可以使用--stat选项\n--stat 选项在每次提交的下面列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。\n$ git log --stat\ncommit f974236b7551a860b5c31c184cff66a66970603d (HEAD -> master)\nAuthor: TestUserName &lt;test@example.com>\nDate:   Thu Oct 22 19:50:29 2020 +0800\n\n    add .gitignore LICENSE.txt\n\n .gitignore          | 5 +++++\n LICENSE.txt         | 1 +\n README => README.md | 0\n test.txt            | 6 ------\n 4 files changed, 6 insertions(+), 6 deletions(-)\n\ncommit 29fb9b4a159899da5675c132b64f1bcf0170c7a5\nAuthor: TestUserName &lt;test@example.com>\nDate:   Thu Oct 22 19:17:14 2020 +0800\n\n    added .gitignore\n\n test.txt | 3 +++\n 1 file changed, 3 insertions(+)\n\ncommit ba935920d4afc2121b674f933bada9d1c9791fa0\nAuthor: TestUserName &lt;test@example.com>\nDate:   Thu Oct 22 17:56:01 2020 +0800\n\n    update text.txt; add README,version File\n\n README   | 1 +\n test.txt | 4 +++-\n version  | 2 ++\n 3 files changed, 6 insertions(+), 1 deletion(-)\n\ncommit 4ee1d4d20421d9276bc80808276207940695bbff\nAuthor: TestUserName &lt;test@example.com>\nDate:   Thu Oct 22 10:51:17 2020 +0800\n\n    init\n\n test.txt | 1 +\n 1 file changed, 1 insertion(+)\n\n--pretty 选项可以指定使用不同语默认格式的方式展示提交历史。\n这个选项还有一些内建子选项可以使用，比如 oneline  将每个提交放在一行显示，查看的提交数很大时非常有用，另外还有 short，full 和fuller ，展示的信息或多或少有些不同。\n$ git log --pretty=oneline\nf974236b7551a860b5c31c184cff66a66970603d (HEAD -> master) add .gitignore LICENSE.txt\n29fb9b4a159899da5675c132b64f1bcf0170c7a5 added .gitignore\nba935920d4afc2121b674f933bada9d1c9791fa0 update text.txt; add README,version File\n4ee1d4d20421d9276bc80808276207940695bbff init\nformat 可以定制要显示的记录格式。这样的输出对后期提取分析格外有用。\n$ git log --pretty=formate:\"%h - %an, %ar : %s\"\nformate:f974236 - TestUserName, 19 hours ago : add .gitignore LICENSE.txt\nformate:29fb9b4 - TestUserName, 20 hours ago : added .gitignore\nformate:ba93592 - TestUserName, 21 hours ago : update text.txt; add README,version File\nformate:4ee1d4d - TestUserName, 28 hours ago : init\ngit log --pretty=format 常用的选项 列出了常用的格式占位符写法及其代表的意义。\n\n\n\n选项\n说明\n\n\n\n%H\n提交对象（commit）的完整哈哈希字符串\n\n\n%h\n提交对象的剪短哈希字符串\n\n\n%T\n树对象（tree）的完整哈希字符串\u0010\n\n\n%t\n树对象的简短哈希字符串\n\n\n%P\n父对象（parent）的完整哈希字符串\n\n\n%p\n父对象的简短哈希字符串\n\n\n%an\n作者（author）的名字\n\n\n%ae\n作者的电子邮件\n\n\n%ad\n作者修订日期，可以用–date=选项定制格式,``–date=(relative\n\n\n%ar\n作者修订日期，按多久以前的方式显示\n\n\n%cn\n提交者（committer）的名字\n\n\n%ce\n提交者的电子邮件地址\n\n\n%cd\n提交日期\n\n\n%cr\n提交日期，按多久以前的方式显示\n\n\n%s\n提交说明\n\n\n\n作者指的是实际做出修改的人\n提交者指的是最后将次工作成功提交到仓库的人\n当某个项目发布不定，然后某个人核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。\n\n当oneline 或 format 与另一个log 选项 --graph 结合使用时尤其有用。这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史：\n$ git log --pretty=format:\"%h %s\" --graph\ngit log常用选项\n\n\n\n选项\n说明\n\n\n\n-p\n按补丁格式显示每个更新之间的差异\n\n\n–stat\n显示每次更新的文件系统修改统计信息\n\n\n–shortstat\n只显示–stat中最后的行数修改添加移除统计\n\n\n–name-only\n仅在提交信息后显示已修改的文件清单\n\n\n–name-status\n显示新增、修改、删除的文件清单\n\n\n–abbrev-commit\n仅显示 SHA-1 的前几个字符，而非所有的40个字符\n\n\n–relative-date\n使用较短的相对时间显示（比如：”2 weeks ago”）\u0010\n\n\n–graph\n显示 ASCII 图形表示的分支合并历史\n\n\n–pretty\n使用其他格式显示历史提交信息。可以的选项包括 online,short,full，fuller和 format\n\n\n限制输出长度\n除了定制输出格式的选项之外，git log 还有许多非常使用的限制输出长度的选项，也就是只输出部分提交信息。前面提到的 -2（-&lt;n&gt;） ，初次之外还有按照时间做闲职的选项，比如--since 和 --until \n$ git log --since=2.weeks\n这个命令可以在多种格式下工作，比如具体某一天”2008-08-08”，或者相对多久以前”1 years 2day 3 minutes ago”\n另一个非常有用的筛选选项是 -S，可以列出那些添加或者移除了某些字符的提交。\n$ git log -S function_name\ngit log [文件路径] 可以查看选择文件或目录的历史提交\ngit log 常用输出限制选项\n\n\n\n选项\n说明\n\n\n\n-(n)\n仅显示最近的n 条提交 ，如 -2.\n\n\n–since,–after\n仅显示指定时间之后的提交\n\n\n–until,–before\n仅显示指定时间之前的提交\n\n\n–author\n仅显示指定作者相关的提交\n\n\n–committer\n仅显示指定提交者相关的提交\n\n\n-grep\n仅显示包含知道关键字的提交\n\n\n-S\n仅显示添加或移除了某个关键字的提交\n\n\n4. 撤销操作4.1 重新提交在某些情况下，发现漏了几个文件没有提交，或者是提交信息写错了，此时 ，可以运行带有 --amend 选项的命令尝试重新提交\n$ git commit --amend\n该命令会将暂存区中的文件提交。如果自上次提交依赖还未做任何改变，快照会保持不变，所修改的只是提交信息。最终只会有一个提交（第二次提交会代替第一次提交的结果）。\n4.2修改倒数第n次commit git rebase -i HEAD~[倒数第n次commit]\n$ git rebase -i HEAD~2//修改倒数第二次 commit\n执行该命令，会出现编辑窗口，在命令界面编辑倒数第n次提交的commit 前的 pick 为 e 表示编辑\npick eae306bcae change:commit msg\n\n# Rebase 60e669d341..eae306bcae onto 60e669d341 (1 command)\n#\n# Commands:\n# p, pick &lt;commit> = use commit\n# r, reword &lt;commit> = use commit, but edit the commit message\n# e, edit &lt;commit> = use commit, but stop for amending\n# s, squash &lt;commit> = use commit, but meld into previous commit\n# f, fixup &lt;commit> = like \"squash\", but discard this commit's log message\n# x, exec &lt;command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop &lt;commit> = remove commit\n# l, label &lt;label> = label current HEAD with a name\n# t, reset &lt;label> = reset HEAD to a label\n# m, merge [-C &lt;commit> | -c &lt;commit>] &lt;label> [# &lt;oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). Use -c &lt;commit> to reword the commit message.\n\n改为 \ne eae306bcae change:commit msg\n\n# Rebase 60e669d341..eae306bcae onto 60e669d341 (1 command)\n#\n# Commands:\n# p, pick &lt;commit> = use commit\n# r, reword &lt;commit> = use commit, but edit the commit message\n# e, edit &lt;commit> = use commit, but stop for amending\n# s, squash &lt;commit> = use commit, but meld into previous commit\n# f, fixup &lt;commit> = like \"squash\", but discard this commit's log message\n# x, exec &lt;command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop &lt;commit> = remove commit\n# l, label &lt;label> = label current HEAD with a name\n# t, reset &lt;label> = reset HEAD to a label\n# m, merge [-C &lt;commit> | -c &lt;commit>] &lt;label> [# &lt;oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). Use -c &lt;commit> to reword the commit message.\n\n\n然后点击 Esc 键，退出编辑模式，使用:wq 命令保存本次编辑。\n然后可以对此次提交的文件进行修改 ，该操作会使本地git创建一个临时修改分支，再修改完成后，使用命令回到刚才的分支，并合并修改到刚才分支\n修改完成后，使用 git add 命令，添加修改文件索引\n$ git add A.java\n使用一下命令将本次修改追加到此次修改的commit 中,也可以再该命令后修改 commit msg ，然后使用 :wq 命令保存修改的 commit msg\n$ git commit --amend\n使用以下命令回到刚才的分支，并合并修改到刚才分支\n$ git rebase --continue\n使用git push 命令将修改推送到远程\n$ git push origin develop\n4.3 取消暂存的文件如果需要将已经添加到暂存区的文件取消暂存，可以使用git reset 命令。\n$ git reset HEAD test.txt\nUnstaged changes after reset:\nM    test.txt\n在调用时加上--hard 选项可以令git reset 成为一个危险的命令，会将该项目中的修改丢失。\n4.4 撤销对文件的修改如果在修改了一段代码后，没有解决问题，所以不想保留该文件的修改是，可以使用git checkout -- &lt;file&gt; 命令来将文件还原成上次提交时的样子。\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add &lt;file>...\" to update what will be committed)\n  (use \"git checkout -- &lt;file>...\" to discard changes in working directory)\n\n    modified:   README.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n$ git checkout -- README.md\n$ git status\nOn branch master\nnothing to commit, working tree clean\n5、隐藏本地修改如果当前修改没修改完，紧急修复一个 bug时，需要先将当前修改内容隐藏，修改完 bug 后，回来继续修改，则可以使用git stash 命令来进行隐藏修改操作\n$ git stash save \"隐藏说明信息\" \n改命令会将当前修改的已跟踪文件进行隐藏，保存到隐藏栈中。将项目恢复到上次提交时的状态。\n查看本地隐藏栈\n$ git stash list\n根据隐藏栈中的对象id将隐藏栈中的一项恢复，继续上次的修改。\n$ git stash pop stash@{0}\n6. 仓库的使用6.1 查看远程仓库可以运行git remote 命令来查看已经配置的远程仓库服务器。它会列出知道的每一个远程服务器的简写。如果已经克隆了自己的仓库，至少能看到 origin - 这是克隆的仓库服务器的默认名字。\n$ git clone https://github.com/onestravel/test.git \nCloning into 'test'...\nremote: Enumerating objects: 21, done.\nremote: Counting objects: 100% (21/21), done.\nremote: Compressing objects: 100% (9/9), done.\nremote: Total 21 (delta 2), reused 21 (delta 2), pack-reused 0\nUnpacking objects: 100% (21/21), done.\n$ cd test \n$ git remote\norigin\n也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。\n$ git remote -v\norigin    https://github.com/onestravel/test.git (fetch)\norigin    https://github.com/onestravel/test.git (push)\n如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name]命令。\n$ git remote show origin\n* remote origin\n  Fetch URL: https://github.com/onestravel/test.git\n  Push  URL: https://github.com/onestravel/test.git\n  HEAD branch: master\n  Remote branch:\n    master tracked\n  Local branch configured for 'git pull':\n    master merges with remote master\n  Local ref configured for 'git push':\n    master pushes to master (up to date)\n这个命令会列出在特定分支上 pull 或 push 对自动的操作远程仓库中的哪一个分支。也列出了那些远程分支不再本地，那些远程分支已经从服务器上移除了。\n6.2 添加远程仓库可以使用git remote add &lt;shortname&gt; &lt;url&gt; 来添加一个新的远程 Git 仓库，同时知道一个可以轻松引用的简写：\n$ git remote add pb https://github.com/onestravel/test.git\n$ git remote -v\norigin    https://github.com/onestravel/test.git (fetch)\norigin    https://github.com/onestravel/test.git (push)\npb    https://github.com/onestravel/test.git (fetch)\npb    https://github.com/onestravel/test.git (push)\n此时如果想拉取 pb 对应的仓库服务器上的信息，可以运行：\n$ git fetch pb\nFrom https://github.com/onestravel/test\n * [new branch]      master     -> pb/master\n6.3 从远程仓库中抓取与拉取从远程仓库中获得数据，可以执行：\n$ git fetch [remote_name]\n这个命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会用于那个远程仓库中所有分支的引用，可以随时合并或查看。\ngit fetch 命令会将数据拉取到本地仓库，但是他不会自动合并或修改当前的工作。当准备好时必须手动将其合并。\ngit pull 命令会自动的抓取并合并远程分支到当前分支，默认情况下，git clone 会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支。运行 git pull 通常会从最初克隆的服务器上抓取 bong 自动尝试合并到当前所在分支\n6.4 推送到远程仓库git push [remote-name] [branch-name] 命令可以将本地仓库中 当前分支（master）上的为推送到远程仓库的提交，全部推送到远程仓库服务器。\u0010\n$ git push origin master\nEnumerating objects: 21, done.\nCounting objects: 100% (21/21), done.\nDelta compression using up to 4 threads\nCompressing objects: 100% (11/11), done.\nWriting objects: 100% (21/21), 1.76 KiB | 1.76 MiB/s, done.\nTotal 21 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), done.\nTo https://github.com/onestravel/test.git\n * [new branch]      master -> master\n只有当有远程服务器的写入权限时，改命令才会生效。\n如果在此次推送之前有其他人推送过时，需要先进行 pull ,将他们的推送拉取到本地并将其合并如本地仓库后才能推送。\n6.5 远程仓库的移除与重命名想要重命名引用名称，可以使用git remote rename [old name] [new name] ，\n$ git remote rename pb pt\n$ git remote\norigin \npt\n这种操作会修改远程分支的名字\u0010，比如过去引用pb/master 会变成 pt/master 。\n如果想要移除一个远程仓库，可以使用git remote rm 命令：\n$ git remote rm pt\n$ git remote\norigin\n7. 标签的使用Git  和其他版本控制系统一样，可以给历史中的某一个提交打算标签，以示重要。比如发布结点。\n7.1 列出标签在 Git 中可以使用git  tag 很直观的列出已有的标签\n$ git tag\nv1.0\nv1.1\nv2.0\nv2.3\n可以使用特定模式查找标签\n$ git tag -l 'v2.*'\nv2.0\nv2.3\n7.2 创建标签Git 使用两种主要类型的标签：轻量标签（lightweight）与 附注标签（annotated）。\n一个轻量标签很像一个不会改变的分支，他只是一个特定提交的引用。\n附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间，还有一个标签信息。并且可以使用 GNU Privacy Guard（GPG）签名与验证。\n附注标签\n在 Git 中创建一个附注标签时很简单的，最简单的方法是在运行git tag 命令时指定 -a 选项：\n$ git tag -a v2.5 -m 'version 2.5'\n$ git tag\nv1.0\nv1.1\nv2.0\nv2.3\nv2.5\n\u0010\u0010-m 选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。 \n通过使用 git show 命令可以看到标签信息与对应的提交信息：\n$ git show v2.5\ntag v2.5\nTagger: wanghu &lt;wanghu@do-global.com>\nDate:   Mon Oct 26 20:09:19 2020 +0800\n\nversion 2.5\n\ncommit bf1c84c9273b827f28c06b26a176a44795b38ef0 (HEAD -> master, tag: v2.5, pbhttps/master, origin/master, origin/HEAD)\nAuthor: TestUserName &lt;test@example.com>\nDate:   Fri Oct 23 16:09:46 2020 +0800\n\n    create test.txt\n\ndiff --git a/test.txt b/test.txt\nnew file mode 100644\nindex 0000000..46fdabe\n--- /dev/null\n+++ b/test.txt\n@@ -0,0 +1 @@\n+test code\n\n输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。\n轻量标签\n 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：\n$ git tag v2.5-1\n$ git tag\nv1.0\nv1.1\nv2.0\nv2.3\nv2.5\nv2.5-1\n运行 git show，你不会看到额外的标签信息。命令只会显示出提交信息：\n$ git show v2.5-1\ncommit bf1c84c9273b827f28c06b26a176a44795b38ef0 (HEAD -> master, tag: v2.5-1, tag: v2.5, pbhttps/master, origin/master, origin/HEAD)\nAuthor: TestUserName &lt;test@example.com>\nDate:   Fri Oct 23 16:09:46 2020 +0800\n\n    create test.txt\n\ndiff --git a/test.txt b/test.txt\nnew file mode 100644\nindex 0000000..46fdabe\n--- /dev/null\n+++ b/test.txt\n@@ -0,0 +1 @@\n+test code\n\n7.3 后期打标签如果相对过去的提交打标签，需要在命令末尾知道提交的校验和（或部分校验和）：\n$ git log --pretty=oneline\nbf1c84c9273b827f28c06b26a176a44795b38ef0 (HEAD -> master, tag: v2.5-1, tag: v2.5, pbhttps/master, origin/master, origin/HEAD) create test.txt\n7236b53506f041de847f43eab3fedaa97d45a789 update README.md\nf974236b7551a860b5c31c184cff66a66970603d add .gitignore LICENSE.txt\n29fb9b4a159899da5675c132b64f1bcf0170c7a5 added .gitignore\nba935920d4afc2121b674f933bada9d1c9791fa0 update text.txt; add README,version File\n4ee1d4d20421d9276bc80808276207940695bbff init\n$ git tag -a v1.2 7236b53\n$ git show v1.2\ntag v1.2\nTagger: wanghu &lt;wanghu@do-global.com>\nDate:   Mon Oct 26 20:16:54 2020 +0800\n\nversion 1.2\ns\n\ncommit 7236b53506f041de847f43eab3fedaa97d45a789 (tag: v1.2)\nAuthor: TestUserName &lt;test@example.com>\nDate:   Fri Oct 23 16:00:21 2020 +0800\n\n    update README.md\n\ndiff --git a/README.md b/README.md\nindex cd19876..9fafd26 100644\n--- a/README.md\n+++ b/README.md\n@@ -1 +1,6 @@\n My Project-\n+\n+\n+\n+update on dev branch\n\n7.4 共享标签默认情况下，git push 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样 - 你可以运行 git push origin [tagname]。\u0010\n$ git push origin v2.5\nEnumerating objects: 1, done.\nCounting objects: 100% (1/1), done.\nWriting objects: 100% (1/1), 158 bytes | 158.00 KiB/s, done.\nTotal 1 (delta 0), reused 0 (delta 0)\nTo https://github.com/onestravel/test.git\n * [new tag]         v2.5 -> v2.5\n\n如果想要一次性推送很多标签，也可以使用带有 –tags 选项的 git push 命令。这将会把所有不在远程仓库服务器上的标签全部传送到远程仓库。\n$ git push origin --tags\nEnumerating objects: 1, done.\nCounting objects: 100% (1/1), done.\nWriting objects: 100% (1/1), 160 bytes | 160.00 KiB/s, done.\nTotal 1 (delta 0), reused 0 (delta 0)\nTo https://github.com/onestravel/test.git\n * [new tag]         v1.2 -> v1.2\n * [new tag]         v2.5-1 -> v2.5-1\n7.5 检出标签如果想要本地工作目录与仓库中知道的标签版本完全一样，可以使用git checkout -b [branch-name]\u0010 [tag-name]\u0010 在特定标签上创建一个新分支：\n$ git checkout -b version2.5 v2.5\nSwitched to a new branch 'version2.5'\n如果在这之后又进行了一次提交，version2.5 分支会因为改动向前移动了，那么 version2.5 分支就会和v2.5 标签稍微有些不同。\n四、Git  分支Git 的分支，本质上紧急时指向提交对象的可变指针。Git 的默认分支名字是 master 。在多次提交操作之后，已经有一个指向最后那个提交\u0010\u0010对象的master 分支。它会在每次的提交操作中自动向前移动。\n\nGit 的 master 分支，并不是一个特殊的分支，和其他分支没有任何区别。只是在git init 命令的时候默认创建的。\n\n1. 创建分支Git 使用git branch &lt;branch-name&gt; 命令来新建分支（创建一个可以移动的新的指针）。使用git branch &lt;branch-name&gt; 会在当前所在对象上创建一个指针。\nGit 是怎么知道当前是在哪一个分支上呢？其实，Git 有一个名为HEAD 的特殊指针。它和其他版本控制系统里的 HEAD 概念完全不同。在 Git 中，它是一个指针，指向当前所在的本地分支。\ngit branch 命令仅仅创建一个新分支，并不会自动切换到新分支中。\n$ git branch testing\n$ git branch\n* master\n  testing\n  version2.5\n$ git log --oneline --decorate\nbf1c84c (HEAD -> master, tag: v2.5-1, tag: v2.5, pbhttps/master, origin/master, origin/HEAD, version2.5, testing) create test.txt\n7236b53 (tag: v1.2) update README.md\nf974236 add .gitignore LICENSE.txt\n29fb9b4 added .gitignore\nba93592 update text.txt; add README,version File\n4ee1d4d init\n可以看到 master 和 testing 分支均指向校验和以 bf1c84c 开头的提交对象。\n2. 分支切换要切换到另一个已经存在的命令，可以使用git checkout 命令。\n$ git checkout testing\n执行完改命令后， HEAD 就会指向 testing 分支了。\n切换分支时，这么命令做了两件事。一是使HEAD 指向指定的分支。二是将工作目录恢复成指定分支所执行的快照内容。\n\n分支切换会改变工作目录中的文件。\n如果不能保证在切换分支时可以干净利落的完成这个任务，那么则切换分支失败。\n\n3. 分支代码合并假设，现在在master 分支上进行新的开发工作，但是现在线上版本（version 2.5）出现了一个 bug，需要紧急修复，则需要将当前分支修改的代码暂存，切换到 version2.5 版本，新建 version2.5.1 分支，用于修复 bug。修复之后，进行发版，并将修复bug 的修改合并到 master 分支。\n$ git checkout version2.5                       \nSwitched to branch 'version2.5'\n$ git checkout -b version2.5.1\nSwitched to a new branch 'version2.5.1'\n$ vim test.txt \n$ vim version\n$ git add test.txt\n$ git add version\n$ git commit -m\"fix bug on version2.5\"\n[version2.5.1 2b1d2e0] fix bug on version2.5\n 2 files changed, 5 insertions(+), 2 deletions(-)\n git push origin version2.5.1\nEnumerating objects: 7, done.\nCounting objects: 100% (7/7), done.\nDelta compression using up to 4 threads\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (4/4), 367 bytes | 367.00 KiB/s, done.\nTotal 4 (delta 1), reused 0 (delta 0)\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nremote: \nremote: Create a pull request for 'version2.5.1' on GitHub by visiting:\nremote:      https://github.com/onestravel/test/pull/new/version2.5.1\nremote: \nTo https://github.com/onestravel/test.git\n * [new branch]      version2.5.1 -> version2.5.1\n\n现在已经修复完 bug，并生成了新的分支 version 2.5.1，接下来需要将 version2.5.1 分支上的修改合并到 master 分支。\n$ git checkout master\nSwitched to branch 'master'\nYour branch is up to date with 'origin/master'.\n$ git merge version2.5.1\nAuto-merging version\nCONFLICT (content): Merge conflict in version\nAutomatic merge failed; fix conflicts and then commit the result.\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nChanges to be committed:\n\n    modified:   test.txt\n\nUnmerged paths:\n  (use \"git add &lt;file>...\" to mark resolution)\n\n    both modified:   version\n\n可以看到在合并 version 2.5.1 的时候有了冲突（在 master 分支和 version2.5.1 分支都对 version 文件的相同部分做了不同的修改），则需要解决冲突，名进行提交（commit）。\n\n 如果在合并的两个版本之间没有修改同一个文件的同一个部分，则不会产生冲突，就可以干净的合并他们。\n\n$ vim version\n编辑冲突文件\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nversion: 3.0.0\ncode: 300\n=======\nversion: 2.5.1\ncode: 251\n>>>>>>> version2.5.1\n~                    \n因为这个是版本改变，在 master 分支应该是新的版本 3.0.0 ,所以，删掉冲突中的 version2.5.1 中的代码，进行解决。并且将&lt;&lt;&lt;&lt;&lt;&lt;&lt; , ======= ,  &gt;&gt;&gt;&gt;&gt;&gt;&gt;这些行完全删除。\nversion: 3.0.0\ncode: 300\n\n也可以尝试使用git mergetool命令来解决冲突。改命令会启动一个合适的可视化合并工具。\n\n保存对改文件的修改，然后进行文件的提交\n$ git add version \n$ git commit \n[master 0639659] Merge branch 'version2.5.1'\n此处使用git commit 命令继续提交，会出现编辑提交日志的窗口，会显示以下内容：\nMerge branch 'version2.5.1'\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# Date:      Wed Oct 28 16:38:53 2020 +0800\n#\n# On branch master\n# Your branch is ahead of 'origin/master' by 3 commits.\n#   (use \"git push\" to publish your local commits)\n#\n# Changes to be committed:\n#       modified:   test.txt\n#       modified:   version\n#\n直接保存改日志的编辑，则提交成功。接下来可以选择推送至远程仓库服务器，或者继续进行新功能的开发，后续推送至远程仓库服务器。\n4. 分支管理git branch 命令不只是可以创建或删除分支。如果不加参数运行这个命令，会得到当前所有分支的一个列表\n$ git branch\n* master\n  testing\n  version2.5\n  version2.5.1\nmaster 分支前的 * 字符代表现在检出的哪一个分支，也就是说，当前 HEAD 指针所指向的分支。\n如果需要查看每一个分支的最后一次提交，可以运行git branch -v命令：\n$ git branch -v\n\n* master       02c3021 [ahead 3] Merge branch 'version2.5.1'\n  testing      bf1c84c create test.txt\n  version2.5   bf1c84c create test.txt\n  version2.5.1 4b30818 change version\n--merged 与 --no-merged 者两个选项可以过滤这个俩表中已经合并或者尚未合并到当前分支的分支。\n$ git checkout testing\n$ vim test.txt\n$ git add test.txt\n$ git commit -m\"update test\"\n[testing b00d0ae] update test\n 1 file changed, 3 insertions(+)\n$ git checkout master\nSwitched to branch 'master'\n$ git branch --merged\n* master\n  version2.5\n    version2.5.1\n$ git branch --no-merged\n  testing\n5. 远程分支5.1 远程分支远程引用是对远程仓库的引用（指针），包括分支，标签等等。可以通过git ls-remote 来显示的获得远程引用的完整列表，或者通过git remote show (remote) 获得远程分支的更多信息。\n$ git ls-remote   \nFrom https://github.com/onestravel/test.git\nbf1c84c9273b827f28c06b26a176a44795b38ef0    HEAD\nbf1c84c9273b827f28c06b26a176a44795b38ef0    refs/heads/master\ne5b97a2fb0ad902b2a6069d07964bc09ab102f0f    refs/heads/version2.5.1\n853cf5e3d043663e823565c6f8b7b4eb713e8d2c    refs/tags/v1.2\n7236b53506f041de847f43eab3fedaa97d45a789    refs/tags/v1.2^{}\ne5fb21c6d785132c26100f6f951feebce8aa2a40    refs/tags/v2.5\nbf1c84c9273b827f28c06b26a176a44795b38ef0    refs/tags/v2.5^{}\nbf1c84c9273b827f28c06b26a176a44795b38ef0    refs/tags/v2.5-1\n远程跟踪分支是远程分支状态的引用。它们是不能移动的本地引用，当做任何网络通信操作时，它们会自动移动。\n远程分支以（remote）/（branch）形式命名，如果响应查看最后一次与远程仓库 origin 通信时 master 分支的状态，可以查看origin/master 分支。\n可以运行git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。因为那台服务器上现有的数据是 origin 服务器上的一个子集，所以 Git 并不会抓取数据而是会设置远程跟踪分支 teamone/master 指向 teamone 的 master 分支。\n5.2 推送当想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。本地分支并不会自动与远程仓库同步，必须显示的推送想要分享的分支。\n将本地分支 testing 推送到远程仓库上：\n$ git push origin testing\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 4 threads\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 291 bytes | 291.00 KiB/s, done.\nTotal 3 (delta 1), reused 0 (delta 0)\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nremote: \nremote: Create a pull request for 'testing' on GitHub by visiting:\nremote:      https://github.com/onestravel/test/pull/new/testing\nremote: \nTo https://github.com/onestravel/test.git\n * [new branch]      testing -> testing\n\n如果不想让远程仓库上的分支叫做 testing 可以运行git push origin testing:otherbranch 来将本地的 testing 分支推送到远程仓库上的 otherbranch 分支。\n$ git push origin testing:otherbranch\nTotal 0 (delta 0), reused 0 (delta 0)\nremote: \nremote: Create a pull request for 'otherbranch' on GitHub by visiting:\nremote:      https://github.com/onestravel/test/pull/new/otherbranch\nremote: \nTo https://github.com/onestravel/test.git\n * [new branch]      testing -> otherbranch\n\n\n如果使用 HTTPS URL 来推送，Git 服务器会询问用户名和密码，默认情况下它会在中断中提示服务器是否允许你进行推送。\n\ngit merge origin/otherbranch 会将这些工作合并到当前所在的分支。\n如果想要在远程分支origin/otherbranch 上创建 dev 分支进行一些工作时，可以如下操作：\n$ git checkout -b dev origin/otherbranch\nBranch 'dev' set up to track remote branch 'otherbranch' from 'origin'.\nSwitched to a new branch 'dev'\n这会在本地创建一个 用于工作的 dev 分支，并且起点位于 origin/otherbranch。\n5.3 跟踪分支从一个远程分支检出一个本地分支会自动创建一个叫做“跟踪分支”（也叫“上游分支”）。跟踪分支是与远程分支有直接关系的本地分支。如果在一个跟踪分支上输入 git pull ,Git 能自动滴识别去那个服务器上抓取、合并到哪个分支。\n如果想要设置本地分支跟踪其他远程仓库上的跟踪分支，可以运行git checkout -b [branch] [remote-name]/[branch] 命令，这个命令 Git 提供了快捷方式 git checkout --track [remote-name]/[branch] 。\n设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。\n$ git branch -u origin/testing\nBranch 'dev' set up to track remote branch 'testing' from 'origin'.\n如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。\n$ git branch -vv\n* dev          b00d0ae [origin/testing] update test\n  master       65682fc [origin/master: ahead 5] Merge branch 'version2.5.1'\n  testing      b00d0ae update test\n  version2.5   bf1c84c create test.txt\n  version2.5.1 4b30818 change version\n\n可以看到本地分支 dev 正在跟踪 origin/testing ；master 分支正在跟踪origin/master ，并且“ahead” 是5，表示本地 master 分支还有 5 个提交没有推送到服务器。\n想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。\n$ git fetch --all; git branch -vv\n5.4  拉取当git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。它只会获取数据然后让你自己合并。\ngit pull 会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并如那个远程分支。大多数情况下，它可以看着是一个git fetch 紧接着一个git merge 命令。\n5.5 删除远程分支如果临时创建了一个分支，并且这个分支的职责已经完成了，不需要了，想将这个分支从远程服务器删除。可以运行带有--delete 选项的git push 命令来删除一个远程分支。比如需要从远程服务器上删除testing 分支，运行下面的命令：\n$ git push origin --delete testing\nTo https://github.com/onestravel/test.git\n - [deleted]         testing\n$ git branch -vv\n* dev          b00d0ae [origin/testing: gone] update test\n  master       65682fc [origin/master: ahead 5] Merge branch 'version2.5.1'\n  testing      b00d0ae update test\n  version2.5   bf1c84c create test.txt\n  version2.5.1 4b30818 change version\n这个命令做的只是从服务器上移除这个指针，Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以是不小心删除了，通常比较容易恢复。使用git branch -vv查看分支跟踪状态，可以看到 dev 分支跟踪的远程分支origin/testing 后面是一个 gone 的状态。\n6. 变基在 Git 中整合来自不同分支的修改主要有两种方法：merge 和 rebase 。\n使用 rebase 命令将提交到某一分支上的所有修改都移动至另外一个分支上。必然在 C4 提交中引入的补丁和修改，然后在 C3 提交的基础上再应用一次。就叫变基。\n","categories":["Git"],"tags":["Git"]},{"title":"Linux 用户、用户组添加修改删除(ubuntu、centos)","url":"https://blog.onestravel.cn/20161009/16c77759ce14/","content":"Linux 用户、用户组添加修改删除(ubuntu、centos)一、LINUX(UBUNTU/CENTOS)用户添加删除修改1、建用户：adduser web                             #新建web用户\nuseradd web                                #添加web 用户\npasswd web                               #给web用户设置密码\nuseradd web -g admin -n -m  #新建web用户并指定用户组为 admin用户组,并自动建立登录目录\npasswd web                  #给web 用户设置密码\nuseradd(选项)(参数)\n\n                #创建admin用户，并指定属组为admin 用户id为10000\nuseradd -r -m -s  /bin/bash -g admin -u 10000 admin \n-c&lt;备注&gt;：加上备注文字。备注文字会保存在passwd的备注栏位中； \n-d&lt;登入目录&gt;：指定用户登入时的启始目录； \n-D：变更预设值； \n-e&lt;有效期限&gt;：指定帐号的有效期限； \n-f&lt;缓冲天数&gt;：指定在密码过期后多少天即关闭该帐号； \n-g&lt;群组&gt;：指定用户所属的群组； \n-G&lt;群组&gt;：指定用户所属的附加群组； \n-m：自动建立用户的登入目录； \n-M：不要自动建立用户的登入目录； \n-n：取消建立以用户名称为名的群组； \n-r：建立系统帐号； \n-s：指定用户登入后所使用的shell； \n-u：指定用户id。\n2、给已有的用户增加工作组usermod -G admin web                    #给web用户设置admin附属用户组\n#给用户设置添加多个用户组\nusermod -g web -G admin,www web #给web用户设置主用户组web组，admin,www附属用户组\ngpasswd -a web admin                #给web用户设置admin用户组\n3、新建用户同时增加工作组useradd -g admin web                      #新建web用户并增加到admin工作组\n注：-g 所属组-d 家目录-s 所用的SHELL\n4、临时关闭方法一 /etc/shadow文件中属于该用户的行的第二个字段（密码）前面加上 就可以了。想恢复该用户，去掉即可。 方法二 使用命令关闭用户账号：\npasswd web –l\n重新释放：\npasswd web –u\n5、永久性删除用户账号userdel web\ngroupdel web\nusermod –G web web   #（强制删除该用户的主目录和主目录下的所有文件和子目录）\n6、从组中删除用户编辑/etc/group 找到用户组admin那一行，删除用户名web 或者用命令\ngpasswd -d A web\n7、显示用户信息id user\ncat /etc/passwd\n二、用户组 LINUX(UBUNTU/CENTOS) 添加删除修改1、建工作组groupadd admin                          #新建admin工作组\n2、修改用户组groupmod -n newadmin admin                #修改admin用户组名称改为newadmin\n3、删除用户组groupdel admin                            #删除admin用户组\n4.查看用户的用户组信息groups web                                #==查看web所有用户组==","categories":["Linux"],"tags":["Linux","centos","ubuntu"]},{"title":"Html5利用AppCache和LocalStorage实现缓存h5页面数据","url":"https://blog.onestravel.cn/20161009/af07143c33b9/","content":"Html5利用AppCache和LocalStorage实现缓存h5页面数据\n最近在开发的过程中遇到了一个问题，就是在Android上通过WebView加载Html5页面时发现页面加载速度慢，再加上网络速度慢，每次请求需要5s左右的时间，严重影响用户体验，所以查询资料，最终找到一个可以解决加载缓慢的方法，现在介绍给大家：1、使用AppCache机制实现缓存html，css，js文件和一些本地图片，这种缓存方法使用manifest文件进行缓存数据，一般manifest文件默认后缀名为 .appcache，在设置缓存以后，第一次加载页面时会根据manifest文件中列出的缓存文件路径，将文件进行缓存到浏览器，在再次打开的时候，不会再次从服务器请求，而是加载缓存数据。但是如果manifest文件没有发生改变，那么服务器上的相关页面发生改动，加载时也是只会加载缓存的数据，不会进行更新；如果需要更新，必须改动manifest文件，哪怕只是一个空格或者换行。开启缓存机制需要两步:\n(1). 需要在服务器端做AppCache缓存处理：在每个需要缓存的html页面增加manifest属性，设置AppCache文件，进行缓存。\n创建manifest文件**manifest文件（manifest.appcache）\n\nCACHE MANIFEST#VERSION 2016-09-28 14:44\n# 直接缓存的文件\nCACHE:../index.html\n../css/index.css\n../js/jquery-2.2.4.min.js../js/index.js\n../images/loading.gif../images/index_one.jpg../images/index_one_icon.png../images/index_two.jpg../images/index_two_icon.png../images/index_three.jpg../images/index_three_icon.png../images/index_four.jpg../images/index_four_icon.png\n#需要在线请求的文件路径，*代表除CACHE以外的文件都进行在线请求NETWORK:*\n# 替代方案 ，当请求失败时需要跳转的页面FALLBACK:../error.html\n\nmanifest文件分为三个部分：CACHE，NETWORK 和 FALLBACK；\nCACHE：是所需要缓存文件的路径可以是绝对路径或者相对路径，一般相对路径比较好。NETWORK ：是需要即时从服务器请求的文件，一般默认号，表示除CACHE所列所见以外的文件都是需要即时请求更新的。*FALLBACK**：这个页面时当缓存请求失败时所需展示的页面，一般默认一个错误页面。\nVERSION：版本号，这是一个附加属性，可有可无，加这个是为了在页面改动时，可以进行改动此版本号，使得manifest文件发生改动，从而浏览器再次请求html页面时，发现页面manifest文件进行改动，浏览器会从服务器重新拉取更新的内容。\nmanifest文件有了，现在所需做的就是把manifest文件和Html文件进行关联，这个非常简单：在Html标签中标签有一个属性manifest，就是用来关联manifest文件的，所以只需要在缓存的html文件中的html标签上声明manifest属性，就可以进行AppCache缓存。\n\n\n\n\n\n（2）这样服务器端的缓存就处理好了，可以在浏览器上进行测试，是完全可以缓存的，但是用在Android上使用WebView加载H5页面时，则需要在Android端进行设置：\n\nWebSettings webseting = webview.getSettings();\nwebseting.setDomStorageEnabled(true);webseting.setAppCacheMaxSize(102410248);//设置缓冲大小，我设的是8MString appCacheDir = this.getApplicationContext().getDir(“cache”, Context.MODE_PRIVATE).getPath();webseting.setAppCachePath(appCacheDir);webseting.setAllowFileAccess(true);webseting.setAppCacheEnabled(true);webseting.setCacheMode(WebSettings.LOAD_DEFAULT);//可以在加载前对网络进行判断，如果有网络，则设置缓存模式为  WebSettings.LOAD_DEFAULT，从服务器请求数据， 如果没有网络测设置缓存模式为WebSettings.LOAD_CACHE_ELSE_NETWORK\n\n缓存模式(5种)\nLOAD_CACHE_ONLY:  不使用网络，只读取本地缓存数据LOAD_DEFAULT:  根据cache-control决定是否从网络上取数据。LOAD_CACHE_NORMAL:API level 17中已经废弃, 从API level 11开始作用同LOAD_DEFAULT模式LOAD_NO_CACHE:不使用缓存，只从网络获取数据.LOAD_CACHE_ELSE_NETWORK: 只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。\n如：www.taobao.com的cache-control为no-cache，在模式LOAD_DEFAULT下，无论如何都会从网络上取数据，如果没有网络，就会出现错误页面；在LOAD_CACHE_ELSE_NETWORK模式下，无论是否有网络，只要本地有缓存，都使用缓存。本地没有缓存时才从网络上获取。www.360.com.cn的cache-control为max-age=60，在两种模式下都使用本地缓存数据。\na、缓存构成根据setAppCachePath(String appCachePath)提供的路径，在H5使用缓存过程中生成的缓存文件。\nb、缓存模式无模式选择，通过setAppCacheEnabled(boolean flag)设置是否打开。默认关闭，即，H5的缓存无法使用。\nc、清除缓存找到调用setAppCachePath(String appCachePath)设置缓存的路径，把它下面的文件全部删除就OK了。clearCache(boolean)CacheManager.clear高版本中需要调用隐藏API。\nd、控制大小通过setAppCacheMaxSize(long appCacheMaxSize)设置缓存最大容量，默认为Max Integer。同时，可能通过覆盖WebChromeClient.onReachedMaxAppCacheSize(long requiredStorage, long quota, WebStorage.QuotaUpdater quotaUpdater)来设置缓存超过先前设置的最大容量时的策略。\n这样一来，通过设置服务器端的缓存，与Android前端的缓存，就可以有效解决Html5的加载缓慢问题，该方法虽然解决了缓存问题，但是会发现只是在第二次打开是速度会明显提升，但是在首次进行加载时，页面加载还是非常缓慢的，目前还没想到方案进行解决，后面如果找到方法，则会继续更新！-\n\n发表博客是为了做个笔记，并且和各位读者进行交流，互相学习，如果哪位读者有更好地解决方案，请麻烦留言告知，万分谢谢！\n","categories":["前端H5"],"tags":["html","AppCache","LocalStorage"]}]