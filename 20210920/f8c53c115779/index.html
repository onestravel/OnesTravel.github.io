<!DOCTYPE html>
<html  lang="zh-CN" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" id="theme-color">
  <meta name="description" content="冰冻三尺，非一日之寒；为山九仞，岂一日之功；不忘初心，方得始终！">
  <link rel="icon" href="/favicon.png">
  <title>【并发编程】线程基础</title>
  
  
  <meta property="og:title" content="【并发编程】线程基础">
  
  
  <meta property="og:url" content="https://blog.onestravel.cn/20210920/f8c53c115779/index.html">
  
  
  <meta property="og:img" content="/medias/avatar.jpg">
  
  
  <meta property="og:img" content="冰冻三尺，非一日之寒；为山九仞，岂一日之功；不忘初心，方得始终！">
  
  
  <meta property="og:type" content="article">
  <meta property="og:article:published_time" content="2021-09-20">
  <meta property="og:article:modified_time" content="2022-10-08">
  <meta property="og:article:author" content="一个人的旅行">
  
  
  <meta property="og:article:tag" content="JVM">
  
  <meta property="og:article:tag" content="JAVA">
  
  
  
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
    var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
      }
    };
    setDarkmode();
  </script>
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
  </script>
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
  <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  <link rel="prefetch" href="//cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" as="script">
  
  
  
  <link rel="prefetch" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" as="script">
  
  
  
  
<link rel="stylesheet" href="/css/main.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">

  
  
<link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">

  
  
  
  
<meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
  <div class="wrapper">
    
    <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
      <img class="navbar-logo-img" src="/favicon.png" alt="logo">
      
      <span class="navbar-logo-dsc">一个人的旅行</span>
    </span>
  </div>
  <div class="navbar-menu">
    
    <a href="/" class="navbar-menu-item">
    
    首页
    
    </a>
    
    <a href="/archives" class="navbar-menu-item">
    
    归档
    
    </a>
    
    <a href="/tags" class="navbar-menu-item">
    
    标签
    
    </a>
    
    <a href="/categories" class="navbar-menu-item">
    
    分类
    
    </a>
    
    <a href="/about" class="navbar-menu-item">
    
    关于
    
    </a>
    
    <a href="/friends" class="navbar-menu-item">
    
    友链
    
    </a>
    
    <a class="navbar-menu-item darknavbar" id="dark"><i class="iconfont icon-weather"></i></a>
    <a class="navbar-menu-item searchnavbar" id="search"><i class="iconfont icon-search" style="font-size: 1.2rem; font-weight: 400;"></i></a>
  </div>
</nav>
    
    <div id="local-search" style="display: none;">
      <input class="navbar-menu-item" id="search-input" placeholder="请输入搜索内容...">
      <div id="search-content"></div>
    </div>
    
    <div class="section-wrap">
      <div class="container">
        <div class="columns">
          <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      【并发编程】线程基础
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2021-09-20T14:50:00.000Z">
      <i class="iconfont icon-calendar" style="margin-right: 2px;"></i>
      <span>2021-09-20</span>
    </time>
    
    <span class="dot"></span>
    
    <a href="/categories/JAVA/" class="post-meta-link">JAVA</a>
    
    
    
    <span class="dot"></span>
    <span>9.6k 字</span>
    
  </div>
  
  <div class="post-meta post-show-meta" style="margin-top: -10px;">
    <div style="display: flex; align-items: center;">
      <i class="iconfont icon-biaoqian" style="margin-right: 2px; font-size: 1.15rem;"></i>
      
      
        <a href="/tags/JVM/" class="post-meta-link">JVM</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/JAVA/" class="post-meta-link">JAVA</a>
      
    </div>
  </div>
  
  </header>
  <div id="section" class="post-content">
    <h1 id="【并发编程】线程基础"><a href="#【并发编程】线程基础" class="headerlink" title="【并发编程】线程基础"></a>【并发编程】线程基础</h1><h2 id="一-实现线程的方式"><a href="#一-实现线程的方式" class="headerlink" title="一. 实现线程的方式"></a>一. 实现线程的方式</h2><h3 id="1-为何说只有一种实现线程的方式"><a href="#1-为何说只有一种实现线程的方式" class="headerlink" title="1. 为何说只有一种实现线程的方式"></a>1. 为何说只有一种实现线程的方式</h3><h4 id="1-1-常见的实现线程的方式"><a href="#1-1-常见的实现线程的方式" class="headerlink" title="1.1 常见的实现线程的方式"></a>1.1 常见的实现线程的方式</h4><h5 id="1-1-1-继承Thread类"><a href="#1-1-1-继承Thread类" class="headerlink" title="1.1.1 继承Thread类"></a>1.1.1 继承<code>Thread</code>类</h5><p>继承 <code>Thread</code> 类，并重写其中的 <code>run()</code> 方法。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">'用Thread类实现线程'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h5 id="1-1-2-实现-Runnable-接口"><a href="#1-1-2-实现-Runnable-接口" class="headerlink" title="1.1.2 实现 Runnable 接口"></a>1.1.2 实现 <code>Runnable</code> 接口</h5><p>实现 <code>Runnable</code> 接口，实现其 <code>run()</code> 方法，然后将实现了 <code>Runnable</code> 接口的实例传递到 <code>Thread</code> 类中就可以实现多线程。 </p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunnableThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">'用实现Runnable接口实现线程'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h5 id="1-1-3-线程池创建线程"><a href="#1-1-3-线程池创建线程" class="headerlink" title="1.1.3 线程池创建线程"></a>1.1.3 线程池创建线程</h5><p>通过线程池来创建线程。线程中实现了很多线程，我们可以通过其构造器指定该线程池允许创建的线程的最大数量；比如：我们将线程池的数量设置为10，那么就将会有10个子线程来为我们工作。接下来，我们通过线程池中的代码来看看线程池是怎么创建线程的。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>

    <span class="token function">DefaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        SecurityManager s <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        group <span class="token operator">=</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> s<span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>
            Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        namePrefix <span class="token operator">=</span> <span class="token string">"pool-"</span> <span class="token operator">+</span>
            poolNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
            <span class="token string">"-thread-"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">public</span> Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> r<span class="token punctuation">,</span>
                    namePrefix <span class="token operator">+</span> threadNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Thread<span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span>
            t<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>对于线程池而言，本质上是通过线程工厂来创建线程的，默认采用 <code>DefaultThreadFactory</code>，它会给线程池创建的线程设置一些默认值，比如：线程的名字、是否是守护线程、线程的优先级等；最终还是通过 <code>new Thread()</code> 来创建线程，只是构造方法中传入的参数多一些。</p>
<h5 id="1-1-4-有返回值的-Callable-创建线程"><a href="#1-1-4-有返回值的-Callable-创建线程" class="headerlink" title="1.1.4 有返回值的 Callable 创建线程"></a>1.1.4 有返回值的 Callable 创建线程</h5><p><code>Runnable</code> 创建的线程时没有返回值的，而 <code>Callable</code> 和与之相关的 <code>Future</code> 和 <code>FutureTask</code> 可以把线程执行的结果作为返回值返回。如代码所示：实现 <code>Callable</code> 接口，并且泛型设置为 <code>Integer</code> ,然后返回一个随机整数。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">CallableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//创建线程池</span>
ExecutorService service <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//提交任务，并用 Future提交返回结果</span>
Future<span class="token operator">&lt;</span>Integer<span class="token operator">></span> future <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CallableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>无论是 <code>Callable</code> 还是 <code>FutureTask</code> ，它们首先和 <code>Runnable</code> 一样都是一个任务，是需要被执行的，而不是说它们本身就是一个线程。它们可以放到线程池中执行：如代码所示，<code>submit()</code> 方法把任务放到线程池中，并由线程池创建线程。</p>
<h4 id="1-2-总结，为什么实现线程只有一种方式"><a href="#1-2-总结，为什么实现线程只有一种方式" class="headerlink" title="1.2 总结，为什么实现线程只有一种方式"></a>1.2 总结，为什么实现线程只有一种方式</h4><p>根据前面的实现线程的方式，我们可以看到比如线程池、定时器等仅仅只是在 <code>new Thread()</code> 之外做了一层封装；最终都还是通过实现 <code>Runnable</code> 接口或者继承 <code>Thread</code> 类来实现的。</p>
<p>我们知道，启动线程的方式是调用 <code>start()</code> 方法，然后在 <code>start()</code> 方法中最终会调 <code>run()</code> 方法。</p>
<p>我们来看 <code>Thread</code> 类的时候可以发现，在 <code>Thread</code> 类的 <code>run()</code> 方法中做了如下操作： 判断 <code>target</code> 不为 <code>null</code> 的情况下，调用 <code>target</code> 的 <code>run()</code> 方法；而 <code>target</code> 实际上就是 <code>Runnable</code> 接口的一个实例，即使用 Runnable 接口实现线程时传给Thread类的对象。</p>
<p>继承 <code>Thread</code> 类，然后重写 <code>run()</code> 方法，重写后的<code>run()</code>方法中就是需要执行的任务，最终还是调用 <code>start()</code> 方法来启动线程。</p>
<p>所以创建线程就只有一种方式，就是构造一个 <code>Thread</code> 类，这是创建线程的唯一方式。</p>
<p>上面看到的实现线程的两种方式本质上都是一样的，就是构造一个 <code>Thread</code> 类，不同点在于<strong>实现线程运行内容的不同</strong> ：要买来自重写的 <code>run()</code> 方法，要么来自 <code>target</code> 的 <code>run()</code> 方法。</p>
<p><strong>所以我们可以这样描述：</strong></p>
<p>本质上，实现线程只有一种方式，而要想实现线程执行的内容，却有两种方式，也就是可以通过 实现 <code>Runnable</code> 接口的方式，或是继承 <code>Thread</code> 类重写 <code>run()</code> 方法的方式，把我们想要执行的代码传入，让线程去执行，在此基础上，如果我们还想有更多实现线程的方式，比如线程池和 <code>Timer</code> 定时器，只需要在此基础上进行封装即可。</p>
<h3 id="2-为什么说实现-Runnable-接口比继承-Thread-类实现线程要好"><a href="#2-为什么说实现-Runnable-接口比继承-Thread-类实现线程要好" class="headerlink" title="2. 为什么说实现 Runnable 接口比继承 Thread 类实现线程要好"></a>2. 为什么说实现 Runnable 接口比继承 Thread 类实现线程要好</h3><p>我们来总结一下实现 <code>Runnable</code> 接口比继承 <code>Thread</code> 类实现线程好在哪里？</p>
<ul>
<li>从代码架构考虑： <code>Runnable</code> 接口只有一个 <code>run()</code> 方法，它定义了需要执行的内容，在这种情况些 实现了 <code>Runnable</code> 类和 <code>Thread</code> 类的解耦；<code>Thread</code> 类负责启动线程和设置属性等，权责分明。</li>
<li>从性能考虑：使用继承 <code>Thread</code> 类来实现线程，没执行依次任务，就需要创建一个独立的线程；执行完成之后到生命周期的尽头，如果需要再次执行，就必须重新创建一个线程；在线程执行的任务量比较大的时候，带来的开销也很大。如果使用实现 <code>Runnable</code> 接口的方式来实现线程，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建/销毁线程，大大降低了性能开销。</li>
<li>从拓展性考虑：Java 语言不执行多继承，如果类一旦继承了 <code>Thread</code> 类，那么后续就不能继承其他的类。如果该类需要继承其他的一些类来实现功能上的拓展，就显得很局限了，限制了代码的拓展性。而Java运行多实现，则实现<code>Runnable</code> 接口方式来实现线程，则不会限制代码的拓展性。</li>
</ul>
<p><strong>综上所述：</strong></p>
<p>应该优先选择通过实现 Runnable 接口的方式来创建线程。</p>
<h2 id="二-如何正确停止线程"><a href="#二-如何正确停止线程" class="headerlink" title="二. 如何正确停止线程"></a>二. 如何正确停止线程</h2><p>通长情况下，我们不会停止一个线程，而是允许线程运行到结束，然后让它自然停止。但是依然也有许多特殊情况需要手动停止线程，比如：用户突然关闭程序，程序出错重启等。</p>
<h3 id="1-正确停止线程"><a href="#1-正确停止线程" class="headerlink" title="1. 正确停止线程"></a>1. 正确停止线程</h3><p>对于Java 程序而言，最正确的停止线程的方式是 <code>interrupt</code>,但 <code>interrupt</code> 仅仅起到通知被停止线程的作用。对于被停止线程而言，它完全具有自主权，可以选择立即停止 、过一会停止，或者不停止。那么为什么Java不提供强制停止线程的能力呢？</p>
<p>其实，Java 希望程序间能够相互通知，相互协作的管理线程，因为如果在不知道对方线程正在做的工作，贸然停止线程就可能造成一些安全问题，为了避免问题，就需要给对方线程一定的事件来处理收尾工作。 </p>
<h4 id="1-1-用-interrupt-停止线程"><a href="#1-1-用-interrupt-停止线程" class="headerlink" title="1.1 用 interrupt 停止线程"></a>1.1 用 interrupt 停止线程</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">islnterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> more work flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//do more work</span>
<span class="token punctuation">}</span></code></pre>
<p>一旦调用某个线程的 <code>interrupt()</code> 方法之后，这个线程的中断标记为就会被置为 <code>true</code> ；每个线程都有这样的标记位，当线程执行时，应该定期检查该标志位，如果标记为被置为 <code>true</code> ，就说明有程序想终止该线程。</p>
<p>在上面的代码中看到，在 <code>while</code> 循环体判断语句中，首先通过 <code>Thread.currentThread().islnterrupted()</code> 判断线程是否被中断，随后检查是否还有工作要做的标志位，两个条件都满足的情况下，才会继续执行下面的工作。</p>
<p>eg:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StopThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> count <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"count = "</span> <span class="token operator">+</span> count<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>在 <code>StopThread</code> 类的 <code>run()</code> 方法中，首先判断线程是否被中断，然后判断 <code>count</code> 是否小于 1000。这线程的工作内容就是打印0~999的数字，每打印一个数字，<code>count</code> 加 1 ；可以看到每次开始之前都会检查线程是否被中断。</p>
<p>在 <code>main</code> 函数中启动该线程，然后过 5 毫秒之后立刻终止线程，该线程会检测中断信号，于是在线程未执行完就会停止，这种就属于通过 <code>interrupt</code> 正确停止线程的情况。</p>
<h4 id="1-2-sleep-期间能否感受到中断"><a href="#1-2-sleep-期间能否感受到中断" class="headerlink" title="1.2 sleep 期间能否感受到中断"></a>1.2 sleep 期间能否感受到中断</h4><p>现在我们考虑一种特殊情况：在线程执行过程中有休眠需求，也就是每打印一次，进入一次 <code>sleep</code> ，将 <code>sleep</code> 时间设置为 10 秒；则改造后的代码如下</p>
<pre class=" language-java"><code class="language-java">Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> 
        num <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
            num<span class="token operator">++</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StopDuringSleep</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        Runnable runnable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> num <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    num<span class="token operator">++</span><span class="token punctuation">;</span>
                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>在主线程休眠 5 毫秒后，通知子线程中断，此时子线程仍然在执行 <code>sleep</code> 语句，处于休眠中。那么就需要考虑，在休眠中的线程能否感受到中断通知呢？如果需要等到线程休眠结束后，那岂不响应中断太不及时了。</p>
<p>在 Java 设计之初，如果 <code>sleep</code>,<code>wait</code> 等可以让线程进入阻塞的方法使得线程休眠了，而处于休眠中的线程被中断，那么线程是可以感受到中断信号的，并且会抛出一个 <code>InterruptedException</code> 异常，同时清除中断信号，将中断标记为置为false；这样，就不用担心长时间休眠中的线程感受不到中断了，因为即便现在还在休眠中，仍然能够响应中断通知，并抛出异常。</p>
<h4 id="1-3-相应中断的两种最佳处理方式"><a href="#1-3-相应中断的两种最佳处理方式" class="headerlink" title="1.3 相应中断的两种最佳处理方式"></a>1.3 相应中断的两种最佳处理方式</h4><p>在实际开发中肯定是团队协作的，不同的人负责编写不同的方法，然后相互调用来实现整个业务的逻辑。那么如果我们负责编写的方法需要被别人调用，同时我们的方法内调用了 sleep 或者 wait 等能响应中断的方法时，仅仅 catch 住异常是不够的。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">subTas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 在这里不处理该异常是非常不好的</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>我们可以在方法中使用 try/catch 或在方法签名中声明 throws  InterruptedException。</p>
<h5 id="1-3-1-方法签名抛异常，run-强制-try-catch"><a href="#1-3-1-方法签名抛异常，run-强制-try-catch" class="headerlink" title="1.3.1 方法签名抛异常，run() 强制 try/catch"></a>1.3.1 方法签名抛异常，run() 强制 try/catch</h5><p>上面代码所示 <code>catch</code> 语句块里是空的，并没有进行任何处理。假设线程执行到这个方法，并且正在 <code>sleep</code> ，此时有线程发送 <code>interrupt</code> 通知试图中断线程，就会抛出异常，并清除中断信号。抛出的异常被 <code>catch</code> 语句块捕捉。</p>
<p>但是，捕捉到异常的 <code>catch</code> 没有进行任何处理逻辑，相当于把中断信号给隐藏了，这样做是很不合理的。我们可以选择在方法签名中抛出异常</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">subTask2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>正如代码所示：要求每一个方法的调用方有义务去处理异常。调用方要不使用 <code>try/catch</code> 并在 <code>catch</code> 中正确处理异常，要不将异常声明到方法签名中。如果每层逻辑都遵守规范，便可以将中断信号传递到顶层，最终让 <code>run()</code> 方法可以捕获异常。对于 <code>run()</code> 方法而言，它本身没有抛出异常的能力，只能通过 <code>try/catch</code> 来处理异常；可以根据不同的业务逻辑来进行相应的处理。</p>
<h5 id="1-3-2-再次中断"><a href="#1-3-2-再次中断" class="headerlink" title="1.3.2 再次中断"></a>1.3.2 再次中断</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>除了刚刚推荐的将异常声明到方法签名中的方式以外，还可以在 <code>catch</code> 语句中再次中断线程。如代码所示，需要在 <code>catch</code> 语句块中调用 <code>Thread.currentThread().interrupt()</code>函数。因为如果线程在休眠期间被中断，那么会自动清除中断信号。如果这时候手动添加中断信号，中断信号依然可以被捕捉到。这样后续执行的方法依然可以检测到这里发生过中断，可以做出相应的处理，整个线程可以正常退出</p>
<h3 id="2-为什么-volatile-标记位的停止方法是错误的？"><a href="#2-为什么-volatile-标记位的停止方法是错误的？" class="headerlink" title="2. 为什么 volatile 标记位的停止方法是错误的？"></a>2. 为什么 volatile 标记位的停止方法是错误的？</h3><h4 id="2-1-错误的停止方法"><a href="#2-1-错误的停止方法" class="headerlink" title="2.1 错误的停止方法"></a>2.1 错误的停止方法</h4><p>首先，我们来看几种线程停止的错误的方法：比如：<code>stop()</code> , <code>suspend()</code> 和 <code>resume()</code>,这些方法已经被 Java 标记为 <code>@Deprecated</code>。我们不应该再使用它们。因为 <code>stop()</code> 会直接把线程停止，这样就没有给足够的事件来处理想要在停止之前保存数据的逻辑，任务嘎然而止，会导致出现数据完整性等问题。</p>
<p>对于 <code>suspend()</code> 和 <code>resume()</code> 而言，它们的问题在于如果线程调用 <code>suspend()</code> ,它并不会释放锁，就开始进入休眠，但此时有可能扔持有锁，这样就容易导致死锁，因为这把锁在线程被 <code>resume()</code> 之前，是不会释放的。</p>
<p>正因为有这样的风险，所以 <code>suspend()</code> 和 <code>resume()</code> 组合使用的方式也被废弃了。</p>
<p>接下来我们来看一下，为什么用 <code>volatile</code> 标记位的停止方法也是错误的？</p>
<h4 id="2-2-volatile-修饰标记位使用的场景"><a href="#2-2-volatile-修饰标记位使用的场景" class="headerlink" title="2.2 volatile 修饰标记位使用的场景"></a>2.2 volatile 修饰标记位使用的场景</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileCanStop</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> canceled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>canceled <span class="token operator">&amp;&amp;</span> num <span class="token operator">&lt;=</span> <span class="token number">1000000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token string">"是10的倍数。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                num<span class="token operator">++</span><span class="token punctuation">;</span>
                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        VolatileCanStop r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VolatileCanStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        r<span class="token punctuation">.</span>canceled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>如代码所示：声明了一个叫做 <code>VolatileStopThread</code> 的类，它实现了 <code>Runnable</code> 接口，然后在 <code>run()</code> 中进行 <code>while</code> 循环，在循环体中进行了两层判断，首先判断 <code>canceled</code> 变量的值（<code>canceled</code> 变量是一个被 <code>volatile</code> 修饰的初始值为 false 的布尔值），当该值变为 true 时，<code>while</code> 跳出循环，<code>while</code> 第二个判断是 <code>num</code> 值小于 1000000 ，在 <code>while</code> 循环体中，只要是10的倍数，就打印出来，然后 <code>num++</code> 。</p>
<p>接下来，在 <code>main()</code> 方法中，首先启动线程，然后经过3秒中的时间， 把用 <code>volatile</code> 修饰的布尔值标记位设置为 true，这样，正在运行的线程就会在下一次 <code>while</code> 循环判断中判断出 <code>canceled</code> 的值已经变为 true 了，这样就不再满足 <code>while</code> 的判断条件，跳出整个 <code>while</code> 循环，线程就停止了，这种情况是演示 <code>volatile</code> 修饰的标记位可以正常工作的情况。</p>
<h4 id="2-3-volatile-修饰标记位不适用的场景"><a href="#2-3-volatile-修饰标记位不适用的场景" class="headerlink" title="2.3 volatile 修饰标记位不适用的场景"></a>2.3 volatile 修饰标记位不适用的场景</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> canceled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    BlockingQueue storage<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">Producer</span><span class="token punctuation">(</span>BlockingQueue storage<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> storage<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;=</span> <span class="token number">100000</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>canceled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">50</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    storage<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token string">"是50的倍数,被放到仓库中了。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                num<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者结束运行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>首先，声明了一个生产者 <code>Producer</code> ，通过 <code>volatile</code> 标记的初始值为 false 的布尔值 <code>canceled</code> 来停止线程。在 <code>run()</code> 方法中， <code>while</code> 的判断语句是 num 是否小于 100000 以及 <code>canceled</code> 是否被标记。<code>while</code> 循环体中判断 <code>num</code> 如果是 50 的倍数就放到 <code>storage</code> 仓库中 ，<code>storage</code> 是生产者与消费者质检通信的存储器，当 <code>num</code> 大于 100000 或被通知停止时，会跳出 <code>while</code> 循环并执行 <code>finally</code> 语句块，告诉大家 『生产者结束运行』</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>
    BlockingQueue storage<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span>BlockingQueue storage<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> storage<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">needMoreNums</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0.97</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>对于消费者 <code>Consumer</code> ，它与生产者共用同一个仓库 <code>storage</code> ，并且在方法内通过 <code>needMoreNums()</code> 方法判断是否需要继续使用更多的数字，刚才生产者生产了一些 50 的倍数供消费者使用，消费者是否继续使用数字的判断条件时产生一个随机数并与 0.97 进行比较，大于 0.97 就不在继续使用数字。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        ArrayBlockingQueue storage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Producer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread producerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>producer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        producerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Consumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>consumer<span class="token punctuation">.</span><span class="token function">needMoreNums</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>consumer<span class="token punctuation">.</span>storage<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"被消费了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者不需要更多数据了。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//一旦消费不需要更多数据了，我们应该让生产者也停下来，但是实际情况却停不下来</span>
        producer<span class="token punctuation">.</span>canceled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>producer<span class="token punctuation">.</span>canceled<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>在 <code>main()</code> 函数中，首先创建了生产者/消费者共用的仓库 <code>BlockingQueue storage</code>，仓库容量是 8，并且建立生产者并将生产者放入线程后启动线程，启动后进行 500 毫秒的休眠，这是生产者会阻塞， 500 毫秒后消费者被创建出来，并判断是否需要更多的数字，然后每次消费后休眠 100 毫秒，这样的业务逻辑是有可能出现在实际生产中的。</p>
<p>当消费者不再需要数据，就会将 <code>canceled</code> 的标记位设置为 true ，理论上此时生产者就会跳出 <code>while</code> 循环，并打印出 『 生产者运行结束』。</p>
<p>然而结果并不是我们想象的那样，尽管已经把 <code>canceled</code> 设置为 true ， 但生产者仍然没有停止，这是因为在这种情况下，生产者在执行 <code>storage.put(num)</code> 时发生阻塞，在它被唤醒之前是没办法进入下一次循环判断 <code>canceled</code> 的值的，所以这种情况下用 <code>volatile</code> 是没有办法让生产者停下来的，相反如果用 <code>interrupt</code> 语句来中断，即便生产者处理阻塞状态，仍然能够感受到中断信号，并做响应处理。</p>
<h2 id="三-线程的6中状态的切换"><a href="#三-线程的6中状态的切换" class="headerlink" title="三. 线程的6中状态的切换"></a>三. 线程的6中状态的切换</h2><h3 id="1-线程的6中状态"><a href="#1-线程的6中状态" class="headerlink" title="1. 线程的6中状态"></a>1. 线程的6中状态</h3><p>在 Java 中线程的生命周期中一共有6种状态</p>
<ul>
<li>New（新建）</li>
<li>Runnable（可运行）</li>
<li>Blocked（被阻塞）</li>
<li>Waiting（等待）</li>
<li>Timed Waiting（计时等待）</li>
<li>Terminated （被终止）</li>
</ul>
<p>如果想要确定线程当前的状态，可以通过 getState() 方法，并且线程在任何时刻只可能处于 1 种状态。</p>
<p>下面我们来逐个介绍线程的 6 种状态：</p>
<h4 id="1-1-New-新创建"><a href="#1-1-New-新创建" class="headerlink" title="1.1 New 新创建"></a>1.1 New 新创建</h4><img src="/images/java_thread/thread_state_new.png" alt="New" style="background-color:#fff" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/images/java_thread/thread_state_new.png" class="lozad post-image">

<p>New 表示线程被创建但尚未启动的状态：当我们用 new Thread() 新建一个线程时，如果线程没有开始运行 start() 方法，所以也没有开始执行 run() 方法里面的代码，那么此时它的状态就是 New。而一旦线程调用了 start()，它的状态就会从 New 变成 Runnable状态。</p>
<h4 id="1-2-Runnable-可运行"><a href="#1-2-Runnable-可运行" class="headerlink" title="1.2 Runnable 可运行"></a>1.2 Runnable 可运行</h4><img src="/images/java_thread/thread_state_runnable.png" alt="img" style="background-color:#fff;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/images/java_thread/thread_state_runnable.png" class="lozad post-image">

<p>Java 中的 Runable 状态对应操作系统线程状态中的两种状态，分别是 Running 和 Ready，也就是说，Java 中处于 Runnable 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。</p>
<p>所以，如果一个正在运行的线程是 Runnable 状态，当它运行到任务的一半时，执行该线程的 CPU 被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是 Runnable，因为它有可能随时被调度回来继续执行任务。</p>
<h4 id="1-3-Blocked-阻塞状态"><a href="#1-3-Blocked-阻塞状态" class="headerlink" title="1.3 Blocked 阻塞状态"></a>1.3 Blocked 阻塞状态</h4><img src="/images/java_thread/thread_state_blocked.png" alt="img" style="background-color:#fff;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/images/java_thread/thread_state_blocked.png" class="lozad post-image">

<p>从 Runnable 状态进入 Blocked 状态只有一种可能，就是进入 synchronized 保护的代码时没有抢到 monitor 锁，无论是进入 synchronized 代码块，还是 synchronized 方法；当处于 Blocked 的线程抢到 monitor 锁，就会从 Blocked 状态回到Runnable 状态。</p>
<h4 id="1-4-Waiting-等待"><a href="#1-4-Waiting-等待" class="headerlink" title="1.4 Waiting 等待"></a>1.4 Waiting 等待</h4><img src="/images/java_thread/thread_state_waiting.png" alt="img" style="background-color:#fff;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/images/java_thread/thread_state_waiting.png" class="lozad post-image">

<p>线程进入 Waiting 状态有三种可能性。</p>
<ul>
<li>没有设置 Timeout 参数的 Object.wait() 方法。</li>
<li>没有设置 Timeout 参数的 Thread.join() 方法。</li>
<li>LockSupport.park() 方法。</li>
</ul>
<p>刚才强调过，Blocked 仅仅针对 synchronized monitor 锁，可是在 Java 中还有很多其他的锁，比如 ReentrantLock，如果线程在获取这种锁时没有抢到该锁就会进入 Waiting 状态，因为本质上它执行了 LockSupport.park() 方法，所以会进入 Waiting 状态。同样，Object.wait() 和 Thread.join() 也会让线程进入 Waiting 状态。 </p>
<p>Blocked 与 Waiting 的区别是 Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()/notifyAll() 。</p>
<h4 id="1-5-Timed-Waiting-限期等待"><a href="#1-5-Timed-Waiting-限期等待" class="headerlink" title="1.5 Timed Waiting 限期等待"></a>1.5 Timed Waiting 限期等待</h4><img src="/images/java_thread/thread_state_timed_waiting.png" alt="img" style="background-color:#fff;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/images/java_thread/thread_state_timed_waiting.png" class="lozad post-image">

<p>在 Waiting 上面是 Timed Waiting 状态，这两个状态是非常相似的，区别仅在于有没有时间限制，Timed Waiting 会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒。</p>
<p>以下情况会让线程进入 Timed Waiting 状态。</p>
<ul>
<li>设置了时间参数的 Thread.sleep(long millis) 方法；</li>
<li>设置了时间参数的 Object.wait(long timeout) 方法；</li>
<li>设置了时间参数的 Thread.join(long millis) 方法；</li>
<li>设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。</li>
</ul>
<p><strong>如果其他线程调用 notify() 或 notifyAll()来唤醒它，它会直接进入 Blocked 状态，这是为什么呢？因为唤醒 Waiting 线程的线程如果调用 notify() 或 notifyAll()，要求必须首先持有该 monitor 锁，所以处于 Waiting 状态的线程被唤醒时拿不到该锁，就会进入 Blocked 状态，直到执行了 notify()/notifyAll() 的唤醒它的线程执行完毕并释放 monitor 锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从 Blocked 状态回到 Runnable 状态。</strong></p>
<p>同样在 Timed Waiting 中执行 notify() 和 notifyAll() 也是一样的道理，它们会先进入 Blocked 状态，然后抢夺锁成功后，再回到 Runnable 状态。</p>
<p>当然对于 Timed Waiting 而言，如果它的超时时间到了且能直接获取到锁/join的线程运行结束/被中断/调用了LockSupport.unpark()，会直接恢复到 Runnable 状态，而无需经历 Blocked 状态。</p>
<h4 id="1-6-Terminated-终止"><a href="#1-6-Terminated-终止" class="headerlink" title="1.6 Terminated 终止"></a>1.6 Terminated 终止</h4><img src="/images/java_thread/thread_state_terminated.png" alt="img" style="background-color:#fff;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/images/java_thread/thread_state_terminated.png" class="lozad post-image">

<p>要想进入这个Terminated 终止状态有两种可能。</p>
<ul>
<li><p>run() 方法执行完毕，线程正常退出。</p>
</li>
<li><p>出现一个没有捕获的异常，终止了 run() 方法，最终导致意外终止。</p>
</li>
</ul>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>最后我们再看线程转换的两个注意点。</p>
<ol>
<li>线程的状态是需要按照箭头方向来走的，比如线程从 New 状态是不可以直接进入 Blocked 状态的，它需要先经历 Runnable 状态。</li>
<li>线程生命周期不可逆：一旦进入 Runnable 状态就不能回到 New 状态；一旦被终止就不可能再有任何状态的变化。所以一个线程只能有一次 New 和 Terminated 状态，只有处于中间状态才可以相互转换。</li>
</ol>
<h2 id="四-wait-notify-notifyAll-方法的使用注意事项"><a href="#四-wait-notify-notifyAll-方法的使用注意事项" class="headerlink" title="四. wait/notify/notifyAll 方法的使用注意事项"></a>四. wait/notify/notifyAll 方法的使用注意事项</h2><p>从以下三个问题入手学习 wait/notify/notifyAll 方法的使用注意事项：</p>
<ul>
<li>为什么 wait 方法必须在 synchronized 保护的同步代码中使用？</li>
<li>为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？</li>
<li>wait/notify 和 sleep 方法的异同？</li>
</ul>
<h3 id="1-为什么-wait-方法必须在-synchronized-保护的同步代码中使用？"><a href="#1-为什么-wait-方法必须在-synchronized-保护的同步代码中使用？" class="headerlink" title="1. 为什么 wait 方法必须在 synchronized 保护的同步代码中使用？"></a>1. 为什么 wait 方法必须在 synchronized 保护的同步代码中使用？</h3><p>首先，我们来看看 wait 方法的源码注释是怎么写的。</p>
<p>“wait method should always be used in a loop:</p>
<pre class=" language-java"><code class="language-java"> <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">while</span> <span class="token punctuation">(</span>condition does not hold<span class="token punctuation">)</span>
         obj<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// Perform action appropriate to condition</span>
<span class="token punctuation">}</span></code></pre>
<p>This method should only be called by a thread that is the owner of this object’s monitor.”</p>
<p>意思是说，在使用 wait 方法时，必须把 wait 方法写在 synchronized 保护的 while 代码块中，并始终判断执行条件是否满足，如果满足就往下继续执行，如果不满足就执行 wait 方法，而在执行 wait 方法之前，必须先持有对象的 monitor 锁，也就是通常所说的 synchronized 锁。那么设计成这样有什么好处呢？</p>
<p>我们逆向思考这个问题，如果不要求 wait 方法放在 synchronized 保护的同步代码中使用，而是可以随意调用，那么就有可能写出这样的代码。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">BlockingQueue</span> <span class="token punctuation">{</span>
    Queue<span class="token operator">&lt;</span>String<span class="token operator">></span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">give</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        buffer<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Since someone may be waiting in take</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> String <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> buffer<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>在代码中可以看到有两个方法，give 方法负责往 buffer 中添加数据，添加完之后执行 notify 方法来唤醒之前等待的线程，而 take 方法负责检查整个 buffer 是否为空，如果为空就进入等待，如果不为空就取出一个数据，这是典型的生产者消费者的思想。</p>
<p>但是这段代码并没有受 synchronized 保护，于是便有可能发生以下场景：</p>
<ul>
<li>首先，消费者线程调用 take 方法并判断 buffer.isEmpty 方法是否返回 true，若为 true 代表buffer是空的，则线程希望进入等待，但是在线程调用 wait 方法之前，就被调度器暂停了，所以此时还没来得及执行 wait 方法。</li>
<li>此时生产者开始运行，执行了整个 give 方法，它往 buffer 中添加了数据，并执行了 notify 方法，但 notify 并没有任何效果，因为消费者线程的 wait 方法没来得及执行，所以没有线程在等待被唤醒。</li>
<li>此时，刚才被调度器暂停的消费者线程回来继续执行 wait 方法并进入了等待。<br>虽然刚才消费者判断了 buffer.isEmpty 条件，但真正执行 wait 方法时，之前的 buffer.isEmpty 的结果已经过期了，不再符合最新的场景了，因为这里的“判断-执行”不是一个原子操作，它在中间被打断了，是线程不安全的。</li>
</ul>
<p>假设这时没有更多的生产者进行生产，消费者便有可能陷入无穷无尽的等待，因为它错过了刚才 give 方法内的 notify 的唤醒。</p>
<p>我们看到正是因为 wait 方法所在的 take 方法没有被 synchronized 保护，所以它的 while 判断和 wait 方法无法构成原子操作，那么此时整个程序就很容易出错。</p>
<p>我们把代码改写成源码注释所要求的被 synchronized 保护的同步代码块的形式，代码如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">give</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      buffer<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> String <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
   <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token keyword">return</span> buffer<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这样就可以确保 notify 方法永远不会在 buffer.isEmpty 和 wait 方法之间被调用，提升了程序的安全性。</p>
<p>另外，wait 方法会释放 monitor 锁，这也要求我们必须首先进入到 synchronized 内持有这把锁。</p>
<p>这里还存在一个“虚假唤醒”（spurious wakeup）的问题，线程可能在既没有被notify/notifyAll，也没有被中断或者超时的情况下被唤醒，这种唤醒是我们不希望看到的。虽然在实际生产中，虚假唤醒发生的概率很小，但是程序依然需要保证在发生虚假唤醒的时候的正确性，所以就需要采用while循环的结构。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>condition does not hold<span class="token punctuation">)</span>
    obj<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这样即便被虚假唤醒了，也会再次检查while里面的条件，如果不满足条件，就会继续wait，也就消除了虚假唤醒的风险。</p>
<h3 id="2-为什么-wait-notify-notifyAll-被定义在-Object-类中，而-sleep-定义在-Thread-类中？"><a href="#2-为什么-wait-notify-notifyAll-被定义在-Object-类中，而-sleep-定义在-Thread-类中？" class="headerlink" title="2. 为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？"></a>2. 为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？</h3><p>为什么 wait/notify/notifyAll 方法被定义在 Object 类中？而 sleep 方法定义在 Thread 类中？主要有两点原因：</p>
<ul>
<li>因为 Java 中每个对象都有一把称之为 monitor 监视器的锁，由于每个对象都可以上锁，这就要求在对象头中有一个用来保存锁信息的位置。这个锁是对象级别的，而非线程级别的，wait/notify/notifyAll 也都是锁级别的操作，它们的锁属于对象，所以把它们定义在 Object 类中是最合适，因为 Object 类是所有对象的父类。</li>
<li>因为如果把 wait/notify/notifyAll 方法定义在 Thread 类中，会带来很大的局限性，比如一个线程可能持有多把锁，以便实现相互配合的复杂逻辑，假设此时 wait 方法定义在 Thread 类中，如何实现让一个线程持有多把锁呢？又如何明确线程等待的是哪把锁呢？既然我们是让当前线程去等待某个对象的锁，自然应该通过操作对象来实现，而不是操作线程。</li>
</ul>
<h3 id="3-wait-notify-和-sleep-方法的异同"><a href="#3-wait-notify-和-sleep-方法的异同" class="headerlink" title="3. wait/notify 和 sleep 方法的异同"></a>3. wait/notify 和 sleep 方法的异同</h3><p>对比 wait/notify 和 sleep 方法的异同，主要对比 wait 和 sleep 方法，我们先说相同点：</p>
<ul>
<li><p>它们都可以让线程阻塞。</p>
</li>
<li><p>它们都可以响应 interrupt 中断：在等待的过程中如果收到中断信号，都可以进行响应，并抛出 InterruptedException 异常。</p>
</li>
</ul>
<p>但是它们也有很多的不同点：</p>
<ul>
<li>wait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求。</li>
<li>在同步代码中执行 sleep 方法时，并不会释放 monitor 锁，但执行 wait 方法时会主动释放 monitor 锁。</li>
<li>sleep 方法中会要求必须定义一个时间，时间到期后会主动恢复，而对于没有参数的 wait 方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并不会主动恢复。</li>
<li>wait/notify 是 Object 类的方法，而 sleep 是 Thread 类的方法。</li>
</ul>
<h2 id="五-有哪几种实现生产者消费者模式的方法"><a href="#五-有哪几种实现生产者消费者模式的方法" class="headerlink" title="五. 有哪几种实现生产者消费者模式的方法"></a>五. 有哪几种实现生产者消费者模式的方法</h2><h3 id="5-1-生产者消费者模式"><a href="#5-1-生产者消费者模式" class="headerlink" title="5.1 生产者消费者模式"></a>5.1 生产者消费者模式</h3><p>我们先来看看什么是生产者消费者模式，生产者消费者模式是程序设计中非常常见的一种设计模式，被广泛运用在解耦、消息队列等场景。在现实世界中，我们把生产商品的一方称为生产者，把消费商品的一方称为消费者，有时生产者的生产速度特别快，但消费者的消费速度跟不上，俗称“产能过剩”，又或是多个生产者对应多个消费者时，大家可能会手忙脚乱。如何才能让大家更好地配合呢？这时在生产者和消费者之间就需要一个中介来进行调度，于是便诞生了生产者消费者模式。</p>
<img src="/images/java_thread/thread_producer_consumer.png" alt="img" style="background-color:#fff;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/images/java_thread/thread_producer_consumer.png" class="lozad post-image">

<p>使用生产者消费者模式通常需要在两者之间增加一个阻塞队列作为媒介，有了媒介之后就相当于有了一个缓冲，平衡了两者的能力，整体的设计如图所示，最上面是阻塞队列，右侧的 1 是生产者线程，<strong>生产者在生产数据后将数据存放在阻塞队列中</strong>，左侧的 2 是消费者线程，<strong>消费者获取阻塞队列中的数据</strong>。而中间的 3 和 4 分别代表生产者消费者之间互相通信的过程，因为无论阻塞队列是满还是空都可能会产生阻塞，<strong>阻塞之后就需要在合适的时机去唤醒被阻塞的线程</strong>。</p>
<p>那么什么时候阻塞线程需要被唤醒呢？有两种情况:</p>
<ul>
<li>第一种情况是当消费者看到阻塞队列为空时，开始进入等待，这时生产者一旦往队列中放入数据，就会通知所有的消费者，唤醒阻塞的消费者线程。</li>
<li>另一种情况是如果生产者发现队列已经满了，也会被阻塞，而一旦消费者获取数据之后就相当于队列空了一个位置，这时消费者就会通知所有正在阻塞的生产者进行生产。</li>
</ul>
<h3 id="5-2-如何用-BlockingQueue-实现生产者消费者模式"><a href="#5-2-如何用-BlockingQueue-实现生产者消费者模式" class="headerlink" title="5.2 如何用 BlockingQueue 实现生产者消费者模式"></a>5.2 如何用 BlockingQueue 实现生产者消费者模式</h3><p>我们接下来看如何用 wait/notify/Condition/BlockingQueue 实现生产者消费者模式，先从最简单的 BlockingQueue 开始讲起：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  BlockingQueue<span class="token operator">&lt;</span>Object<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 Runnable producer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>producer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>producer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Runnable consumer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>如代码所示，首先，创建了一个 ArrayBlockingQueue 类型的 BlockingQueue，命名为 queue 并将它的容量设置为 10；其次，创建一个简单的生产者，while(true) 循环体中的queue.put() 负责往队列添加数据；然后，创建两个生产者线程并启动；同样消费者也非常简单，while(true) 循环体中的 queue.take() 负责消费数据，同时创建两个消费者线程并启动。为了代码简洁并突出设计思想，代码里省略了 try/catch 检测，我们不纠结一些语法细节。以上便是利用 BlockingQueue 实现生产者消费者模式的代码。虽然代码非常简单，但实际上 ArrayBlockingQueue 已经在背后完成了很多工作，比如队列满了就去阻塞生产者线程，队列有空就去唤醒生产者线程等。</p>
<h3 id="5-3-如何用-Condition-实现生产者消费者模式"><a href="#5-3-如何用-Condition-实现生产者消费者模式" class="headerlink" title="5.3 如何用 Condition 实现生产者消费者模式"></a>5.3 如何用 Condition 实现生产者消费者模式</h3><p>BlockingQueue 实现生产者消费者模式看似简单，背后却暗藏玄机，我们在掌握这种方法的基础上仍需要掌握更复杂的实现方法。我们接下来看如何在掌握了 BlockingQueue 的基础上利用 Condition 实现生产者消费者模式，它们背后的实现原理非常相似，相当于我们自己实现一个简易版的 BlockingQueue：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBlockingQueueForCondition</span> <span class="token punctuation">{</span>

   <span class="token keyword">private</span> Queue queue<span class="token punctuation">;</span>
   <span class="token keyword">private</span> <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
   <span class="token keyword">private</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">private</span> Condition notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">private</span> Condition notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


   <span class="token keyword">public</span> <span class="token function">MyBlockingQueueForCondition</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>max <span class="token operator">=</span> size<span class="token punctuation">;</span>
       queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
       lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">try</span> <span class="token punctuation">{</span>
           <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
           queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
           notEmpty<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
           lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">public</span> Object <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
       lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">try</span> <span class="token punctuation">{</span>
           <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
           Object item <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           notFull<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">return</span> item<span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
           lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>如代码所示，首先，定义了一个队列变量 queue 并设置最大容量为 16；其次，定义了一个 ReentrantLock 类型的 Lock 锁，并在 Lock 锁的基础上创建两个 Condition，一个是 notEmpty，另一个是 notFull，分别代表队列没有空和没有满的条件；最后，声明了 put 和 take 这两个核心方法。</p>
<p>因为生产者消费者模式通常是面对多线程的场景，需要一定的同步措施保障线程安全，所以在 put 方法中先将 Lock 锁上，然后，在 while 的条件里检测 queue 是不是已经满了，如果已经满了，则调用 notFull 的 await() 阻塞生产者线程并释放 Lock，如果没有满，则往队列放入数据并利用 notEmpty.signalAll() 通知正在等待的所有消费者并唤醒它们。最后在 finally 中利用 lock.unlock() 方法解锁，把 unlock 方法放在 finally 中是一个基本原则，否则可能会产生无法释放锁的情况。</p>
<p>下面再来看 take 方法，take 方法实际上是与 put 方法相互对应的，同样是通过 while 检查队列是否为空，如果为空，消费者开始等待，如果不为空则从队列中获取数据并通知生产者队列有空余位置，最后在 finally 中解锁。</p>
<p>这里需要注意，我们在 take() 方法中使用 while( queue.size() == 0 ) 检查队列状态，而不能用 if( queue.size() == 0 )。为什么呢？大家思考这样一种情况，因为生产者消费者往往是多线程的，我们假设有两个消费者，第一个消费者线程获取数据时，发现队列为空，便进入等待状态；因为第一个线程在等待时会释放 Lock 锁，所以第二个消费者可以进入并执行 if( queue.size() == 0 )，也发现队列为空，于是第二个线程也进入等待；而此时，如果生产者生产了一个数据，便会唤醒两个消费者线程，而两个线程中只有一个线程可以拿到锁，并执行 queue.remove 操作，另外一个线程因为没有拿到锁而卡在被唤醒的地方，而第一个线程执行完操作后会在 finally 中通过 unlock 解锁，而此时第二个线程便可以拿到被第一个线程释放的锁，继续执行操作，也会去调用 queue.remove 操作，然而这个时候队列已经为空了，所以会抛出 NoSuchElementException 异常，这不符合我们的逻辑。而如果用 while 做检查，当第一个消费者被唤醒得到锁并移除数据之后，第二个线程在执行 remove 前仍会进行 while 检查，发现此时依然满足 queue.size() == 0 的条件，就会继续执行 await 方法，避免了获取的数据为 null 或抛出异常的情况。</p>
<h3 id="5-4-如何用-wait-notify-实现生产者消费者模式"><a href="#5-4-如何用-wait-notify-实现生产者消费者模式" class="headerlink" title="5.4 如何用 wait/notify 实现生产者消费者模式"></a>5.4 如何用 wait/notify 实现生产者消费者模式</h3><p>最后我们再来看看使用 wait/notify 实现生产者消费者模式的方法，实际上实现原理和Condition 是非常类似的，它们是兄弟关系：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyBlockingQueue</span> <span class="token punctuation">{</span>

   <span class="token keyword">private</span> <span class="token keyword">int</span> maxSize<span class="token punctuation">;</span>
   <span class="token keyword">private</span> LinkedList<span class="token operator">&lt;</span>Object<span class="token operator">></span> storage<span class="token punctuation">;</span>

   <span class="token keyword">public</span> <span class="token function">MyBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>maxSize <span class="token operator">=</span> size<span class="token punctuation">;</span>
       storage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
       <span class="token keyword">while</span> <span class="token punctuation">(</span>storage<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> maxSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       storage<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
       <span class="token keyword">while</span> <span class="token punctuation">(</span>storage<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>storage<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>如代码所示，最主要的部分仍是 take 与 put 方法，我们先来看 put 方法，put 方法被 synchronized 保护，while 检查队列是否为满，如果不满就往里放入数据并通过 notifyAll() 唤醒其他线程。同样，take 方法也被 synchronized 修饰，while 检查队列是否为空，如果不为空就获取数据并唤醒其他线程。使用这个 MyBlockingQueue 实现的生产者消费者代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
* 描述：     wait形式实现生产者消费者模式
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WaitStyle</span> <span class="token punctuation">{</span>

   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       MyBlockingQueue myBlockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyBlockingQueue</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       Producer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>myBlockingQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
       Consumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>myBlockingQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>producer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

   <span class="token keyword">private</span> MyBlockingQueue storage<span class="token punctuation">;</span>

   <span class="token keyword">public</span> <span class="token function">Producer</span><span class="token punctuation">(</span>MyBlockingQueue storage<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> storage<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">try</span> <span class="token punctuation">{</span>
               storage<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>

   <span class="token keyword">private</span> MyBlockingQueue storage<span class="token punctuation">;</span>

   <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span>MyBlockingQueue storage<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> storage<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">try</span> <span class="token punctuation">{</span>
               storage<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>以上就是三种实现生产者消费者模式的示例，其中，第一种 BlockingQueue 模式实现比较简单，但其背后的实现原理在第二种、第三种实现方法中得以体现，第二种、第三种实现方法本质上是我们自己实现了 BlockingQueue 的一些核心逻辑，供生产者与消费者使用。</p>

  </div>
  <div>
  
  <div class="post-note note-warning copyright" style="margin-top: 42px">
    <p><span style="font-weight: bold;">作者：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://blog.onestravel.cn/about">一个人的旅行</a></p>
    <p><span style="font-weight: bold;">文章链接：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://blog.onestravel.cn/20210920/f8c53c115779/">https://blog.onestravel.cn/20210920/f8c53c115779/</a></p>
    <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
  </div>
  
  </div>
</article>
<div class="nav">
  
  
  <div class="nav-item-next">
    <a href="/20210728/9c2efe6aefcb/" class="nav-link">
      <div>
        <div class="nav-label">下一篇</div>
        
        <div class="nav-title">【笔记四】编译插桩操纵字节码，实现不可能完成的任务 </div>
        
      </div>
      <i class="iconfont icon-right nav-next-icon"></i>
    </a>
  </div>
  
</div>

<div class="card card-content comment-card" style="margin-top: 16px;">
  <div class="comment-card-title">评论</div>
  
  <div id="gitalk-container"></div>
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

  
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>

  
<script src="/js/lib/md5.min.js"></script>

  <script>
    var gitalk = new Gitalk({
      clientID: 'a52a65db0a634019e27f',
      clientSecret: 'a04eaebc103e73d3769221171a4b87b55b39998d',
      repo: 'onestravel.github.io',
      owner: 'onestravel',
      admin: "onestravel",
      id: md5(location.href),
      distractionFreeMode: true,
      language: 'navigator.language || navigator.userLanguage',
      labels: ["Gitalk"],
      perPage: 10
    })

    gitalk.render('gitalk-container')
  </script>

</div>

<div class="card card-content toc-card" id="mobiletoc">
  <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">【并发编程】线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">一. 实现线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BD%95%E8%AF%B4%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">1. 为何说只有一种实现线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">1.1 常见的实现线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-text">1.1.1 继承Thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3"><span class="toc-text">1.1.2 实现 Runnable 接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.1.3 线程池创建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-4-%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84-Callable-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.1.4 有返回值的 Callable 创建线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%80%BB%E7%BB%93%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2 总结，为什么实现线程只有一种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3%E6%AF%94%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E8%A6%81%E5%A5%BD"><span class="toc-text">2. 为什么说实现 Runnable 接口比继承 Thread 类实现线程要好</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">二. 如何正确停止线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%AD%A3%E7%A1%AE%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">1. 正确停止线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%94%A8-interrupt-%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.1 用 interrupt 停止线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-sleep-%E6%9C%9F%E9%97%B4%E8%83%BD%E5%90%A6%E6%84%9F%E5%8F%97%E5%88%B0%E4%B8%AD%E6%96%AD"><span class="toc-text">1.2 sleep 期间能否感受到中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%9B%B8%E5%BA%94%E4%B8%AD%E6%96%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%80%E4%BD%B3%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">1.3 相应中断的两种最佳处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%8Crun-%E5%BC%BA%E5%88%B6-try-catch"><span class="toc-text">1.3.1 方法签名抛异常，run() 强制 try&#x2F;catch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-%E5%86%8D%E6%AC%A1%E4%B8%AD%E6%96%AD"><span class="toc-text">1.3.2 再次中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-volatile-%E6%A0%87%E8%AE%B0%E4%BD%8D%E7%9A%84%E5%81%9C%E6%AD%A2%E6%96%B9%E6%B3%95%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%9F"><span class="toc-text">2. 为什么 volatile 标记位的停止方法是错误的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E9%94%99%E8%AF%AF%E7%9A%84%E5%81%9C%E6%AD%A2%E6%96%B9%E6%B3%95"><span class="toc-text">2.1 错误的停止方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-volatile-%E4%BF%AE%E9%A5%B0%E6%A0%87%E8%AE%B0%E4%BD%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">2.2 volatile 修饰标记位使用的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-volatile-%E4%BF%AE%E9%A5%B0%E6%A0%87%E8%AE%B0%E4%BD%8D%E4%B8%8D%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">2.3 volatile 修饰标记位不适用的场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%BA%BF%E7%A8%8B%E7%9A%846%E4%B8%AD%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-text">三. 线程的6中状态的切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%846%E4%B8%AD%E7%8A%B6%E6%80%81"><span class="toc-text">1. 线程的6中状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-New-%E6%96%B0%E5%88%9B%E5%BB%BA"><span class="toc-text">1.1 New 新创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Runnable-%E5%8F%AF%E8%BF%90%E8%A1%8C"><span class="toc-text">1.2 Runnable 可运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-Blocked-%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81"><span class="toc-text">1.3 Blocked 阻塞状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-Waiting-%E7%AD%89%E5%BE%85"><span class="toc-text">1.4 Waiting 等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-Timed-Waiting-%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85"><span class="toc-text">1.5 Timed Waiting 限期等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-Terminated-%E7%BB%88%E6%AD%A2"><span class="toc-text">1.6 Terminated 终止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-wait-notify-notifyAll-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">四. wait&#x2F;notify&#x2F;notifyAll 方法的使用注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E5%9C%A8-synchronized-%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">1. 为什么 wait 方法必须在 synchronized 保护的同步代码中使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-wait-notify-notifyAll-%E8%A2%AB%E5%AE%9A%E4%B9%89%E5%9C%A8-Object-%E7%B1%BB%E4%B8%AD%EF%BC%8C%E8%80%8C-sleep-%E5%AE%9A%E4%B9%89%E5%9C%A8-Thread-%E7%B1%BB%E4%B8%AD%EF%BC%9F"><span class="toc-text">2. 为什么 wait&#x2F;notify&#x2F;notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-wait-notify-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">3. wait&#x2F;notify 和 sleep 方法的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">五. 有哪几种实现生产者消费者模式的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.1 生产者消费者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%A6%82%E4%BD%95%E7%94%A8-BlockingQueue-%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.2 如何用 BlockingQueue 实现生产者消费者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%A6%82%E4%BD%95%E7%94%A8-Condition-%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.3 如何用 Condition 实现生产者消费者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%A6%82%E4%BD%95%E7%94%A8-wait-notify-%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.4 如何用 wait&#x2F;notify 实现生产者消费者模式</span></a></li></ol></li></ol></li></ol>
</div></main>
          <aside class="left-column">
            
            <div class="card card-author">
              
<img src="/medias/avatar.jpg" class="author-img">

<p class="author-name">一个人的旅行</p>
<p class="author-description">冰冻三尺，非一日之寒；为山九仞，岂一日之功；不忘初心，方得始终！</p>
<div class="author-message">
  <a class="author-posts-count" href="/archives">
    <span>69</span>
    <span>文章</span>
  </a>
  <a class="author-categories-count" href="/categories">
    <span>14</span>
    <span>分类</span>
  </a>
  <a class="author-tags-count" href="/tags">
    <span>47</span>
    <span>标签</span>
  </a>
</div>

<div class="author-card-society">
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="https://github.com/onestravel">
        <i class="iconfont icon-github society-icon"></i>
      </a>
    </div>
  
    <div class="author-card-society-icon">
      <a href="mailto:service@onestravel.cn">
        <i class="iconfont icon-mail society-icon"></i>
      </a>
    </div>
  
</div>

            </div>
            
            <div class="sticky-tablet">
  
  
  <article class="display-when-two-columns spacer">
    <div class="card card-content toc-card">
      <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">【并发编程】线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">一. 实现线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BD%95%E8%AF%B4%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">1. 为何说只有一种实现线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">1.1 常见的实现线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-text">1.1.1 继承Thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3"><span class="toc-text">1.1.2 实现 Runnable 接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.1.3 线程池创建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-4-%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84-Callable-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.1.4 有返回值的 Callable 创建线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%80%BB%E7%BB%93%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2 总结，为什么实现线程只有一种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3%E6%AF%94%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E8%A6%81%E5%A5%BD"><span class="toc-text">2. 为什么说实现 Runnable 接口比继承 Thread 类实现线程要好</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">二. 如何正确停止线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%AD%A3%E7%A1%AE%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">1. 正确停止线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%94%A8-interrupt-%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.1 用 interrupt 停止线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-sleep-%E6%9C%9F%E9%97%B4%E8%83%BD%E5%90%A6%E6%84%9F%E5%8F%97%E5%88%B0%E4%B8%AD%E6%96%AD"><span class="toc-text">1.2 sleep 期间能否感受到中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%9B%B8%E5%BA%94%E4%B8%AD%E6%96%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%80%E4%BD%B3%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">1.3 相应中断的两种最佳处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%8Crun-%E5%BC%BA%E5%88%B6-try-catch"><span class="toc-text">1.3.1 方法签名抛异常，run() 强制 try&#x2F;catch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-%E5%86%8D%E6%AC%A1%E4%B8%AD%E6%96%AD"><span class="toc-text">1.3.2 再次中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-volatile-%E6%A0%87%E8%AE%B0%E4%BD%8D%E7%9A%84%E5%81%9C%E6%AD%A2%E6%96%B9%E6%B3%95%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%9F"><span class="toc-text">2. 为什么 volatile 标记位的停止方法是错误的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E9%94%99%E8%AF%AF%E7%9A%84%E5%81%9C%E6%AD%A2%E6%96%B9%E6%B3%95"><span class="toc-text">2.1 错误的停止方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-volatile-%E4%BF%AE%E9%A5%B0%E6%A0%87%E8%AE%B0%E4%BD%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">2.2 volatile 修饰标记位使用的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-volatile-%E4%BF%AE%E9%A5%B0%E6%A0%87%E8%AE%B0%E4%BD%8D%E4%B8%8D%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">2.3 volatile 修饰标记位不适用的场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%BA%BF%E7%A8%8B%E7%9A%846%E4%B8%AD%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-text">三. 线程的6中状态的切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%846%E4%B8%AD%E7%8A%B6%E6%80%81"><span class="toc-text">1. 线程的6中状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-New-%E6%96%B0%E5%88%9B%E5%BB%BA"><span class="toc-text">1.1 New 新创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Runnable-%E5%8F%AF%E8%BF%90%E8%A1%8C"><span class="toc-text">1.2 Runnable 可运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-Blocked-%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81"><span class="toc-text">1.3 Blocked 阻塞状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-Waiting-%E7%AD%89%E5%BE%85"><span class="toc-text">1.4 Waiting 等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-Timed-Waiting-%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85"><span class="toc-text">1.5 Timed Waiting 限期等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-Terminated-%E7%BB%88%E6%AD%A2"><span class="toc-text">1.6 Terminated 终止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-wait-notify-notifyAll-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">四. wait&#x2F;notify&#x2F;notifyAll 方法的使用注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E5%9C%A8-synchronized-%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">1. 为什么 wait 方法必须在 synchronized 保护的同步代码中使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-wait-notify-notifyAll-%E8%A2%AB%E5%AE%9A%E4%B9%89%E5%9C%A8-Object-%E7%B1%BB%E4%B8%AD%EF%BC%8C%E8%80%8C-sleep-%E5%AE%9A%E4%B9%89%E5%9C%A8-Thread-%E7%B1%BB%E4%B8%AD%EF%BC%9F"><span class="toc-text">2. 为什么 wait&#x2F;notify&#x2F;notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-wait-notify-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">3. wait&#x2F;notify 和 sleep 方法的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">五. 有哪几种实现生产者消费者模式的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.1 生产者消费者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%A6%82%E4%BD%95%E7%94%A8-BlockingQueue-%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.2 如何用 BlockingQueue 实现生产者消费者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%A6%82%E4%BD%95%E7%94%A8-Condition-%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.3 如何用 Condition 实现生产者消费者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%A6%82%E4%BD%95%E7%94%A8-wait-notify-%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.4 如何用 wait&#x2F;notify 实现生产者消费者模式</span></a></li></ol></li></ol></li></ol>
    </div>
  </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header"><i class="iconfont icon-fenlei" style="padding-right: 2px;"></i>分类</div>
  <div class="categories-list">
    
      <a href="/categories/NDK/">
        <div class="categories-list-item">
          NDK
          <span class="categories-list-item-badge">5</span>
        </div>
      </a>
    
      <a href="/categories/Android/">
        <div class="categories-list-item">
          Android
          <span class="categories-list-item-badge">9</span>
        </div>
      </a>
    
      <a href="/categories/CPlusPlus/">
        <div class="categories-list-item">
          CPlusPlus
          <span class="categories-list-item-badge">6</span>
        </div>
      </a>
    
      <a href="/categories/C/">
        <div class="categories-list-item">
          C
          <span class="categories-list-item-badge">5</span>
        </div>
      </a>
    
      <a href="/categories/前端H5/">
        <div class="categories-list-item">
          前端H5
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/JNI/">
        <div class="categories-list-item">
          JNI
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/算法/">
        <div class="categories-list-item">
          算法
          <span class="categories-list-item-badge">18</span>
        </div>
      </a>
    
      <a href="/categories/DevTools/">
        <div class="categories-list-item">
          DevTools
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/SpringBoot/">
        <div class="categories-list-item">
          SpringBoot
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/Jenkins/">
        <div class="categories-list-item">
          Jenkins
          <span class="categories-list-item-badge">5</span>
        </div>
      </a>
    
      <a href="/categories/Kotlin/">
        <div class="categories-list-item">
          Kotlin
          <span class="categories-list-item-badge">8</span>
        </div>
      </a>
    
      <a href="/categories/Linux/">
        <div class="categories-list-item">
          Linux
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/JAVA/">
        <div class="categories-list-item">
          JAVA
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/Git/">
        <div class="categories-list-item">
          Git
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header"><i class="iconfont icon-biaoqian" style="padding-right: 2px;"></i>热门标签</div>
  <div class="tags-list">
    
    <a href="/tags/Android/" title="Android"><div class="tags-list-item">Android</div></a>
    
    <a href="/tags/Kotlin/" title="Kotlin"><div class="tags-list-item">Kotlin</div></a>
    
    <a href="/tags/CPlusPlus/" title="CPlusPlus"><div class="tags-list-item">CPlusPlus</div></a>
    
    <a href="/tags/NDK/" title="NDK"><div class="tags-list-item">NDK</div></a>
    
    <a href="/tags/C/" title="C"><div class="tags-list-item">C</div></a>
    
    <a href="/tags/JVM/" title="JVM"><div class="tags-list-item">JVM</div></a>
    
    <a href="/tags/数组/" title="数组"><div class="tags-list-item">数组</div></a>
    
    <a href="/tags/自动化部署/" title="自动化部署"><div class="tags-list-item">自动化部署</div></a>
    
    <a href="/tags/Jenkins/" title="Jenkins"><div class="tags-list-item">Jenkins</div></a>
    
    <a href="/tags/斐波那契数列/" title="斐波那契数列"><div class="tags-list-item">斐波那契数列</div></a>
    
    <a href="/tags/Intellij-IDEA/" title="Intellij IDEA"><div class="tags-list-item">Intellij IDEA</div></a>
    
    <a href="/tags/html/" title="html"><div class="tags-list-item">html</div></a>
    
    <a href="/tags/JNI/" title="JNI"><div class="tags-list-item">JNI</div></a>
    
    <a href="/tags/Linux/" title="Linux"><div class="tags-list-item">Linux</div></a>
    
    <a href="/tags/矩阵/" title="矩阵"><div class="tags-list-item">矩阵</div></a>
    
    <a href="/tags/centos/" title="centos"><div class="tags-list-item">centos</div></a>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
          <aside class="right-column">
            <div class="sticky-widescreen">
  
  
  <article class="card card-content toc-card">
    <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">【并发编程】线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">一. 实现线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BD%95%E8%AF%B4%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">1. 为何说只有一种实现线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">1.1 常见的实现线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-text">1.1.1 继承Thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3"><span class="toc-text">1.1.2 实现 Runnable 接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.1.3 线程池创建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-4-%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84-Callable-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.1.4 有返回值的 Callable 创建线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%80%BB%E7%BB%93%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2 总结，为什么实现线程只有一种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3%E6%AF%94%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E8%A6%81%E5%A5%BD"><span class="toc-text">2. 为什么说实现 Runnable 接口比继承 Thread 类实现线程要好</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">二. 如何正确停止线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%AD%A3%E7%A1%AE%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">1. 正确停止线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%94%A8-interrupt-%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.1 用 interrupt 停止线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-sleep-%E6%9C%9F%E9%97%B4%E8%83%BD%E5%90%A6%E6%84%9F%E5%8F%97%E5%88%B0%E4%B8%AD%E6%96%AD"><span class="toc-text">1.2 sleep 期间能否感受到中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%9B%B8%E5%BA%94%E4%B8%AD%E6%96%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%80%E4%BD%B3%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">1.3 相应中断的两种最佳处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%EF%BC%8Crun-%E5%BC%BA%E5%88%B6-try-catch"><span class="toc-text">1.3.1 方法签名抛异常，run() 强制 try&#x2F;catch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-%E5%86%8D%E6%AC%A1%E4%B8%AD%E6%96%AD"><span class="toc-text">1.3.2 再次中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-volatile-%E6%A0%87%E8%AE%B0%E4%BD%8D%E7%9A%84%E5%81%9C%E6%AD%A2%E6%96%B9%E6%B3%95%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%9F"><span class="toc-text">2. 为什么 volatile 标记位的停止方法是错误的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E9%94%99%E8%AF%AF%E7%9A%84%E5%81%9C%E6%AD%A2%E6%96%B9%E6%B3%95"><span class="toc-text">2.1 错误的停止方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-volatile-%E4%BF%AE%E9%A5%B0%E6%A0%87%E8%AE%B0%E4%BD%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">2.2 volatile 修饰标记位使用的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-volatile-%E4%BF%AE%E9%A5%B0%E6%A0%87%E8%AE%B0%E4%BD%8D%E4%B8%8D%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">2.3 volatile 修饰标记位不适用的场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%BA%BF%E7%A8%8B%E7%9A%846%E4%B8%AD%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-text">三. 线程的6中状态的切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%846%E4%B8%AD%E7%8A%B6%E6%80%81"><span class="toc-text">1. 线程的6中状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-New-%E6%96%B0%E5%88%9B%E5%BB%BA"><span class="toc-text">1.1 New 新创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Runnable-%E5%8F%AF%E8%BF%90%E8%A1%8C"><span class="toc-text">1.2 Runnable 可运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-Blocked-%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81"><span class="toc-text">1.3 Blocked 阻塞状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-Waiting-%E7%AD%89%E5%BE%85"><span class="toc-text">1.4 Waiting 等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-Timed-Waiting-%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85"><span class="toc-text">1.5 Timed Waiting 限期等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-Terminated-%E7%BB%88%E6%AD%A2"><span class="toc-text">1.6 Terminated 终止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-wait-notify-notifyAll-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">四. wait&#x2F;notify&#x2F;notifyAll 方法的使用注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E5%9C%A8-synchronized-%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">1. 为什么 wait 方法必须在 synchronized 保护的同步代码中使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-wait-notify-notifyAll-%E8%A2%AB%E5%AE%9A%E4%B9%89%E5%9C%A8-Object-%E7%B1%BB%E4%B8%AD%EF%BC%8C%E8%80%8C-sleep-%E5%AE%9A%E4%B9%89%E5%9C%A8-Thread-%E7%B1%BB%E4%B8%AD%EF%BC%9F"><span class="toc-text">2. 为什么 wait&#x2F;notify&#x2F;notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-wait-notify-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">3. wait&#x2F;notify 和 sleep 方法的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">五. 有哪几种实现生产者消费者模式的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.1 生产者消费者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%A6%82%E4%BD%95%E7%94%A8-BlockingQueue-%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.2 如何用 BlockingQueue 实现生产者消费者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%A6%82%E4%BD%95%E7%94%A8-Condition-%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.3 如何用 Condition 实现生产者消费者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%A6%82%E4%BD%95%E7%94%A8-wait-notify-%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.4 如何用 wait&#x2F;notify 实现生产者消费者模式</span></a></li></ol></li></ol></li></ol>
  </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header"><i class="iconfont icon-wenzhang_huaban" style="padding-right: 2px;"></i>最近文章</div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-09-20</div>
        <a href="/20210920/f8c53c115779/"><div class="recent-posts-item-content">【并发编程】线程基础</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-07-28</div>
        <a href="/20210728/9c2efe6aefcb/"><div class="recent-posts-item-content">【笔记四】编译插桩操纵字节码，实现不可能完成的任务</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-05-28</div>
        <a href="/20210528/618470f841d8/"><div class="recent-posts-item-content">【笔记三】字节码层面分析 class 文件结构</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-03-28</div>
        <a href="/20210328/68b72d473df5/"><div class="recent-posts-item-content">【笔记二】GC 回收机制和分代回收策略</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
        </div>
      </div>
    </div>
  </div>
  
  <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>Copyright ©
          
          2020 -
          
          2022
        </span>
        &nbsp;
        <a href="/" class="footer-link">一个人的旅行 </a>
      </div>
    </div>

    
    <div class="footer-dsc">
      
      Powered by
      <a href="https://hexo.io/" class="footer-link" target="_blank" rel="nofollow noopener noreferrer">&nbsp;Hexo </a>
      
      
      <span>&nbsp;|&nbsp;</span>
      
      
      Theme -
      <a href="https://github.com/theme-kaze" class="footer-link" target="_blank"
        rel="nofollow noopener noreferrer">&nbsp;Kaze</a>
      
    </div>
    
    
    
    
      <div class="footer-dsc">
        
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
        
        <span>&nbsp;|&nbsp;</span>
        
        
        本站总访客数<span id="busuanzi_value_site_uv"></span>次
        
      </div>
      
    
</footer>
  <a role="button" id="scrollbutton" class="basebutton"  aria-label="回到顶部">
  <i class="iconfont icon-arrowleft button-icon"></i>
</a>
<a role="button" id="menubutton" class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a role="button" id="popbutton" class="basebutton" aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a role="button" id="darkbutton" class="basebutton darkwidget" aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a role="button" id="searchbutton" class="basebutton searchwidget" aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a>

  
  
  

  
  
  <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img');
    var i;
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a');
      wrapper.setAttribute('href', img[i].getAttribute('data-src'));
      wrapper.setAttribute('aria-label', 'illustration');
      wrapper.style.cssText = 'width: 100%; display: flex; justify-content: center;';
      if (img[i].alt) wrapper.dataset.caption = img[i].alt;
      wrapper.dataset.nolink = true;
      img[i].before(wrapper);
      wrapper.append(img[i]);
      var divWrap = document.createElement('div');
      divWrap.classList.add('gallery');
      wrapper.before(divWrap);
      divWrap.append(wrapper);
    }
    baguetteBox.run('.gallery');
  }
</script>
<script>loadScript("/js/lib/lightbox/baguetteBox.min.js", addImgLayout)</script>
  
  
  
<script src="/js/main.js"></script>

  
  <script>loadScript("/js/lib/busuanzi.min.js")</script>
  
  
  <script>
    var addLazyload = function () {
      var observer = lozad('.lozad', {
        load: function (el) {
          el.srcset = el.getAttribute('data-src');
        },
        loaded: function (el) {
          el.classList.add('loaded');
        }
      });
      observer.observe();
    }
  </script>
  <script>loadScript("/js/lib/lozad.min.js", addLazyload)</script>
  
  
  <script>
    var googleAnalytics = function() {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-145377665-1');
    }
  </script>
  <script>loadScript("https://www.googletagmanager.com/gtag/js?id=" + "UA-145377665-1", googleAnalytics)</script>
  
</body>

</html>